<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-12-19T08:54:09+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android开发问题汇总]]></title>
    <link href="http://DamianSheldon.github.io/blog/problems-of-android-development.html/"/>
    <updated>2014-12-17T09:38:20+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/problems-of-android-development</id>
    <content type="html"><![CDATA[<h3>Android Studio SDK Components安装提示操作超时</h3>

<p><code>
// MacOS
$ vim /etc/hosts
203.208.46.146 dl.google.com
203.208.46.146 dl-ssl.google.com
</code></p>

<h3>Android Studio Check Updates提示连接出错</h3>

<p>```
// MacOS
$ vim /Applications/Android\ Studio.app/Contents/Info.plist</p>

<p>// 搜索 VMOptions</p>

<p>// 添加如下内容
-Djava.net.preferIPv4Stack=true
-Didea.updates.url=<a href="http://dl.google.com/android/studio/patches/updates.xml">http://dl.google.com/android/studio/patches/updates.xml</a>
-Didea.patches.url=<a href="http://dl.google.com/android/studio/patches/">http://dl.google.com/android/studio/patches/</a></p>

<p>// 结果
<key>VMOptions</key>
<string>
-Dfile.encoding=UTF-8 -ea
-Dsun.io.useCanonCaches=false
-Djava.net.preferIPv4Stack=true
 -Djna.nosys=true
 -Djna.boot.library.path=<br/>
 -Djna.debug_load=true
 -Djna.debug_load.jna=true
 -Djsse.enableSNIExtension=false
 -XX:+UseCodeCacheFlushing
 -XX:+UseConcMarkSweepGC
 -XX:SoftRefLRUPolicyMSPerMB=50
 -Xverify:none -Xbootclasspath/a:../lib/boot.jar
 -Djava.net.preferIPv4Stack=true
 -Didea.updates.url=<a href="http://dl.google.com/android/studio/patches/updates.xml">http://dl.google.com/android/studio/patches/updates.xml</a>
 -Didea.patches.url=<a href="http://dl.google.com/android/studio/patches/">http://dl.google.com/android/studio/patches/</a>
 </string></p>

<p>// 重启 Android Studio
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App如何与Server安全交互]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-does-app-security-communicate-with-server.html/"/>
    <updated>2014-12-15T11:53:11+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-does-app-security-communicate-with-server</id>
    <content type="html"><![CDATA[<p>大多数App都需和Server通信来提供服务，这中间就牵涉到网络通信安全。网络通信安全是一个很大的话题，本文不打算全面覆盖，而是来理理HTTPS。</p>

<p>移动设备可能会处于不安全的网络环境中，比如连接了某个公共热点，攻击者不需要访问设备，只需访问设备所在的网络，就能获取到用户信息，所以，当应用中用户的信息需要保护时，开发者需要保证通信的安全性。</p>

<p>最简单直接的解决办法是采用HTTPS,在web服务器上安装一个自签名证书，启用HTTPS,然后对NSURLConnection进行配置以接受该自签名证书。</p>

<p>HTTPS是如何做到通信安全的呢？答案是TLS/SSL协议。TLS(Transport Layer Security)/SSL(Secure Socket  Layer)协议是专门为解决网络通信安全设计的。它的基石是非对称加密。</p>

<p>TLS/SSL链路中的数据是加密的，客户端给服务器发送的数据是用服务器的公钥加密的，由于非对称加密的数学特性，只有拥有私钥的服务器才能正确解密数据。服务器给客户端发送的数据则是用自己的私钥加密的，客户端用公钥解密。</p>

<p>那么我们如何判断服务器发给我们的公钥是值得信任的呢？通常商业网站的数字证书都是由中级证书或根证书来签名，而根证书是一开始就内置在设备中，不是通过网络交换的，这样当某个服务器声明说我是某某，我们可以通过证书链来判断真伪。</p>

<p>根证书其实是一个自签名证书，我们的应用也可以用自签名证书来确保网络通信安全，还可以省掉很大一笔证书费用，只要私钥足够安全，它甚至比商业证书更安全。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App State Preservation and Restoration]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-state-preservation-and-restoration.html/"/>
    <updated>2014-12-08T11:55:48+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-state-preservation-and-restoration</id>
    <content type="html"><![CDATA[<ol>
<li>什么是State Preservation and Restoration？</li>
<li>为什么要用State Preservation and Restoration？</li>
<li>如何使用State Preservation and Restoration？</li>
</ol>


<h3>什么是State Preservation and Restoration？</h3>

<p>State Preservation and Restoration组成UIKit的state preservation system，它提供简单而灵活的架构来保存和恢复应用的视图控制器和视图。</p>

<h3>为什么要用State Preservation and Restoration？</h3>

<blockquote><p>Even if your app supports background execution, it cannot run forever. At some point, the system might need to terminate your app to free up memory for the current foreground app. However, the user should never have to care if an app is already running or was terminated. From the user’s perspective, quitting an app should just seem like a temporary interruption. When the user returns to an app, that app should always return the user to the last point of use, so that the user can continue with whatever task was in progress. This behavior provides a better experience for the user and with the state restoration support built in to UIKit is relatively easy to achieve.</p></blockquote>

<p>即使你的应用支持后台运行，它也不可能一直运行。某个时刻，系统也许需要终止你的应用为当前应用释放内存。然而，用户应该永远不用关心应用是已经运行或终止。从用户的角度来看，退出应用应该就像暂时的中断。当用户回到应用，它应该回到上次使用的状态，以便用户能继续任何正在进行的任务。这种行为为用户提供了更好的体验，UIKit内置了这种状态恢复支持很容易就能实现。</p>

<!-- more -->


<h3>如何使用State Preservation and Restoration？</h3>

<p>State Restoreation成功的前提条件如下： <br/>
1. <strong>状态保留必须成功。</strong>也就是说应用终止前必须进入后台运行状态。 <br/>
2. <strong>应用不可以强制退出。</strong> <br/>
3. <strong>从最近一次状态保留开始，应用必须没有启动失败过。</strong></p>

<p>Checklist for Implementing State Preservation and Restoration</p>

<ol>
<li>(Required) Implement the <code>application:shouldSaveApplicationState:</code> and <code>application:shouldRestoreApplicationState:</code>methods in your app delegate;</li>
<li>(Required) Assign restoration identifiers to each view controller you want to preserve by assigning a non empty string to their <code>restorationIdentifier</code> property;If you want to save the state of specific views too, assign non empty strings to their <code>restorationIdentifier</code> properties;</li>
<li>(Required) Show your app’s window from the <code>application:willFinishLaunchingWithOptions:</code> method of your app delegate. The state restoration machinery needs the window so that it can restore scroll positions and other relevant bits of your app’s interface.</li>
<li>Assign restoration classes to the appropriate view controllers. (If you do not do this, your app delegate is asked to provide the corresponding view controller at restore time.)</li>
<li>(Recommended) Encode and decode the state of your views and view controllers using the <code>encodeRestorableStateWithCoder:</code> and <code>decodeRestorableStateWithCoder:</code> methods of those objects;</li>
<li>Encode and decode any version information or additional state information for your app using the <code>application:willEncodeRestorableStateWithCoder:</code> and <code>application:didDecodeRestorableStateWithCoder:</code> methods of your app delegate;</li>
<li>Objects that act as data sources for table views and collection views should implement the <strong>UIDataSourceModelAssociation</strong> protocol. Although not required, this protocol helps preserve the selected and visible items in those types of views.</li>
</ol>


<h3>注意事项</h3>

<div style="text-align: center" markdown="1">

    <img name="state_vc_caveats_2x" src="http://DamianSheldon.github.io/images/state_vc_caveats_2x.png" width="594" height="862">

</div>


<p>上图有颜色的视图控制器的状态是不会被保存和恢复的。</p>

<h3>Reference</h3>

<p>App Programming Guide for iOS</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建自定义的Xcode 6 工程模板]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-to-creating-custom-xcode-6-project-templates.html/"/>
    <updated>2014-12-05T14:34:04+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-to-creating-custom-xcode-6-project-templates</id>
    <content type="html"><![CDATA[<p>使用Xcode 6新建工程时，Apple准备了好些模板，这些模板写个Demo还是没有问题的，但是用来组织项目文件还是太弱了，所以情况经常是不得不每次去新建各种目录，这种重复性的劳动一来乏味，二来浪费时间。那么我们能不像创建自己的模板呢？这样新建的工程就能按自己的想法包含各种目录和文件。好消息是可以，坏消息是Apple没有提供相应的文档。虽然没有文档，还是试着来创建一个模板，每次都重复实在太烦（就是这么任性）。</p>

<p>既然没有文档，我们就把Apple的模板复制一份，在它的基础上修改成我们需要的样子。<strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/</strong>有iOS所有工程模板。用户自定义的模板建议放到<strong>~/Library/Developer/Xcode/Templates/</strong>，目录如果不存在就创建。模板至少要包含两部分：一是扩展名为<strong>.xctemplate</strong>的文件夹；二是名称为<strong>TemplateInfo.plist</strong>的属性列表文件。好了，我们来创建一个自定义模板：</p>

<p>```
// Step 1:
$ mkdir ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>// Step 2:
$ cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/Single\ View\ Application.xctemplate/* ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>```</p>

<!-- more -->


<p>现在我们有了一个和Single View Application一样的模板，但这和我们目标还相差很远。接下来我们要做就是修改<strong>TemplateInfo.plist</strong>，让模板为我们做更多准备工作。</p>

<table>
<thead>
<tr>
<th></th>
<th> Keys </th>
<th> Advice </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Ancestors   </td>
<td> No          | Import settings from another Project Template.</td>
</tr>
<tr>
<td></td>
<td> Concrete    </td>
<td> Recommended | Visible or hide Template form New Project Window.</td>
</tr>
<tr>
<td></td>
<td> Definitions </td>
<td> No          | Work with workplace. Can write to file example source code.</td>
</tr>
<tr>
<td></td>
<td> Description </td>
<td> Recommended | New Project Window &ndash; Project Template Description.</td>
</tr>
<tr>
<td></td>
<td> Identifier  </td>
<td> Yes         | Project Template Unique Identifier.</td>
</tr>
<tr>
<td></td>
<td> Kind        </td>
<td> Yes         | XCode Template Kind. Project or File.</td>
</tr>
<tr>
<td></td>
<td> Nodes       </td>
<td> Recommended | Create or Copy Files to Project. Copy works</td>
</tr>
<tr>
<td></td>
<td> Options     </td>
<td> Recommended | New Project Wizard >> Choose Options for Project. Add Text Fields, Combo Boxes.</td>
</tr>
<tr>
<td></td>
<td> Platforms   </td>
<td> Recommended | Set Platform.</td>
</tr>
<tr>
<td></td>
<td> Project     </td>
<td> Yes         | Set Project Build Settings.</td>
</tr>
<tr>
<td></td>
<td> Targets     </td>
<td> Recommended | Set Build Settings, Build Phases for Targets. Link Libraries.</td>
</tr>
</tbody>
</table>


<p>上面列出了TemplateInfo.plist大部分键，详细介绍在<a href="https://snipt.net/yonishin/about-xcode-4-project-template/">这里</a>。</p>

<p>我自己新建的模板主要用到Definitions和Nodes，它们俩组合起来可以控制模板会新建哪些文件。例如我想让模板包含Models目录：</p>

<p>```
// Step 1:
$ cd ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>// Step 2:
$ mkdir -p Models</p>

<p>// Step 3: 编辑TemplateInfo.plist 如下图所示。</p>

<p>```</p>

<div style="text-align: center" markdown="1">

    <img name="PropertyList" src="http://DamianSheldon.github.io/images/PropertyList.png" width="623" height="836">

</div>


<p>完整的模板放在<a href="https://github.com/DamianSheldon/Xcode-6-Project-Templates">这里</a>。</p>

<h2>Reference</h2>

<p><a href="http://meandmark.com/blog/2011/12/creating-custom-xcode-4-project-templates/">Creating Custom Xcode 4 Project Templates</a><br/>
<a href="https://snipt.net/yonishin/about-xcode-4-project-template/">About XCode 4 Project Template (How To Create Custom Project Template)</a><br/>
<a href="https://github.com/reidmain/Xcode-6-Project-Templates">Xcode-6-Project-Templates</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App Cache]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-cache.html/"/>
    <updated>2014-11-25T16:36:04+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-cache</id>
    <content type="html"><![CDATA[<p>在互联网时代的今天，iOS App几乎都要联网，缓存可以解决网络连接不良甚至无网络所造成的性能问题，而且还可以节约用户的流量。我们可以采用两种缓存策略：预缓存和按需缓存。预缓存就是应用启动以后开个后台线程去把需要用到的数据先取下来。按需缓存就是应用请求网络数据后在本地保存一份，只要本地数据没有过期就使用本地数据。</p>

<h3>预缓存</h3>

<p>实现预缓存可能需要一个后台线程访问数据并以有意义的格式保存，以便本地缓存无需连接服务器即可被编辑。Core Data(或者任何结构化存储)是实现这种缓存的一种方式。</p>

<h3>按需缓存</h3>

<p>按需缓存工作原理类似于浏览器缓存，它允许我们查看以前访问过的内容，主要有四种实现方法：</p>

<ol>
<li>URL缓存；</li>
<li>数据模型缓存；</li>
<li>Core Data;</li>
<li>SQLite。</li>
</ol>


<p>上述的序号是推荐使用的顺序。</p>

<h4>URL缓存</h4>

<p>如果服务器设计得体，遵循HTTP 1.1的缓存规范时，URL缓存效果最好，通常网络库会提供支持。</p>

<!-- more -->


<h4>数据模型缓存</h4>

<p>数据模型缓存是把模型对象用NSKeyedArchiver归档，模型类需要实现NSCoding协议。</p>

<p>使用数据模型缓存时，有个小技巧，可以为它创建内存缓存。这样有两点好处：一是可以延长闪存的使用寿命；二是可以略微提高性能。</p>

<h4>Core Data</h4>

<p>使用Core Data进行按需缓存，需要权衡Core Data的复杂度是否值得。</p>

<h4>SQLite</h4>

<p>使用SQLite时，要注意当前的二进制包是否是线程安全的。</p>

<h2>Reference</h2>

<p>iOS 6 Programming Push the Limits</p>
]]></content>
  </entry>
  
</feed>
