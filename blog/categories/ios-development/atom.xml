<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS Development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-10-08T15:28:32+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Core Animation 笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji/"/>
    <updated>2014-09-03T09:59:58+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji</id>
    <content type="html"><![CDATA[<h2>Core Animation介绍</h2>

<p>Core Animation is a graphics rendering and animation infrastructure available on both iOS and OS X that you use to animate the views and other visual elements of your app.</p>

<h2>什么时候使用Core Animation?</h2>

<p>In places where you want to perform more sophisticated animations, or animations not supported by the UIView class, you can use Core Animation and the view’s underlying layer to create the animation. Because view and layer objects are intricately linked together, changes to a view’s layer affect the view itself.</p>

<h2>如何使用Core Animation?</h2>

<p>  1)Enabling Core Animation Support in Your App;<br/>
  In iOS apps, Core Animation is always enabled and every view is backed by a layer.iOS apps must link against this framework only if they use Core Animation interfaces explicitly.</p>

<p>  2)Selecting a appropriate Layer Object Associated with a View;<br/>
  Reference:Core Animation Programming Guide &mdash; Different Layer Classes Provide Specialized Behaviors</p>

<p>  3)Add animation to layer.<br/>
  CABasicAnimation provides basic, single-keyframe animation capabilities for a layer property.<br/>
  The CAKeyframeAnimation class provides keyframe animation capabilities for a layer object.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App 开发遇到的问题]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti/"/>
    <updated>2014-08-25T17:09:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>  问题描述：Storyboard中的ViewController上添加一个自定义的view,声明为IBOutlet然后用代码改变view的Frame,打印输出Frame的值确实改变了，但是模拟器上的视图的Frame还是没有改变。</p>

<p>  解决办法：Google找到Stackoverflow上有人说是选中了Auto layout的原因，取消之后确实生效了。PS:但是不知道问题的原因是什么。</p>

<p>Reference:<br/>
o <a href="http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work">http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work</a></p>

<p>问题描述：在switch语句中，如果在case中要定义变量的话要加上大括号。</p>

<p>原因：Case statements are only &lsquo;labels&rsquo;. This means the compiler will interpret this as a jump directly to the label.The problem here is one of scope. Your curly brackets define the scope as everything inside the &lsquo;switch&rsquo; statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that case statement and define your variable within it.</p>

<p>Reference:<a href="http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439">http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)如何让didUpdateLocation兼容iOS 5和iOS 6]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/07/28/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/"/>
    <updated>2014-07-28T16:05:38+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/07/28/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6</id>
    <content type="html"><![CDATA[<p><code>- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation</code>是CLLocationManagerDelegate protocol中的一个常用方法，它让你的应用接收更新位置信息，当检测到任何位置变化。新的位置详情存储在newLocation中，它是一个CLLocation.<br/>
当iOS6启动，上述方法被废弃了，建议使用新版本方法<code>- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations</code>或简称locationManager:didUpdateLocations:.</p>

<p>这个快速教程的的创建目的是为了解释如何处理废弃方法，关于它什么是应该完成的以及你在哪里可以找出关于改变的更多细节。如果你想了解如何使用这个新的locationManager:didUpdateLocations: 方法，看下<a href="http://www.devfright.com/didupdatelocations-ios-example/">didUpdateLocations tutorial</a>，它解释了如何使用方法提供的NSArray.</p>

<h3>当方法被废弃了</h3>

<p>当iOS升级了（这很经常），Apple找到新的或更有效方法。当这发生了，方法可以被标记为废弃并在如何使用的地方给出一个提示。具体到CLLocationManagerDelegate，你可以看到文档中推荐了一个不同的方法。虽然你仍然可以使用废弃的方法，即使是在已经废弃的iOS版本中，Apple在未来某个时间点也许会删除掉这个方法当iOS升级了。在那个时间点，你可能需要修改你的代码，提交到Apple Store通过审核流程。</p>

<h3>如何处理废弃的方法</h3>

<p>已经被废弃的方法在新的iOS版本上仍然可以工作。Apple趋向于让它们在未来的几个新版本中保持可用，然后再将它们从类或协议中删除。与其让你的代码在最后关头更新或重新提交到苹果商店。你可以在改变之前做好准备。</p>

<p>今天的例子，我们会看下 locationManager:didUpdateToLocation:fromLocation:方法以及如何让旧的废弃方法和新的方法在同一份代码中共同工作。<br/>
``` objective-c</p>

<p>&ndash;(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *newLocation = [locations lastObject];
CLLocation *oldLocation = [locations objectAtIndex:locations.count-1];
NSLog(@"didUpdateToLocation %@ from %@", newLocation, oldLocation);
MKCoordinateRegion userLocation = MKCoordinateRegionMakeWithDistance(newLocation.coordinate, 1500.0, 1500.0);
[regionsMapView setRegion:userLocation animated:YES];
</code></pre>

<p>}
<code>
为了兼容iOS 5,我们可以加入旧的方法`- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation`，并在旧的方法中调用新的方法，代码看起来会像这样：
</code> objective-c
&ndash;(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *newLocation = [locations lastObject];
CLLocation *oldLocation;
if (locations.count &gt;= 2) {
    oldLocation = [locations objectAtIndex:locations.count-1];
} else {
    oldLocation = nil;
}
NSLog(@"didUpdateToLocation %@ from %@", newLocation, oldLocation);
MKCoordinateRegion userLocation = MKCoordinateRegionMakeWithDistance(newLocation.coordinate, 1500.0, 1500.0);
[regionsMapView setRegion:userLocation animated:YES];
</code></pre>

<p>}</p>

<ul>
<li>(void)locationManager:(CLLocationManager <em>)manager didUpdateToLocation:(CLLocation </em>)newLocation fromLocation:(CLLocation *)oldLocation {
  [self locationManager:locationManager didUpdateLocations:[[NSArray alloc] initWithObjects:newLocation, nil]];
}
```</li>
</ul>


<p>如果是iOS5，新的方法不会被调用，它就像自定义的方法，iOS5并不知道locationManager:didUpdateLocations:事实上是什么。旧的方法简单的alloc/init新的名为currentLocation的NSArray并且使用 initWithObjects:newLocation获取一个newLocation,然后NSArray作为信息被传递到locationManager新的方法。</p>

<p>总之，如果设备是iOS5,旧的方法locationManager:didUpdateToLocation:fromLocation: 告诉代理新的位置可用，它把CLLocation加到NSArray中传递给新的方法，但设备的操作系统并不知道新方法。</p>

<p>如果使用的是iOS6,我们从CLLocationManagerDelegate的头文件中了解到如果代码中既有旧方法又有新方法，那么iOS会调用新方法通知代理位置更新了。</p>

<p>虽然这个快速教程提供了一种处理废弃方法的办法，仍然会有其他很多不同的办法。另外，多查看文档和关文件，因为Apple添加了很多信息，它们很有可能会为你手头的任务提供解决办法。</p>

<p>原文<br/>
o <a href="http://www.devfright.com/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/">http://www.devfright.com/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Properties]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties/"/>
    <updated>2014-06-24T15:28:20+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties</id>
    <content type="html"><![CDATA[<h3>Properties</h3>

<p>“Properties associate values with a particular class, structure, or enumeration. ” &mdash; Apple</p>

<h4>Type Properties</h4>

<p>属于类型本身的properties称为Type Property.</p>

<p>1)Value Type Properties (keyword: static)<br/>
structrue, enumeration可以定义Stroed 和Computed type properties.</p>

<p>Stored type properties for value types can be variables or constants.<br/>
NOTE:Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<p>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</p>

<p>2)Reference Type Properties (keyword: class)<br/>
class只可以定义Computed type properties.</p>

<h4>Instance Properties</h4>

<p>1)Stroed Properties
In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</p>

<p>P.S:A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p>2)Computed Properties
computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>

<h3>Properties Observer</h3>

<p>Property observers observe and respond to changes in a property’s value.</p>

<p>You have the option to define either or both of these observers on a property:</p>

<p>willSet is called just before the value is stored.<br/>
didSet is called immediately after the new value is stored.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Initialization]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-initialization/"/>
    <updated>2014-06-24T11:33:28+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-initialization</id>
    <content type="html"><![CDATA[<h3>Initialization</h3>

<p>“Initialization is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready to for use.” &mdash; Apple Inc.</p>

<p>从苹果的介绍我们可以得出初始化的两个要点:<br/>
1，为实例的每一个存储属性设置初始值;  <br/>
2，进行其他必要的准备工作.</p>

<p>这里我们主要总结下为实例的存储属性设置初始值。Class, Structure, enumeration的初始化略有不同，主要是因为Class可以继承，而这背后的原因是Class是Reference Type,而Structure, enumeration是Value Type。</p>

<h3>Value Type Initialization</h3>

<p>1)为存储属性设置默认值；</p>

<pre><code>Swift会为设置了所有存储属性默认值而没有提供初始化方法的structure提供Default Initializer。
structure在所有存储属性都设置了默认值的情况下自动接受Memberwise Initializer。
</code></pre>

<p>2)初始化方法。</p>

<pre><code>NOTE: Swift会自动将初始化方法的本地参数名生成外部参数名。
</code></pre>

<h3>Reference Type Initialization</h3>

<p>1)为类引入的存储属性设置初始值;<br/>
2)初始化方法。</p>

<pre><code>Designated initializers must always delegate up.
Convenience initializers must always delegate across.

Swift中子类默认是不继承父类的初始化方法,然而当满足一定条件时例外。
Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:

Rule 1
If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.

Rule 2
If your subclass provides an implementation of all of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.

These rules apply even if your subclass adds further convenience initializers.

NOTE:子类可以是用Convenience Initializer实现父类的Designated Initializer.
</code></pre>
]]></content>
  </entry>
  
</feed>
