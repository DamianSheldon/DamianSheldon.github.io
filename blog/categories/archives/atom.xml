<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-10-07T10:29:01+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Mac OSX Mavericks上安装和配置Openfire]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/09/11/install-and-configure-openfire-on-mac-osx-mavericks/"/>
    <updated>2014-09-11T09:15:32+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/09/11/install-and-configure-openfire-on-mac-osx-mavericks</id>
    <content type="html"><![CDATA[<h3>安装</h3>

<p>  Openfire的官方安装文档并没有详细说明如何在Mac OSX上安装。经过查找，它安装的路径在/usr/local下面，需要更改下它的所有者和用户组，并且openfire.sh也要加上可执行属性。</p>

<p>  常见问题：用浏览器打开localhost:9090，报错。<br/>
  解决办法：查看openfire的日志发现是因为端口被占用了，使用sudo lsof -i:9090命令，查看占用端口的程序，用kill -9 pid，终止它们，通常是安装完openfire后，它默认以root的权限启动了一个副本。再次重启openfire，应该可以正常运行了。</p>

<h3>配置</h3>

<p>   配置时需要注意，创建用户时的username，只需填写名字即可，不需要加上@domainname,否则客户端会一直提示密码不正确。查找了很久原因，才知道是这么回事。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation 笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji/"/>
    <updated>2014-09-03T09:59:58+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji</id>
    <content type="html"><![CDATA[<h2>Core Animation介绍</h2>

<p>Core Animation is a graphics rendering and animation infrastructure available on both iOS and OS X that you use to animate the views and other visual elements of your app.</p>

<h2>什么时候使用Core Animation?</h2>

<p>In places where you want to perform more sophisticated animations, or animations not supported by the UIView class, you can use Core Animation and the view’s underlying layer to create the animation. Because view and layer objects are intricately linked together, changes to a view’s layer affect the view itself.</p>

<h2>如何使用Core Animation?</h2>

<p>  1)Enabling Core Animation Support in Your App;<br/>
  In iOS apps, Core Animation is always enabled and every view is backed by a layer.iOS apps must link against this framework only if they use Core Animation interfaces explicitly.</p>

<p>  2)Selecting a appropriate Layer Object Associated with a View;<br/>
  Reference:Core Animation Programming Guide &mdash; Different Layer Classes Provide Specialized Behaviors</p>

<p>  3)Add animation to layer.<br/>
  CABasicAnimation provides basic, single-keyframe animation capabilities for a layer property.<br/>
  The CAKeyframeAnimation class provides keyframe animation capabilities for a layer object.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App 开发遇到的问题]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti/"/>
    <updated>2014-08-25T17:09:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>  问题描述：Storyboard中的ViewController上添加一个自定义的view,声明为IBOutlet然后用代码改变view的Frame,打印输出Frame的值确实改变了，但是模拟器上的视图的Frame还是没有改变。</p>

<p>  解决办法：Google找到Stackoverflow上有人说是选中了Auto layout的原因，取消之后确实生效了。PS:但是不知道问题的原因是什么。</p>

<p>Reference:<br/>
o <a href="http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work">http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work</a></p>

<p>问题描述：在switch语句中，如果在case中要定义变量的话要加上大括号。</p>

<p>原因：Case statements are only &lsquo;labels&rsquo;. This means the compiler will interpret this as a jump directly to the label.The problem here is one of scope. Your curly brackets define the scope as everything inside the &lsquo;switch&rsquo; statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that case statement and define your variable within it.</p>

<p>Reference:<a href="http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439">http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)如何让didUpdateLocation兼容iOS 5和iOS 6]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/07/28/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/"/>
    <updated>2014-07-28T16:05:38+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/07/28/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6</id>
    <content type="html"><![CDATA[<p><code>- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation</code>是CLLocationManagerDelegate protocol中的一个常用方法，它让你的应用接收更新位置信息，当检测到任何位置变化。新的位置详情存储在newLocation中，它是一个CLLocation.<br/>
当iOS6启动，上述方法被废弃了，建议使用新版本方法<code>- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations</code>或简称locationManager:didUpdateLocations:.</p>

<p>这个快速教程的的创建目的是为了解释如何处理废弃方法，关于它什么是应该完成的以及你在哪里可以找出关于改变的更多细节。如果你想了解如何使用这个新的locationManager:didUpdateLocations: 方法，看下<a href="http://www.devfright.com/didupdatelocations-ios-example/">didUpdateLocations tutorial</a>，它解释了如何使用方法提供的NSArray.</p>

<h3>当方法被废弃了</h3>

<p>当iOS升级了（这很经常），Apple找到新的或更有效方法。当这发生了，方法可以被标记为废弃并在如何使用的地方给出一个提示。具体到CLLocationManagerDelegate，你可以看到文档中推荐了一个不同的方法。虽然你仍然可以使用废弃的方法，即使是在已经废弃的iOS版本中，Apple在未来某个时间点也许会删除掉这个方法当iOS升级了。在那个时间点，你可能需要修改你的代码，提交到Apple Store通过审核流程。</p>

<h3>如何处理废弃的方法</h3>

<p>已经被废弃的方法在新的iOS版本上仍然可以工作。Apple趋向于让它们在未来的几个新版本中保持可用，然后再将它们从类或协议中删除。与其让你的代码在最后关头更新或重新提交到苹果商店。你可以在改变之前做好准备。</p>

<p>今天的例子，我们会看下 locationManager:didUpdateToLocation:fromLocation:方法以及如何让旧的废弃方法和新的方法在同一份代码中共同工作。<br/>
``` objective-c</p>

<p>&ndash;(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *newLocation = [locations lastObject];
CLLocation *oldLocation = [locations objectAtIndex:locations.count-1];
NSLog(@"didUpdateToLocation %@ from %@", newLocation, oldLocation);
MKCoordinateRegion userLocation = MKCoordinateRegionMakeWithDistance(newLocation.coordinate, 1500.0, 1500.0);
[regionsMapView setRegion:userLocation animated:YES];
</code></pre>

<p>}
<code>
为了兼容iOS 5,我们可以加入旧的方法`- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation`，并在旧的方法中调用新的方法，代码看起来会像这样：
</code> objective-c
&ndash;(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *newLocation = [locations lastObject];
CLLocation *oldLocation;
if (locations.count &gt;= 2) {
    oldLocation = [locations objectAtIndex:locations.count-1];
} else {
    oldLocation = nil;
}
NSLog(@"didUpdateToLocation %@ from %@", newLocation, oldLocation);
MKCoordinateRegion userLocation = MKCoordinateRegionMakeWithDistance(newLocation.coordinate, 1500.0, 1500.0);
[regionsMapView setRegion:userLocation animated:YES];
</code></pre>

<p>}</p>

<ul>
<li>(void)locationManager:(CLLocationManager <em>)manager didUpdateToLocation:(CLLocation </em>)newLocation fromLocation:(CLLocation *)oldLocation {
  [self locationManager:locationManager didUpdateLocations:[[NSArray alloc] initWithObjects:newLocation, nil]];
}
```</li>
</ul>


<p>如果是iOS5，新的方法不会被调用，它就像自定义的方法，iOS5并不知道locationManager:didUpdateLocations:事实上是什么。旧的方法简单的alloc/init新的名为currentLocation的NSArray并且使用 initWithObjects:newLocation获取一个newLocation,然后NSArray作为信息被传递到locationManager新的方法。</p>

<p>总之，如果设备是iOS5,旧的方法locationManager:didUpdateToLocation:fromLocation: 告诉代理新的位置可用，它把CLLocation加到NSArray中传递给新的方法，但设备的操作系统并不知道新方法。</p>

<p>如果使用的是iOS6,我们从CLLocationManagerDelegate的头文件中了解到如果代码中既有旧方法又有新方法，那么iOS会调用新方法通知代理位置更新了。</p>

<p>虽然这个快速教程提供了一种处理废弃方法的办法，仍然会有其他很多不同的办法。另外，多查看文档和关文件，因为Apple添加了很多信息，它们很有可能会为你手头的任务提供解决办法。</p>

<p>原文<br/>
o <a href="http://www.devfright.com/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/">http://www.devfright.com/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Properties]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties/"/>
    <updated>2014-06-24T15:28:20+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties</id>
    <content type="html"><![CDATA[<h3>Properties</h3>

<p>“Properties associate values with a particular class, structure, or enumeration. ” &mdash; Apple</p>

<h4>Type Properties</h4>

<p>属于类型本身的properties称为Type Property.</p>

<p>1)Value Type Properties (keyword: static)<br/>
structrue, enumeration可以定义Stroed 和Computed type properties.</p>

<p>Stored type properties for value types can be variables or constants.<br/>
NOTE:Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<p>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</p>

<p>2)Reference Type Properties (keyword: class)<br/>
class只可以定义Computed type properties.</p>

<h4>Instance Properties</h4>

<p>1)Stroed Properties
In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</p>

<p>P.S:A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p>2)Computed Properties
computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>

<h3>Properties Observer</h3>

<p>Property observers observe and respond to changes in a property’s value.</p>

<p>You have the option to define either or both of these observers on a property:</p>

<p>willSet is called just before the value is stored.<br/>
didSet is called immediately after the new value is stored.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Concurrency Programming--GCD]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/21/ios-concurrency-programming-gcd/"/>
    <updated>2014-05-21T11:40:27+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/21/ios-concurrency-programming-gcd</id>
    <content type="html"><![CDATA[<h2>GCD是什么？</h2>

<p>GCD是Grand Central Dispatch的缩写，它是用来执行自定义的任务的C接口机制。它可以串行或并行地执行任务，并大大简化了相应的线程代码。它的优点有：<br/>
* 直接简单的编程接口；<br/>
* 自动、整体的线程池管理；<br/>
* 高效的内存管理；<br/>
* 负载时不干扰内核；<br/>
* 异步分发任务到分派队列不会造成死锁；<br/>
* 优雅地处理竞争；<br/>
* 串行分派队列为锁和其他同步操作提供了更高效选择；</p>

<h2>如何使用GCD？</h2>

<p>GCD抽象出来了几组高效的的API,我们使用这些API来完成我们的工作。</p>

<h3>1）单个任务；</h3>

<p>我们通常是通过调用以下API来执行任务：
<code>objective-c
dispatch_async
dispatch_async_f
dispatch_sync
dispatch_sync_f
dispatch_after
dispatch_after_f
dispatch_apply
dispatch_apply_f
dispatch_once
</code></p>

<p>调用这些API之前，我们还要准备好dispatch queue.通常可以通过以下的API创建和管理Queues:
<code>objective-c
dispatch_get_global_queue
dispatch_get_main_queue
dispatch_queue_create
dispatch_get_current_queue
dispatch_queue_get_label
dispatch_set_target_queue
dispatch_main
</code></p>

<p>dispatch queues主要有三大类：main queue, Concurrent queue, Serial queue;</p>

<p>i)main queue:通过dispatch_get_main_queue(void)可以取到main queue;</p>

<p>ii)Concurrent queue:通过dispatch_queue_t dispatch_get_global_queue(long priority,unsigned long flags)可以取得全局的并发队列。总共有四个优先级的全局队列：
 DISPATCH_QUEUE_PRIORITY_HIGH      <br/>
 DISPATCH_QUEUE_PRIORITY_DEFAULT
 DISPATCH_QUEUE_PRIORITY_LOW      <br/>
 DISPATCH_QUEUE_PRIORITY_BACKGROUND</p>

<p>iii）Serial queue:可以使用dispatch_queue_create创建串行或并行队列。</p>

<p>代码示例：
``` objective-c
// i) main queue
dispatch_queue_t mainQueue = dispatch_get_main_queue(void);</p>

<p>// ii)Concurrent Queue
dispatch_queue defaultGlobalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>// iii)Serial queue
dispatch_queue_t myCustomSerialQueue = dispatch_queue_create(&ldquo;com.example.MyCustomSerialQueue&rdquo;, NULL);</p>

<p>// async
dispatch_async(myCustomSerialQueue, ^{</p>

<pre><code>printf("Do some work here.\n");
</code></pre>

<p>});</p>

<p>// sync
dispatch_sync(myCustomSerialQueue, ^{</p>

<pre><code>printf("Do some more work here.\n");
</code></pre>

<p>});
printf(&ldquo;Both blocks have completed.\n&rdquo;);</p>

<p>// apply
for (i = 0; i &lt; count; i++) {
   printf(&ldquo;%u\n&rdquo;,i);
}</p>

<p>// equlivent implement</p>

<p>dispatch_apply(count, defaultGlobalConcurrentQueue, ^(size_t i) {
   printf(&ldquo;%u\n&rdquo;,i);
});
```</p>

<h3>2）组任务；</h3>

<p>可以使用以下API进行组操作：
<code>objective-c
dispatch_group_async
dispatch_group_async_f
dispatch_group_create
dispatch_group_enter
dispatch_group_leave
dispatch_group_notify
dispatch_group_notify_f
dispatch_group_wait
</code>
代码示例：
``` objective-c
// Example 1
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>dispatch_group_t group = dispatch_group_create();</p>

<p>// Add a task to the group
dispatch_group_async(group, queue, ^{
   // Some asynchronous work
});</p>

<p>// Do some other work while the tasks execute.</p>

<p>// When you cannot make any more forward progress,
// wait on the group to block the current thread.
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</p>

<p>// Release the group when it is no longer needed.
dispatch_release(group);</p>

<p>// Example 2
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
[self doWorkOnArray:array];</p>

<p>```</p>

<h3>3）使用Dispatch Semaphores调控有效的资源使用；</h3>

<p>Dispatch Semaphores相关的API如下：
<code>objective-c
dispatch_semaphore_create
dispatch_semaphore_signal
dispatch_semaphore_wait
</code>
代码示例：
```objective-c
// Create the semaphore, specifying the initial pool size
dispatch_semaphore_t fd_sema = dispatch_semaphore_create(getdtablesize() / 2);</p>

<p>// Wait for a free file descriptor
dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);
fd = open(&ldquo;/etc/services&rdquo;, O_RDONLY);</p>

<p>// Release the file descriptor when done
close(fd);
dispatch_semaphore_signal(fd_sema);
```</p>

<h2>Reference</h2>

<p>o Concurrency Programming Guide<br/>
o iOS多线程编程Part 3/3 &ndash; GCD;<a href="http://www.hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/">http://www.hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的绘图系统]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/19/iosde-hui-tu-xi-tong/"/>
    <updated>2014-05-19T16:47:22+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/19/iosde-hui-tu-xi-tong</id>
    <content type="html"><![CDATA[<h2>iOS的绘图框架</h2>

<p>1)UIKit是Objective-C形式的API，提供基本的2D图形绘制，图片处理，和一些实现用户界面元素动画的方法；</p>

<p>2)Core Graphics是C形式的API，支持向量图形，位图和PDF内容；</p>

<p>3)Core Animation是另一个Objective-C形式的API,它能为用户界面增加流畅的移动和动态的反馈效果；</p>

<p>4)OpenGL ES 是移动端版本的OpenGL,它能实现高性能的2D和3D图形绘制。</p>

<h2>Drawing Destinations(iOS-Only)</h2>

<p>1)View Graphics Context<br/>
2)Layer<br/>
3)Bitmap<br/>
4)PDF<br/>
5)Printer</p>

<h2>Drawing to a View Graphics Context in iOS</h2>

<p>1)Implement drawRect:method;<br/>
2)Mark the view you want update by invocate setNeedDisplay;<br/>
3)Obtain Graphic context by Call UIGraphicsGetCurrentContext method;<br/>
4)Use UIKit provides functions, UIBezierPath or Core Graphics to meet your need.</p>

<p>``` objective-c
// 1) UIKit method
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
[path addLineToPoint:CGPointMake(0.4, 18.05)];
[path addLineToPoint:CGPointMake(18.8, -0.47)];
[path addLineToPoint:CGPointMake(37.21, 18.05)];
[path addLineToPoint:CGPointMake(34.31, 20.83)];
[path addLineToPoint:CGPointMake(20.88, 7.22)];
[path addLineToPoint:CGPointMake(20.88, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 7.22)];
[path closePath];
path.lineWidth = 1;
[[UIColor redColor] setStroke];
[path stroke];</p>

<p>// 2) Core Graphics method
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
CGContextAddLineToPoint(ctx, 0.4, 18.05);
CGContextAddLineToPoint(ctx, 18.8, -0.47);
CGContextAddLineToPoint(ctx, 37.21, 18.05);
CGContextAddLineToPoint(ctx, 34.31, 20.83);
CGContextAddLineToPoint(ctx, 20.88, 7.22);
CGContextAddLineToPoint(ctx, 20.88, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 7.22);
CGContextClosePath(ctx);
CGContextSetLineWidth(ctx, 1);
CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextStrokePath(ctx);
```</p>

<h2>Drawing to a Layer(CGLayer)</h2>

<p>A layer context (CGLayerRef) is an offscreen drawing destination associated with another graphics context. It is designed for optimal performance when drawing the layer to the graphics context that created it. A layer context can be a much better choice for offscreen drawing than a bitmap graphics context.</p>

<p>1)“Create a CGLayer Object Initialized with an Existing Graphics Context”<br/>
2)“Get a Graphics Context for the Layer”<br/>
3)“Draw to the CGLayer Graphics Context”<br/>
4)“Draw the Layer to the Destination Graphics Context”</p>

<h2>Drawing to a BitMap</h2>

<p>A bitmap graphics context accepts a pointer to a memory buffer that contains storage space for the bitmap. When you paint into the bitmap graphics context, the buffer is updated. After you release the graphics context, you have a fully updated bitmap in the pixel format you specify.</p>

<p>1)Creating a Bitmap Graphics Context;<br/>
UIGraphicsBeginImageContextWithOptions() or CGBitmapContextCeate()<br/>
2)Draw code.</p>

<p>``` objective-c
// 1) Mix call UIKit and Core Graphics</p>

<p>UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
&hellip;
CGContextStrokePath(ctx);
UIGraphicsEndImageContext();</p>

<p>// 2) Core Graphics
CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);
CGContextScaleCTM(ctx, 0.5, 0.5);
UIGraphicsPushContext(ctx);
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
&hellip;
[path stroke];
UIGraphicsPopContext(ctx);
CGContextRelease(ctx);
```</p>

<h2>Concurrency Drawing</h2>

<p>``` objective-c
UIImageView <em>view; // assume we have this
NSOperationQueue </em>renderQueue; // assume we have this
CGSize size = view.bounds.size;
[renderQueue addOperationWithBlock:^(){</p>

<pre><code>    UIImage *image = [renderer renderInImageOfSize:size];
    [[NSOperationQueue mainQueue] addOperationWithBlock:^(){
        view.image = image;
    }];
</code></pre>

<p>}];</p>

<ul>
<li><p>(UIImage *)renderInImageOfSize:(CGSize)size;
{
  UIGraphicsBeginImageContextWithOptions(size, NO, 0);</p>

<p>  // do drawing here</p>

<p>  UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();
  return result;
}
```</p></li>
</ul>


<h2>Reference</h2>

<p>o Quartz 2D Programming Guide<br/>
o 绘制像素到屏幕上 <a href="http://objccn.io/issue-3-1/">http://objccn.io/issue-3-1/</a></p>
]]></content>
  </entry>
  
</feed>
