<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2017-11-13T17:28:43+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[圆锥渐变的一种简单实现]]></title>
    <link href="http://DamianSheldon.github.io/blog/a-simple-conical-gradient-on-ios.html"/>
    <updated>2017-09-22T15:59:35+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/a-simple-conical-gradient-on-ios</id>
    <content type="html"><![CDATA[<p>Core Graphics 支持两种渐变：线性(Axial)和径向(Radial)渐变，但是有的时候我们可能会用到圆锥(Conical)渐变，例如在扫描附近的目标时，交互可能用上带这种渐变的雷达效果，它长这样：
<img src="../images/Conical-1.png" alt="Conical-1" />
<img src="../images/Conical-2.png" alt="Conical-2" /></p>

<p>要实现这样一种渐变你会怎么做呢？我的想法是从渐变的本质着手。渐变是从一种颜色渐渐变化成另外一种颜色，而圆锥渐变是根据角度渐渐变化。我们把界面看成位图，这样可以由点的位置得到它的角度，继而根据角度线性插值可以得到它的颜色，最终就可以得到圆锥渐变。</p>

<p>想法有了，接下来我们用它来实现上图中 Find My iPhone 图标的雷达效果吧。</p>

<p>首先定义一个 CALayer 的子类 ConicalLayer，</p>

<!--more-->


<pre><code>// ConicalLayer.h
@interface ConicalLayer : CALayer

/// An array of CGColorRef objects defining the color of each gradient stop. 
@property(copy) NSArray *colors;

@end

// ConicalLayer.m
- (id)init
{
    if (!(self = [super init])) {
        return nil;
    }

    _needsDisplayOnBoundsChange = YES;

    return self;
}

- (void)drawInContext:(CGContextRef)ctx
{
    // Draw background
    CGRect rect = CGContextGetClipBoundingBox(ctx);
    CGContextSetFillColorWithColor(ctx, self.backgroundColor);
    CGContextFillRect(ctx, rect);

    if (self.colors.count &lt; 1) {
        return;
    }
    else if (self.colors.count &lt; 2) {
        // There is only one color so directly draw with it
        CGColorRef color = (__bridge CGColorRef)(self.colors.firstObject);
        CGContextSetFillColorWithColor(ctx, color);
        CGContextFillRect(ctx, rect);
        return;
    }

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();

    size_t width = rect.size.width;
    size_t height = rect.size.height;

    size_t bitsPerCompoent = 8;
    size_t bytesPerRow = width * 4;

    size_t bitmapByteCount = bytesPerRow * height;

    uint32_t *bitmapData = calloc( bitmapByteCount / sizeof(uint32_t), sizeof(uint32_t) );

    // Map color to linear array each compoent occupy 1 byte
    uint8_t *colorCompoents = calloc(self.colors.count * 4, sizeof(uint8_t));

    for (int i = 0; i &lt; self.colors.count; ++i) {
        CGColorRef c = (__bridge CGColorRef)(self.colors[i]);

        const CGFloat *compoents = CGColorGetComponents(c);

        uint8_t red = compoents[0] * 255;
        uint8_t green = compoents[1] * 255;
        uint8_t blue = compoents[2] * 255;
        uint8_t alpha = compoents[3] * 255;

        int index = i * 4;
        *(colorCompoents + index) = red;
        *(colorCompoents + index + 1) = green;
        *(colorCompoents + index + 2) = blue;
        *(colorCompoents + index + 3) = alpha;
    }

    // Creating a Bitmap Graphics Context for conical gradient
    CGBitmapInfo bitmapInfo = kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Little;

    CGContextRef bitmapGraphicsCtx = CGBitmapContextCreate(bitmapData, width, height, bitsPerCompoent, bytesPerRow, colorSpace, bitmapInfo);

    // Creating conical gradient from a Bitmap Graphics Context
    CGImageRef conicalGradientImage = CGBitmapContextCreateImage(bitmapGraphicsCtx);

    CGContextRelease(bitmapGraphicsCtx);

    free(colorCompoents);

    free(bitmapData);

    CGColorSpaceRelease(colorSpace);

    // Draws conical gradient image into a graphics context.
    CGContextDrawImage(ctx, rect, conicalGradientImage);

    CGImageRelease(conicalGradientImage);

    // Draws three concentric
    CGContextBeginPath(ctx);

    CGFloat halfWidth = 0.5 * CGRectGetWidth(rect);
    CGFloat maxRadii = 0.8 * halfWidth;
    CGFloat radii = floor(0.33 * maxRadii);

    for (int i = 1; i &lt; 4; ++i) {
        CGFloat r = radii * i;
        CGFloat dx = halfWidth - r;
        CGRect ellipseRect = CGRectInset(rect, dx, dx);

        CGContextAddEllipseInRect(ctx, ellipseRect);
    }

    CGContextSetRGBStrokeColor(ctx, 41/255.0, 234/255.0, 35/255.0, 1.0);
    CGContextStrokePath(ctx);
}

- (BOOL)needsDisplayOnBoundsChange
{
    return _needsDisplayOnBoundsChange;
}

- (void)setNeedsDisplayOnBoundsChange:(BOOL)needsDisplayOnBoundsChange
{
}
</code></pre>

<p>现在我们把架子搭起来了，但是还没有往位图里面填充颜色，在这之前，对这段代码稍作解释，首先是我覆盖了needsDisplayOnBoundsChange 属性的 getter 和 setter 方法，原因是我设置图层关联的背景颜色时会触发这个属性变 NO，导致 <code>drawInContext</code> 不会被调用，我认为这是 Apple 的一个 bug，已经作了反馈，所以这里我使用了这么一个绕过的方法。</p>

<p>其次，我把 RGB 颜色空间的颜色分量取出来放在了一个一维数组里用来备用；最后是 bitmapInfo 要或上 kCGBitmapByteOrder32Little，不然结果会不正确。</p>

<p>接下来就是要填充位图的颜色，代码如下：</p>

<pre><code>    // Create conical gradient bitmap data
    CGFloat centerX = width * 0.5;
    CGFloat centerY = height * 0.5;

    double baseAngle = 2*M_PI / (self.colors.count - 1);

    for (int i = 0; i &lt; height; ++i) {
        for (int j = 0; j &lt; width; ++j) {
            CGFloat x = j - centerX;
            CGFloat y = i - centerY;

            // define atan2 uniquely one uses the principal value in the range (−π, π]. That is, −π &lt; atan2(y, x) ≤ π.
            double angle = atan2(y, x);

            // Convert atan2 result angle to range [0, 2π]
            if (angle &lt; 0) {
                angle += 2 * M_PI;
            }

            // 0-360 map to linear gradient
            double angleRatio = angle / baseAngle;
            int colorIndex = angleRatio; // How many times of base angle?

            angle -= colorIndex * baseAngle;
            angleRatio = angle / baseAngle;

            colorIndex *= 4;

            uint8_t red0 = colorCompoents[colorIndex];
            uint8_t red1 = colorCompoents[colorIndex + 4];

            // Green index
            colorIndex += 1;
            uint8_t green0 = colorCompoents[colorIndex];
            uint8_t green1 = colorCompoents[colorIndex + 4];

            // Blue index
            colorIndex += 1;
            uint8_t blue0 = colorCompoents[colorIndex];
            uint8_t blue1 = colorCompoents[colorIndex + 4];

            // Alpha index
            colorIndex += 1;
            uint8_t alpha0 = colorCompoents[colorIndex];
            uint8_t alpha1 = colorCompoents[colorIndex + 4];

//            uint8_t red = red0 + angleRatio * (red1 - red0);
//            uint8_t green = green0 + angleRatio * (green1 - green0);
//            uint8_t blue = blue0 + angleRatio * (blue1 - blue0);
//            uint8_t alpha = alpha0 + angleRatio * (alpha1 - alpha0);

            uint8_t red = lerp(red0, red1, angleRatio);
            uint8_t green = lerp(green0, green1, angleRatio);
            uint8_t blue = lerp(blue0, blue1, angleRatio);
            uint8_t alpha = lerp(alpha0, alpha1, angleRatio);

            // Multiple alpha
            float a = alpha / 255.0;

            red *= a;
            green *= a;
            blue *= a;

            unsigned long index = i * width + j;

            *(bitmapData + index) = (red &lt;&lt; 24) | (green &lt;&lt; 16) | (blue &lt;&lt; 8) | alpha;
        }
    }
</code></pre>

<p>同样也稍微解释下其中的代码，首先是位图的填充要按照先行后列的顺序，行对就宽，列对应高；其次反正切函数的值域是(−π, π]，所以要把它们映射到[0, 2π]；然后我们根据角度对应的区间，选择起始和终点颜色，再由线性插值得到各自的颜色分量，实践中每个颜色分量还乘上了当前的透明度，最后合成该点的颜色。</p>

<p><a href="https://github.com/DamianSheldon/QuartzDemo">完整示例</a></p>

<h2>Reference:</h2>

<p><a href="https://stackoverflow.com/questions/15344163/conical-gradient-in-qt-without-qconicalgradient">Conical gradient in Qt (without QConicalGradient)</a><br/>
<a href="https://github.com/maxkonovalov/MKGradientView">MKGradientView</a><br/>
<a href="https://en.wikipedia.org/wiki/Color_gradient">Color gradient</a><br/>
<a href="https://en.wikipedia.org/wiki/Linear_interpolation">Linear interpolation</a><br/>
<a href="https://en.wikipedia.org/wiki/Atan2">atan2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 中简单的图片处理]]></title>
    <link href="http://DamianSheldon.github.io/blog/simple-image-processing-in-ios.html"/>
    <updated>2017-07-14T09:49:40+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/simple-image-processing-in-ios</id>
    <content type="html"><![CDATA[<p>在 iOS 应用开发中，我们可能会要对图片进行旋转、缩放和裁剪，在介绍具体方法前，我们有必要先对图片做个大致的了解，这样有助于我们选择合适的方法。</p>

<h3>图片格式</h3>

<p>图片主要有两种格式：一种叫做位图；另一种称之为矢量图。所谓位图，就是把图片看成是由许多像素点组成；而矢量图则是用绘图指令来描述图片。举个例子，圆可以用圆点，半径，线条的粗细和颜色来描述它。从这个例子也可以看出用矢量图来描述风景，人物这样复杂的事物会比较复杂，所以它们通常会用位图来描述。</p>

<p>位图和矢量图也分为很多格式，具体可能查看<a href="https://en.wikipedia.org/wiki/Image_file_formats">Image file formats</a></p>

<p>下面我们讨论的是位图，在 iOS 中我们经常打交道的位图格式是 JPG 和 PNG，用来处理位图数据的类有：UIImage (UIKit)，CGImage (Core Graphics) 和 CIImage (Core Image)。Image I/O 本来是属于 Core Graphics，为了更加方便使用，Apple 将它分离出来成为单独的库。</p>

<h3>旋转</h3>

<p>既然位图是用一个一个的像素点来模拟图片，当我们想要旋转图片时，首先想到的方法自然是改变这些像素点的位置，这当然可以达到目标。要调整这么多像素点的位置自然要耗费不少时间，所有在数码相机刚出来那会，人们不是去改变像素点的位置，而是用一段数据来描述图片的方向等信息，这段数据称为 Exif. 所以对于 JPG 这种拥有 Exif 信息的位图，我们旋转图片的最佳做法自然是改变 Exif 里的方向信息。而 PNG 是没有 Exif 信息的，所以只能改变像素点的位置。</p>

<p>UIImage 自带了几个可以旋转的方法：</p>

<pre><code>+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation;

+ (UIImage *)imageWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation;

- (instancetype)initWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation;

- (instancetype)initWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation;
</code></pre>

<!--more-->


<p>我们没有这个方法的实现源码，但是我们可以输出图片的 Exif 信息来验证上面的说法。iOS 中我们可以使用 Image I/O 这个库来读取和修改图片的 Exif 信息。Image I/O 的文档不是很详细，使用时最好结合头文件的说明，而且要注意区分容器和单个图片，实验表明像方向这种信息它并不是放在 Exif 中，而是图片属性中，它的值和 UIImageOrientation 也不是一一对应的，它们的关系如下：</p>

<pre><code>typedef NS_ENUM(NSInteger, DMLImagePropertyOrientation) {
    DMLImagePropertyOrientationUp               = 1,
    DMLImagePropertyOrientationDown             = 3,
    DMLImagePropertyOrientationLeft             = 8,
    DMLImagePropertyOrientationRight            = 6,
    DMLImagePropertyOrientationUpMirrored       = 2,
    DMLImagePropertyOrientationDownMirrored     = 4,
    DMLImagePropertyOrientationLeftMirrored     = 5,
    DMLImagePropertyOrientationRightMirrored    = 7
};

+ (DMLImagePropertyOrientation)dml_imagePropertyOrientationFromUIImageOrientation:(UIImageOrientation)imageOrientation
{
    DMLImagePropertyOrientation imagePropertyOrientation = DMLImagePropertyOrientationUp;

    switch (imageOrientation) {
        case UIImageOrientationUp:
            imagePropertyOrientation = DMLImagePropertyOrientationUp;
            break;

        case UIImageOrientationDown:
            imagePropertyOrientation = DMLImagePropertyOrientationDown;
            break;

        case UIImageOrientationLeft:
            imagePropertyOrientation = DMLImagePropertyOrientationLeft;
            break;

        case UIImageOrientationRight:
            imagePropertyOrientation = DMLImagePropertyOrientationRight;
            break;

        case UIImageOrientationUpMirrored:
            imagePropertyOrientation = DMLImagePropertyOrientationUpMirrored;
            break;

        case UIImageOrientationDownMirrored:
            imagePropertyOrientation = DMLImagePropertyOrientationDownMirrored;
            break;

        case UIImageOrientationLeftMirrored:
            imagePropertyOrientation = DMLImagePropertyOrientationLeftMirrored;
            break;

        case UIImageOrientationRightMirrored:
            imagePropertyOrientation = DMLImagePropertyOrientationRightMirrored;
            break;
    }

    return imagePropertyOrientation;
}
</code></pre>

<p>从打印输出的内容看出 JPG 图片的方向确实改变了，然后我也写了个方法去改变图片的方向属性，得到了同样的效果，所以当我们是旋转上面提到的方向直接使用 UIImage 自带的几个旋转的方法应该是最佳选择，而要旋转任意角度，还是要通过调整像素点位置来完成。</p>

<pre><code>// 输出图片的属性信息
- (UIImageOrientation)dml_imageOrientationFromExif
{
    UIImageOrientation imageOrientation = UIImageOrientationRightMirrored + 1;

    NSData *dataOfImage = UIImageJPEGRepresentation(self, (CGFloat)0.7);

    CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)dataOfImage, NULL);

    CFDictionaryRef imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);

    NSLog(@"dml_imageOrientationFromExif image Properties:%@\n", (__bridge NSDictionary *)imageProperties);

    CFRelease(imageSource);

    CFNumberRef numberOfImageOrientation = CFDictionaryGetValue(imageProperties, kCGImagePropertyOrientation);

    CFRelease(imageProperties);

    DMLImagePropertyOrientation imagePropertyOrientation = [(__bridge NSNumber *)numberOfImageOrientation integerValue];

    imageOrientation = [[self class] dml_uiimageOrientationFromImagePropertyOrientation:imagePropertyOrientation];

    return imageOrientation;
}

// 修改图片的方向属性
- (UIImage *)dml_setExifOritenation:(UIImageOrientation)imageOrientation error:(NSError * __autoreleasing *)error
{
    NSData *dataOfImage = UIImageJPEGRepresentation(self, (CGFloat)0.7);

    CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)dataOfImage, NULL);

    /* get the file type */
    CFStringRef UTI = CGImageSourceGetType(imageSource);
    if ( NULL == UTI ) {
        /* Handle Error Retrieving File Type Accordingly */
        if (error) {
            *error = [NSError errorWithDomain:(__bridge NSString *)kCFErrorDomainCGImageMetadata code:kCGImageMetadataErrorUnknown userInfo:@{NSLocalizedDescriptionKey: @"Handle Error Retrieving File Type Accordingly"}];
        }
        return nil;
    }

//    CFMutableDataRef finalImageData = (__bridge_retained CFMutableDataRef)dataOfImage.mutableCopy;
    CFMutableDataRef finalImageData = (__bridge_retained CFMutableDataRef)[NSMutableData new];

    /* create an image destination for saving the file */
    CGImageDestinationRef destination = CGImageDestinationCreateWithData(finalImageData, UTI, 1, NULL);
    if ( nil == destination ) {
        /* Handle Error Creating CGImageDestinationRef Accordingly */
        if (error) {
            *error = [NSError errorWithDomain:(__bridge NSString *)kCFErrorDomainCGImageMetadata code:kCGImageMetadataErrorUnknown userInfo:@{NSLocalizedDescriptionKey: @"Handle Error Creating CGImageDestinationRef Accordingly"}];
        }
        return nil;
    }

    /* setting properties */
//    CFDictionaryRef sourceProperties = CGImageSourceCopyProperties(imageSource, NULL);
    CFDictionaryRef sourceProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);

    NSLog(@"dml_setExifOritenation original properties:%@\n", (__bridge NSDictionary *)sourceProperties);

    CFMutableDictionaryRef mutableSourceProperties = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, CFDictionaryGetCount(sourceProperties) + 1, sourceProperties);

    DMLImagePropertyOrientation imagePropertyOrientation = [[self class] dml_imagePropertyOrientationFromUIImageOrientation:imageOrientation];

    CFNumberRef numberForOritentation = CFNumberCreate(kCFAllocatorDefault, kCFNumberNSIntegerType, &amp;imagePropertyOrientation);

    CFDictionarySetValue(mutableSourceProperties, kCGImagePropertyOrientation, numberForOritentation);

    NSLog(@"dml_setExifOritenation edited properties:%@\n", (__bridge NSDictionary *)mutableSourceProperties);

    CGImageDestinationAddImageFromSource(destination, imageSource, 0, mutableSourceProperties);
    CGImageDestinationFinalize(destination);

    UIImage *resultImage = [UIImage imageWithData:(__bridge NSData *)finalImageData];

    CFRelease(numberForOritentation);

    CFRelease(mutableSourceProperties);

    CFRelease(sourceProperties);

    // Print destination properties

    NSData *dataOfDestinationImage = UIImageJPEGRepresentation(resultImage, (CGFloat)0.7);

    CGImageSourceRef destinationImageSource = CGImageSourceCreateWithData((__bridge CFDataRef)dataOfDestinationImage, NULL);

    CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(destinationImageSource, 0, NULL);

    NSLog(@"destination properties:%@\n", (__bridge NSDictionary *)properties);

    CFRelease(properties);
    CFRelease(destinationImageSource);

    return resultImage;
}
</code></pre>

<p>PS.理论上来讲，我们可以使用 <code>void CGImageDestinationSetProperties(CGImageDestinationRef idst, CFDictionaryRef properties);</code> 搭配 <code>bool CGImageDestinationCopyImageSource(CGImageDestinationRef idst, CGImageSourceRef isrc, CFDictionaryRef options, CFErrorRef  _Nullable *err);</code> 来改变图片的属性的，实际实验中并没有达到预期效果，原因不明。</p>

<h3>缩放</h3>

<p>上面提到 UIImage 的旋转方法也可以指定 Scale 因子，它是我们常说的几倍图中这个几倍因子，如果图片本来是一倍图，然后我们欺骗这个方法说是0.5倍图，那么我们会得到一张放大2倍的图，以些类推，所以我们可以考虑用这个方法来满足我们的一些简单需求，不能满足时，我们可以用 Core Graphics 将图片画到目标大小的位图上下文中来得到我们想要的图片。</p>

<h3>裁剪</h3>

<p>UIImage 没有裁剪相关的方法，我们可以使用 Core Graphics 中的 <code>CGImageRef CGImageCreateWithImageInRect(CGImageRef image, CGRect rect);</code>方法来实现裁剪。使用这个方法我们需要注意 Rect 要考虑图片的 scale，图片完整的 <code>rect = {0, 0, image.size.width * image.scale, image.size.height * image.scale}</code>, 所以我们指定裁剪的 rect 时也要带上 scale.</p>

<h3>缩略图</h3>

<p>生成缩略图可以使用 Image I/O 中的 <code>CGImageRef CGImageSourceCreateThumbnailAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options);</code>方法。</p>

<h3>Reference</h3>

<ul>
<li>Image I/O Programming Guide</li>
<li><a href="https://objccn.io/issue-21-2/">图片格式</a></li>
<li><a href="http://nshipster.com/image-resizing/">Image Resizing Techniques</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
