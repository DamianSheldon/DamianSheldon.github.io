<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS Development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-11-11T16:35:19+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(翻译)iOS 设计模式]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/10/ios-design-patterns/"/>
    <updated>2014-11-10T08:35:43+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/10/ios-design-patterns</id>
    <content type="html"><![CDATA[<p>iOS设计模式&mdash;你也许听说过这个术语，但是你知道它意味着什么吗？尽管大多数开发者可能同意设计模式非常重要，但关于它的文章并不多，咱们开发者们写代码时并没有花大多注意力放到设计模式上。</p>

<p>在软件设计中设计模式是对常见问题的可复用的解决方法。他们被设计成模板帮助你写出容易理解和复用的代码。他们也帮助你写出低藕合的代码以便你不需要太多争论就能改变或替换你代码的组件。</p>

<p>如果你刚刚接触设计模式，告诉你些好消息！首先，你已经使用过很多设计模式，这得感谢Cocoa建立的方式以及你被鼓励使用的最佳实践。其次，这篇教程将让你掌握iOS的主要（次要）设计模式，它们在Cocoa中很常用。</p>

<p>教程分成多个部分，每部分包含一种设计模式。在每部分，你会看到如下顺序的解释：</p>

<ul>
<li>该设计模式是什么；</li>
<li>你为什么应该使用它；</li>
<li>如何使用它，以及什么场景合适，使用时需要留意的常见陷阱；</li>
</ul>


<p>这篇教程中，你将创建一个Music Library应用，它会显示你的专辑和它们相关的信息。</p>

<p>在开发应用的过程中，你会慢慢熟悉多数常见的Cocoa设计模式：</p>

<ul>
<li>构造类：单例(Singleton)和 抽象工厂(Abstract Factory);</li>
<li>架构类：模型-视图-控制器(MVC), 修饰(Decorator), 适配器(Adapter), 门面(Facade)和合成（Composite);</li>
<li>行为类：观察者(Observer), 记忆(Memento), 响应链(Chain of Responsibility)和命令（Command）。</li>
</ul>


<p>别被误导认为这是篇纯理论的文章；你会在你音乐应用中使用这些应用模式中的大多数。你的应用最终看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="finalapp-180x320" src="http://DamianSheldon.github.io/images/finalapp-180x320.png" width="180" height="320">  

</div>


<h3>开始吧</h3>

<p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/BlueLibrary-Starter.zip">启动工程</a>,解压ZIP文件内容，然后在Xcode中打开。</p>

<p>里面内容不多，仅仅是默认的ViewController和一个未实现的简单HTTP客户端。</p>

<p><strong>Note</strong>:你知道吗？当你创建一个新的工程你的代码就已经符合设计模式了。MVC, Delegate, Protocol, Singleton&mdash;你免费得到全部！:]</p>

<p>在你深入第一个设计模式之前，你必须创建两个类去持有和显示专辑数据。</p>

<p>导航到<strong>“File\New\File…”</strong>(或简单地按Command+N)。选中<strong>iOS > Cocoa Touch</strong>，然后<strong>Objective-C class</strong>和单击<strong>Next</strong>。设置类名为<strong>Album</strong>并继承<strong>NSObject</strong>。单击<strong>Next</strong>然后<strong>Create</strong>。</p>

<p>打开<strong>Album.h</strong>，然后添加如下属性和方法原型到<strong>@interface</strong> 和 <strong>@end</strong>间:</p>

<p>```
@property (nonatomic, copy, readonly) NSString <em>title, </em>artist, <em>genre, </em>coverUrl, *year;</p>

<ul>
<li>(id)initWithTitle:(NSString<em>)title artist:(NSString</em>)artist coverUrl:(NSString<em>)coverUrl year:(NSString</em>)year;
```</li>
</ul>


<p>注意到所有的属性都是可读的，因为Album对象被创建之后不需要被改变。</p>

<p>方法是对象的初始化方法。当你创建一个新alum，你将传入album name, artist, album cover URL和year。</p>

<p>现在打开<strong>Album.m</strong>,添加下列代码到<strong>@implementation</strong>和<strong>@end</strong>中间:</p>

<p>```
&ndash; (id)initWithTitle:(NSString<em>)title artist:(NSString</em>)artist coverUrl:(NSString<em>)coverUrl year:(NSString</em>)year
{</p>

<pre><code>self = [super init];
if (self)
{
    _title = title;
    _artist = artist;
    _coverUrl = coverUrl;
    _year = year;
    _genre = @"Pop";
}
return self;
</code></pre>

<p>}
```</p>

<p>这里没有什么神奇的；仅仅是一个简单的init方法去创建一个新Album实例。</p>

<p>再次导航到<strong>File\New\File…</strong>。选择<strong>Cocoa Touch</strong>然后<strong>Objective-C class</strong>，点击<strong>Next</strong>。设置类名为<strong>AlbumView</strong>，但是这次设置它为<strong>UIView</strong>的子类。点击<strong>Next</strong>然后<strong>Create</strong>。</p>

<p><strong>Note</strong>:如果你发现快捷键更容易用的话，<strong>Command+N</strong>将创建新的文件，<strong>Command+Option+N</strong>将创建新组，<strong>Command+B</strong>将编译你的工程，<strong>Command+R</strong>将运行工程。</p>

<p>打开<strong>AlbumView.h</strong>,然后添加下列方法原型到<strong>@interface</strong>和<strong>@end</strong>的中间。</p>

<p><code>
- (id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover;
</code></p>

<p>Now open AlbumView.m and replace all the code after @implementation with the following code:</p>

<p>现在打开<strong>AlbumView.m</strong>，用下面的代码替换<strong>@implementation</strong>之后的内容：</p>

<p>```
@implementation AlbumView
{</p>

<pre><code>UIImageView *coverImage;
UIActivityIndicatorView *indicator;
</code></pre>

<p>}</p>

<ul>
<li><p>(id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover
{
  self = [super initWithFrame:frame];
  if (self)
  {</p>

<pre><code>  self.backgroundColor = [UIColor blackColor];
  // the coverImage has a 5 pixels margin from its frame
  coverImage = [[UIImageView alloc] initWithFrame:CGRectMake(5, 5, frame.size.width-10, frame.size.height-10)];
  [self addSubview:coverImage];

  indicator = [[UIActivityIndicatorView alloc] init];
  indicator.center = self.center;
  indicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhiteLarge;
  [indicator startAnimating];
  [self addSubview:indicator];
</code></pre>

<p>  }
  return self;
}</p></li>
</ul>


<p>@end
```</p>

<p>你注意到的第一件事是这里有个名为coverImage的实例变量。变量代表专辑的封面图片。第二个变量是一个指示器，当专辑在下载时它转动指示器。</p>

<p>在初始化方法的实现中，你设置背影为黑色，创建一个与主视图周边有5个点距离的图片视图，创建并添加了一个活动指示器。</p>

<p><strong>Note</strong>:很奇怪为什么把私有变量定义在实现文件中而不是接口文件中？这是因为AlbumView类之外的其他类并不需要知道这些变量的存在，它们仅被类的内部实现中使用。如果你是在开发库或框架让其他开发者使用，这个惯例极其重要。</p>

<p>编译你的工程（<strong>Command+B</strong>）确认所有事情都准备就绪。都好了吗？然后准备迎接你的第一个设计模式！:]</p>

<h3>模型&mdash;视图&mdash;控制器，设计模式之王</h3>

<div style="text-align:center" markdown="1">

<img name="mvcking" src="http://DamianSheldon.github.io/images/mvcking.png" width="293" height="196">  

</div>


<p>模型&mdash;视图&mdash;控制器（MVC）是Cocoa的一个基石，它毫无疑问是被用得最多的设计模式。它依据应用中类的角色给它们分类，鼓励基于角色简洁地分隔代码。</p>

<p>这三个角色是：</p>

<ul>
<li><p>模型：持有你应用数据并定义如何操作它们的对象。例如，这个应用中的模型是你的Album类。</p></li>
<li><p>视图：控制模型类的可视显示以及和用户的交互的对象;所有的UIView和它们的子类基本上都是。在你这个应用中AlbumView代表视图。</p></li>
<li><p>控制器：控制器是中间件，它协调所有的工作。它从模型类访问数据并显示到视图上，监听事件，在需要时操作数据。你能猜到哪个类是你的控制器吗？对，是ViewController。</p></li>
</ul>


<p>你应用中这个设计模式好的实现意味着每个对象都会是三者之一。</p>

<p>视图和模型的通信可以被最佳描述成下图：</p>

<div style="text-align:center" markdown="1">

<img name="mvc0" src="http://DamianSheldon.github.io/images/mvc0.png" width="424" height="194">  

</div>


<p>任何数据发生改变模型类便通知控制器，接下来，控制器将数据更新到视图上。视图接收到用户的动作时可以通知控制器，控制器会根据需要更新模型数据或获取任何请求的数据。</p>

<p>你也许会奇怪为什么不拿掉Controller,在同一个类中实现视图和模型，这看起来更容易。</p>

<p>这都来源于代码的去藕合和可可复用。理想情况下，视图应该完全和模型隔离，这样它可以被不同的模型复用去展示其他的数据。</p>

<p>例如，如果未来你也想添加电影或书本到你的收藏库中，你仍然可以使用相同的AlbumView去展示你的电影和图书对象。此外，如果你创建了一个新的对象，它和专辑有些关系，你可以简单地复用你的Album类，因为它不依赖任何视图。这就是MVC的强大之处！</p>

<h3>如何使用MVC设计模式</h3>

<p>首先，你需要保证你工程中的类是Controller，View, Model三者之一；不要混合两个角色的功能到一个类中。你创建的<strong>Album</strong>和<strong>AlbumView</strong>到目前为止都做的很好。</p>

<p>其次，为了确保你习惯这种工作方式，你应该创建三个工程组来持有你的代码，每组对应一个类别。</p>

<p>导航到<strong>File\New\Group</strong>（或按<strong>Command+Option+N</strong>）并命名为Model，用相同的方法创建<strong>View</strong>和<strong>Controller</strong>组。</p>

<p>现在拖拽<strong>Album.h</strong>和<strong>Album.m</strong>到<strong>Model</strong>组。拖拽<strong>AlbumView.h</strong>和<strong>AlbumView.m</strong>到<strong>View</strong>组，最后拖拽<strong>ViewController.h</strong>和<strong>ViewController.m</strong>到<strong>Controller</strong>组。</p>

<p>目前你的工程结构应该看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="mvc2-255x320" src="http://DamianSheldon.github.io/images/mvc2-255x320.png" width="255" height="320">  

</div>


<p>你的工程已经没有混乱的文件了看起来好多了。你明显能拥有其他的组和类，但这三个类别中的类是应用的核心。</p>

<p>现在你的组件被组织起来了，你需要从其他地方得到你的专辑数据。你将创建一个API类用于全部代码的数据管理&mdash;这提供了一个机会和你探讨下一个设计模式&mdash;单例。</p>

<h3>单例设计模式</h3>

<p>单例设计模式确保对于指定的类仅存在一个实例，全局的访问都指向它。它经常使用懒散加载，只有第一次需要时才创建这个实例。</p>

<p><strong>Note</strong>:Apple大量使用这种方法。例如：<strong>[NSUserDefaults standardUserDefaults]</strong>, <strong>[UIApplication sharedApplication]</strong>, <strong>[UIScreen mainScreen]</strong>, <strong>[NSFileManager defaultManager]</strong> 全都返回单例对象。</p>

<p>你也许会奇怪为什么你要关心一个类是不是只有一个实例，毕竟代码和内存都很便宜，对不对？</p>

<p>有些场景对于类只存在一个实例是有意义的。例如，没有必要存在多个Logger实例，除非你想同时输出多个log文件。以或者来看一个全局配置处理类：像配置文件，对于单个共享资源实现线程安全访问要比在同时可能有很多配置文件修改时容易的多。</p>

<h3>如何使用单例设计模式</h3>

<p>看下下面这个图：</p>

<div style="text-align:center" markdown="1">

<img name="singleton" src="http://DamianSheldon.github.io/images/singleton.png" width="233" height="152">  

</div>


<p>上图示例了一个Logger类，它有一个属性（它就是这个单独的实例），和两个方法：sharedInstance和init。</p>

<p>客户端第一次发送sharedInstance消息，属性的实例还没被初始化，所以你创建类的一个新的实例，然后返回它的一个引用。</p>

<p>下次调用sharedInstance，实例会立即返回不用初始化。这个逻辑保证任何时候都只仅存在一个实例。</p>

<p>你将实现这种模式通过创建一个单例类来管理专辑的所有数据。</p>

<p>你将注意到工程里有一个组叫<strong>API</strong>；这是你放所有将为应用提供服务类的地方。在组里用<strong>iOS\Cocoa Touch\Objective-C class</strong>模板创建一个新的类。命名为<strong>LibraryAPI</strong>，设置它是<strong>NSObject</strong>的子类。</p>

<p>打开<strong>LibraryAPI.h</strong>,用如下内容替代它：</p>

<p>```
@interface LibraryAPI : NSObject</p>

<ul>
<li>(LibraryAPI*)sharedInstance;</li>
</ul>


<p>@end
```</p>

<p>Now go to LibraryAPI.m and insert this method right after the @implentation line:</p>

<p>现在到<strong>LibraryAPI.m</strong>，在<strong>@implentation</strong>之后插入这个方法：</p>

<p>```
+ (LibraryAPI*)sharedInstance
{</p>

<pre><code>// 1
static LibraryAPI *_sharedInstance = nil;

// 2
static dispatch_once_t oncePredicate;

// 3
dispatch_once(&amp;oncePredicate, ^{
    _sharedInstance = [[LibraryAPI alloc] init];
});
return _sharedInstance;
</code></pre>

<p>}
```</p>

<p>简短的方法里有不少内容：</p>

<ol>
<li><p>声明了一个静态变量来持有你类的实例，确保它在你的类中是全局可用的。</p></li>
<li><p>声明了一个<strong>dispatch_once_t</strong>静态变量，它确保初始化方法只会被执行一次。</p></li>
<li><p>使用Grand Central Dispatch (GCD)来执行块，它初始化了一个<strong>LibraryAPI</strong>的实例。这是单例设计模式的要义：类被实例化之后初始化方法就不会被调用了。</p></li>
</ol>


<p>下次你调用<strong>sharedInstance</strong>，在<strong>dispatch_once</strong>块中代码就不会被执行了（因为它已经被执行过一次了），你会得到一个之前创建的<strong>LibraryAPI</strong>的实例引用。</p>

<p>Note:想了解更多GCD内容以及它的用法，看下网站中的这两篇教程：<a href="http://www.raywenderlich.com/?p=4295">Multithreading and Grand Central Dispatch</a>和<a href="http://www.raywenderlich.com/?p=9328">How to Use Blocks</a>。</p>

<p>你现在有一个单例对象作为入口去管理专辑。我们把它进一步完善，创建一个类来处理你收藏库数据的持久化。</p>

<p>以<strong>iOS\Cocoa Touch\Objective-C class</strong>为模板在API组中创建一个新的类，命名为<strong>PersistencyManager</strong>，设置它为<strong>NSObject</strong>的子类。</p>

<p>打开<strong>PersistencyManager.h</strong>，添加下列引用到文件的顶端:</p>

<p>```</p>

<h1>import &ldquo;Album.h&rdquo;</h1>

<p>```</p>

<p>Next, add the following code to PersistencyManager.h after the @interface line:</p>

<p>然后，添加下列代码到<strong>PersistencyManager.h</strong>中<strong>@interface</strong>后面：</p>

<p><code>
- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></p>

<p>上面是你处理专辑数据的三个方法原型。</p>

<p>打开PersistencyManager.m，添加下列代码到@implementation前面：</p>

<p>```
@interface PersistencyManager () {</p>

<pre><code>// an array of all albums
NSMutableArray *albums;
</code></pre>

<p>}
```</p>

<p>上面添加了一个类的扩展，它是另一种给类添加私有方法和变量而不会暴露给外部类的方法。这里你声明了一个<strong>NSMutableArray</strong>来持有专辑数据。数组的可变性可以让你很容易添加和删除专辑数据。</p>

<p>现在添加下现代码实现到PersistencyManager.m文件中@implementation的后面：</p>

<p>```
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    // a dummy list of albums
    albums = [NSMutableArray arrayWithArray:
             @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
             [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
             [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
             [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
             [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
}
return self;
</code></pre>

<p>}
```</p>

<p>在init中，你用5个样本专辑填充了数组。如果上面的专辑你不喜欢，用你喜欢的音乐替换它们吧. :]</p>

<p>现在添加下面三个方法到<strong>PersistencyManager.m</strong>：</p>

<p>```
&ndash; (NSArray*)getAlbums
{</p>

<pre><code>return albums;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)addAlbum:(Album*)album atIndex:(int)index
{
  if (albums.count >= index)
      [albums insertObject:album atIndex:index];
  else
      [albums addObject:album];
}</p></li>
<li><p>(void)deleteAlbumAtIndex:(int)index
{
  [albums removeObjectAtIndex:index];
}
```</p></li>
</ul>


<p>这些方法能让你获取，添加，删除专辑。</p>

<p>编译你的工程，确保所有的文件仍然能成功被编译。</p>

<p>到这，你可能会奇怪<strong>PersistencyManager</strong>来看哪里呢？它又不是单例。<strong>LibraryAPI</strong>和<strong>PersistencyManager</strong>的关系，我们在下一节会进一步揭示，你还会看到<strong>门面</strong>设计模式。</p>

<h3>门面设计模式</h3>

<div style="text-align:center" markdown="1">

<img name="facade" src="http://DamianSheldon.github.io/images/facade.jpg" width="300" height="212">  

</div>


<p>门面设计模式为复杂的子系统提供一个单一的接口。与其把一系列类和它们的API暴露给用户，还不如仅仅暴露给它们一个简单统一的API。</p>

<p>下图解释了这种理念：</p>

<div style="text-align:center" markdown="1">

<img name="facade2-480x241" src="http://DamianSheldon.github.io/images/facade2-480x241.png" width="480" height="241">  

</div>


<p>API的使用者们完全感觉不到它后面的复杂。当很多类协作时，这种设计模式十分理想，特别是当它们对用户很复杂或很难理解。</p>

<p>门面模式让使用系统的代码从接口和你隐藏实现的类解藕；它也减少了外部代码对内部子系统工作的依赖。当门面底下的类想改变时，这也很有用，因为门面能保留相同的API，尽管后面的代码已经改变了。</p>

<p>例如，如果有一天你想替换你的后端服务，你不需要去修改使用你API的代码。</p>

<h3>如何使用门面设计模式</h3>

<p>目前你有<strong>PersistencyManager</strong>保存专辑数据到本地，<strong>HTTPClient</strong>处理远程交互。工程中其他的类不应该意识到这个逻辑的存在。</p>

<p>为了实现这个设计模式，仅<strong>LibraryAPI</strong>应该持有<strong>PersistencyManager</strong>和<strong>HTTPClient</strong>的实例。然后，<strong>LibraryAPI</strong>会对其他的服务暴露一个简单的API。</p>

<p><strong>Note</strong>:通常，单例在整个应用的生命周期都存在。你不应该让单例保持大多其他对象的强引用，因为他们直到应用关闭才会被释放。</p>

<p>设计看起来像下面这样：</p>

<div style="text-align:center" markdown="1">

<img name="design-patterns-facade-uml-480x71" src="http://DamianSheldon.github.io/images/design-patterns-facade-uml-480x71.png" width="480" height="71">  

</div>


<p><strong>LibraryAPI</strong>将暴露给其他代码，但是会对应用的其他部分隐藏<strong>HTTPClient</strong>和<strong>PersistencyManager</strong>的复杂。</p>

<p>打开<strong>LibraryAPI.h</strong>，添加下列引用到文件的顶端：</p>

<p>```</p>

<h1>import &ldquo;Album.h&rdquo;</h1>

<p>```</p>

<p>然后，添加下列方法定义到<strong>LibraryAPI.h</strong>：</p>

<p><code>
- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></p>

<p>现在，这些方法是你会暴露给其他类的。</p>

<p>到LibraryAPI.m中，添加下面两个引用：</p>

<p>```</p>

<h1>import &ldquo;PersistencyManager.h&rdquo;</h1>

<h1>import &ldquo;HTTPClient.h&rdquo;</h1>

<p>```</p>

<p>这将是你唯一导入这些类的地方。记住：你的API将会是唯一的入口去访问你"复杂"的系统。</p>

<p>现在，通过类的扩展添加些私有变量（在@implementation上面）：</p>

<p>```
@interface LibraryAPI () {</p>

<pre><code>PersistencyManager *persistencyManager;
HTTPClient *httpClient;
BOOL isOnline;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p><strong>isOnline</strong>决定任何专辑列表的改变，例如，添加或删除专辑，是否应该被更新到服务器。</p>

<p>你现在需要通过<strong>init</strong>来初始化这些变量。添加下列代码到<strong>LibraryAPI.m</strong>：</p>

<p>```
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    persistencyManager = [[PersistencyManager alloc] init];
    httpClient = [[HTTPClient alloc] init];
    isOnline = NO;
}
return self;
</code></pre>

<p>}
```</p>

<p>HTTP Client最终不会和真实的服务器交互，这里仅仅是为示例门面模式的使用，所以<strong>isOnline</strong>将一直是<strong>NO</strong>。</p>

<p>下一步，添加下面三个方法到<strong>LibraryAPI.m</strong>：</p>

<p>```
&ndash; (NSArray*)getAlbums
{</p>

<pre><code>return [persistencyManager getAlbums];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)addAlbum:(Album*)album atIndex:(int)index
{
  [persistencyManager addAlbum:album atIndex:index];
  if (isOnline)
  {
      [httpClient postRequest:@&ldquo;/api/addAlbum&rdquo; body:[album description]];
  }
}</p></li>
<li><p>(void)deleteAlbumAtIndex:(int)index
{
  [persistencyManager deleteAlbumAtIndex:index];
  if (isOnline)
  {
      [httpClient postRequest:@&ldquo;/api/deleteAlbum&rdquo; body:[@(index) description]];
  }
}
```</p></li>
</ul>


<p>看一眼<strong>addAlbum:atIndex:</strong>。类首先更新本地数据，然后如果是联网的话，更新远程服务器。这是门面的真正力量；当你系统外面添加一个新专辑，它不知道，也不需要知道这底下的复杂。</p>

<p><strong>Note</strong>:当你为子系统的类设计门面时，记住没任何东西防止客户端直接访问隐藏的类。不要吝啬你的防御代码，不要假设所有客户端按门面相同的方式使用这些类是必须的。</p>

<p>编译并运行你的应用。你会看到像下面这样令人兴奋和无法置信的空的黑色屏幕。</p>

<div style="text-align:center" markdown="1">

<img name="2013-09-01_12-08-44-211x320" src="http://DamianSheldon.github.io/images/2013-09-01_12-08-44-211x320.png" width="211" height="320">  

</div>


<p>你将会需要些东西来显示专辑数据到屏幕上&mdash;这是个完美的使用场景对于你的下个设计模式：修饰。</p>

<h3>修饰设计模式</h3>

<p>修饰设计模式动态添加行为和能力到一个对象而不需要修改它的代码。它是不同于子类那样通过包装到另一个对象来修改类的行为的方法。</p>

<p>在Objective-C中，这种设计模式有两个很常见的实现：<strong>Category</strong>和<strong>Delegation</strong>。</p>

<h4>Category</h4>

<p>Category是一个极其强大的机制，它允许你添加方法到已经存在的类而不需要子类化。新的方法在编译时被添加，可以像扩展类的普通方法一样被执行。它和经典的修饰模式有点不同，因为一个Category不能持有扩展类的实例。</p>

<p><strong>Note</strong>:除了扩展你自己的类，你还可以添加方法到任意Cocoa拥有的类。</p>

<h4>如何使用Categories</h4>

<p>想像这么一个场景，你有一个Album对象，你想让它显示在一个表格视图中:</p>

<div style="text-align:center" markdown="1">

<img name="design-patterns-category1" src="http://DamianSheldon.github.io/images/design-patterns-category1.png" width="310" height="188">  

</div>


<p>专辑标题是从哪来的呢？<strong>Album</strong>是一个模型对象，所以它不关心你如何展示数据。你将需要些外部代码来为<strong>Album</strong>类添加该功能，但是不能直接修改类。</p>

<p>你将创建一个category，这是Album的扩展；它将定义一个新方法，这个新方法会返回一个让UITableView很容易使用的数据结构。</p>

<p>The data structure will look like the following:</p>

<p>这个数据结构会看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="delegate2-480x67" src="http://DamianSheldon.github.io/images/delegate2-480x67.png" width="480" height="67">  

</div>


<p>为了添加<strong>Category</strong>到<strong>Album</strong>，导航到<strong>File\New\File…</strong>，选择<strong>Objective-C category</strong>模板&mdash;不要习惯性地选择了<strong>Objective-C class</strong>！输入<strong>TableRepresentation</strong>到<strong>Category</strong>字段，<strong>Album</strong>到<strong>Category on</strong>字段。</p>

<p>Note:你有没注意到新文件的名字？<strong>Album+TableRepresentation</strong>意味着你正在扩展<strong>Album</strong>类。这个惯例很重要，因为它易读并且它防止和你事其他人可能创建的categories冲突。</p>

<p>Go to Album+TableRepresentation.h and add the following method prototype:</p>

<p>进入Album+TableRepresentation.h，添加如下方法原型：</p>

<p><code>
- (NSDictionary*)tr_tableRepresentation;
</code></p>

<p>注意这里的方法名前有个<strong>tr_</strong>，是<strong>category:TableRepresentation</strong>的缩写。再次提醒，像这样的惯例将防止和其他方法冲突！</p>

<p><strong>Note</strong>:如果你在category中声明的方法和源类，或都同一个类其他的category（甚至父类）方法相同，运行时会使用哪个方法实现是示定义的。这种情况在你使用自己拥有类的category时很少发生，但是当使用categories添加方法到标准的Cocoa或Cocoa Touch类时能导致严重问题。</p>

<p>Go to Album+TableRepresentation.m and add the following method:</p>

<p>进入<strong>Album+TableRepresentation.m</strong>，添加如下方法：</p>

<p>```
&ndash; (NSDictionary*)tr_tableRepresentation
{</p>

<pre><code>return @{@"titles":@[@"Artist", @"Album", @"Genre", @"Year"],
         @"values":@[self.artist, self.title, self.genre, self.year]};
</code></pre>

<p>}
```</p>

<p>Consider for a moment how powerful this pattern can be:</p>

<p>思考下这种模式在某个时刻有多强大：</p>

<ul>
<li>你正在使用直接来自Album属性。</li>
<li>你添加了内容到Album类，但是你并没有子类化它。如果你需要子类化Album，你仍然也可以这么做。</li>
<li>这个简单的额外内容让你能返回一个UITableView式的专辑，并没有修改Album的代码。</li>
</ul>


<p>Apple在Foundation类中大量使用Categories。打开<strong>NSString.h</strong>看下他们是如何做的。找到 <strong>@interface NSString</strong>，你将会看到总共定义了三个categories：<strong>NSStringExtensionMethods</strong>, <strong>NSExtendedStringPropertyListParsing</strong> 和 <strong>NSStringDeprecated</strong>。Categories帮助方法组织和分隔到各个部分。</p>

<h4>Delegation</h4>

<p>另一个修饰设计模式，Delegation，是一种一个对象的行为代表或协调另一个对象。例如，当你使用<strong>UITableView</strong>，你必须实现的方法之一是<strong>tableView:numberOfRowsInSection:</strong>。</p>

<p>你不能期望UITableView知道你想每个部分有多少行，因为这是应用特定的。因此，计算每个部分有多少行的任务传递给了UITableView delegate。它允许UITableView类独立于它显示的数据。</p>

<p>这里有一个当你创建一个UITableView时是如何进行的虚拟场景解释：</p>

<div style="text-align:center" markdown="1">

<img name="delegate-480x252" src="http://DamianSheldon.github.io/images/delegate-480x252.png" width="480" height="252">  

</div>


<p>UITableView对象的工作是显示table view。但是，最终它将需要一些它没有的信息。然后，它救助于它的delegates，发送消息询问额外的信息。在Objective-C中实现delegate模式，一个类通过protocol可以声明可选和必选的方法。你将教程的稍候全面了解protocols。</p>

<p>表面看起来仅仅去继承一个对象然后覆盖必要的方法要简单，但是考虑下你只能继承单一的一个类。如果你想让某个类成为两或多个对象的delegate，这是不能通过继承实现的。</p>

<p>Note:这是个很重要的模式。Apple应用这种方法到大多数UIKit类：<strong>UITableView</strong>, <strong>UITextView</strong>, <strong>UITextField</strong>, <strong>UIWebView</strong>, <strong>UIAlert</strong>, <strong>UIActionSheet</strong>, <strong>UICollectionView</strong>, <strong>UIPickerView</strong>, <strong>UIGestureRecognizer</strong>, <strong>UIScrollView</strong>。列表还在继续。</p>

<p>未完待续&hellip;</p>

<h3>原文</h3>

<p>iOS Design Patterns（<a href="http://www.raywenderlich.com/46988/ios-design-patterns%EF%BC%89">http://www.raywenderlich.com/46988/ios-design-patterns%EF%BC%89</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)Variable-Sized Items in UICollectionView]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview/"/>
    <updated>2014-11-04T11:27:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview</id>
    <content type="html"><![CDATA[<h3>基本训练</h3>

<p>我们以“Single View Application”为模板新建一个工程。在ViewController.xib上添加一个UICollectionView让它覆盖整个view。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView01" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView01.png" width="1110" height="783"></p>

<p>Collection View和它的祖父类似，有delegate和dataSource两个outlet,我们把它们连接到“File’s Owner”,这里的“File’s Owner”是ViewController类。这样Collection View的内容和交互就受ViewController控制。我们也需要一个outlet来引用Collection View,所以用Assistant editor增加一个。刚在ViewController.h中添加的outlet property可以是weak，因为作为ViewController的视图的子视图，它也会被充分的保留。</p>

<h3>单元格</h3>

<p>我们需要设计一个Cell原型来显示内容。如果你的Collection View是在View controller’s XIB ,你必须在先在代码中注册Cell才能使用。如果你是在Storyboard中新建的CollectionView，并在CollectionView的区域内创建的原型Cell,那么你就不需要注册Cell identifier了。因为我们并没有从Storyboard中开始，所以需要手动来创建。</p>

<p>我们在Interface Builder中创建一个原型Cell，设置它的背影为白色，添加一个UILabel，添加Label到父视图边缘的约束，分别是5 points的距离。因为我们想让Label的文字来决定它的尺寸，所以选中Label,然后从Editor menu中选择“Size to Fit Content”。后面我们会看到它是否会按照我们想像的那样工作。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView02" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView02.png" width="964" height="400"></p>

<p>我们设置Identifier为“TagCell”以便我们能在设计中引用。</p>

<p>这里我们遇到了第一个问题。如果你没有使用Storyboards,并没有办法让Collection View在相同的NIB文件中使用Collection View Cell。有两种可行的方法注册Cell:
```objective-c</p>

<pre><code>– registerClass:forCellWithReuseIdentifier:
– registerNib:forCellWithReuseIdentifier:
</code></pre>

<p>```</p>

<p>方法一为指定的Reuse identifier实例化某个特定的类，如果我们是通过代码来创建Cell的视图层级，我们应该使用这个方法；  <br/>
方法二需要一个NIB,而且NIB文件中只有Cell一个元素。在Storyboard中使用Collection Views避免了这个麻烦，这是它工作量更小的第二个重要原因。</p>

<p>为了解决这个问题，我们创建一个“empty Interface Builder Document”，命名为TagCollectionViewCell。感激零涕我们可以简单地CMD+X Cell设计从一个ViewController NIB中，然后CMD+V它到一个空的文档中。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView03" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView03.png" width="791" height="229"></p>

<p>下一步我们将试着注册Cell在Collection View中使用，并想看到显示一定数量的元素。</p>

<h3>注册设计的单元格</h3>

<p>任何时候我们想要一个标识符为“TagCell”的Cell都需要注册设计好的NIB文件，所以我们在ViewController.m文件的viewDidLoad中加入如下代码。
```objective-c</p>

<pre><code>UINib *cellNib = [UINib nibWithNibName:@"TagCollectionViewCell" bundle:nil];
[self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@"TagCell"];
</code></pre>

<p>```</p>

<p>我们仅需要实现的更多方法属于UICollectionViewDataSource协议，这些方法确保单元格正确显示。</p>

<p>```objective-c</p>

<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 UICollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> return cell;
}
```</p></li>
</ul>


<p>现在启动应用，我们看到100个元素全部是使用我们大概还没获奖的设计原型。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView04" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView04.png" width="396" height="744"></p>

<p>一眼就看出所有的元素都拥有相同的大小，准确的50x50 points。这是因为我们没有修改Interface Builder的默认值。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView05" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView05.png" width="261" height="273"></p>

<p>但是在我们为每个元素指定大小之前，让我们首先来完善一下我们的设计。我们移除白色的背影，新建一个TagCollectionViewCell类，并且将它指定为元素的类。</p>

<h3>漂亮的单元</h3>

<p>与其依赖iOS用单元的背影颜色填充整个矩形，我们想用一个圆角的矩形包围我们的标签。</p>

<p>```objective-c
&ndash; (void)drawRect:(CGRect)rect
{
   // inset by half line width to avoid cropping where line touches frame edges
   CGRect insetRect = CGRectInset(rect, 0.5, 0.5);
   UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:insetRect cornerRadius:rect.size.height/2.0];</p>

<p>   // white background
   [[UIColor whiteColor] setFill];
   [path fill];</p>

<p>   // red outline
   [[UIColor redColor] setStroke];
   [path stroke];
}
```</p>

<p>注意：你需要设置单元的contentMode为redraw,否则修改单元的大小不会触发重绘这个漂亮的背影。</p>

<p>结果看起来像下面这样，有部分黑色的背影发光渗透。注意我们需要轻微缩进一点再绘画轮廓，因为Quartz将裁剪红色圆圈靠近视图边界的部分。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView06" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView06.png" width="394" height="110"></p>

<p>下一步是让单元的大小适合现在标签的内容。</p>

<h3>逐个元素指定大小</h3>

<p>当然我们并不满足用1）一个静态值指定所有的元素大小，所以2）想让大小随我们单元的内容自动调整。还记得我们指定元素标签依靠文本大小来决定自身大小吗？视图的边缘距离标签的边缘是固定的5 points。因此如果有一种方法能得到元素的实际大小，那将十分酷。更酷的是如果我们能告诉collection view用这些值来指定元素的大小。</p>

<p>LLDB的一个快速测试表明元素返回一个-1，-1的固定内容大小值，这个未定义是一样的。我们在TagCollectionViewCell的头文件中为Label加一个outlet,以便我们能找到UILabel返回它们显示当前文本需要的大小。</p>

<p>因为我们知道约束四周的空白，我们把它们和Label的固定内容大小相加就得到了元素的大小。
```objective-c
// cache for margins configured via constraints in XIB
static CGSize _extraMargins = {0,0};</p>

<p>@implementation TagCollectionViewCell</p>

<ul>
<li><p>(CGSize)intrinsicContentSize
{
 CGSize size = [self.label intrinsicContentSize];</p>

<p> if (CGSizeEqualToSize(<em>extraMargins, CGSizeZero))
 {
    // quick and dirty: get extra margins from constraints
    for (NSLayoutConstraint *constraint in self.constraints)
    {
       if (constraint.firstAttribute == NSLayoutAttributeBottom || constraint.firstAttribute == NSLayoutAttributeTop)
       {
          // vertical spacer
          </em>extraMargins.height += [constraint constant];
       }
       else if (constraint.firstAttribute == NSLayoutAttributeLeading || constraint.firstAttribute == NSLayoutAttributeTrailing)
       {
          // horizontal spacer
          _extraMargins.width += [constraint constant];
       }
    }
 }</p>

<p> // add to intrinsic content size of label
 size.width += <em>extraMargins.width;
 size.height += </em>extraMargins.height;</p>

<p> return size;
}</p></li>
</ul>


<p>@end
```</p>

<p>该方法从我们在Interface Builder设置的约束中得到实际的留白宽度。它允许我们在IB中调整大小而不需要在代码中改变常量或宏定义。因为我们不打算修改任何约束，只是在方法第一次被调用时懒散的设置一个静态_extraMargins作为常量。</p>

<p>现在困难的部分是从Collection view中出列一个元素并得到大小。它之所以困难是因为方法会调用数据源的collectionView:cellForItemAtIndexPath:，还会调用collectionView:layout:sizeForItemAtIndexPath:方法。这里禁止我们从后一种方法中出列一个元素，否则会导致无限循环。</p>

<p>有些人从模型对象中得到数据，然后cell有一个类方法来计算需要的大小。然而这没有利用我们想要在Interface Builder中设置的约束。对于这个先有鸡还是先有蛋的问题，我能想到的最简便的方法是使用一个单独的元素作为模板，然后使用它新鲜出炉的intrinsicContentSize方法。</p>

<p>```objective-c
@implementation ViewController
{
   TagCollectionViewCell *_sizingCell;
}</p>

<ul>
<li><p>(void)viewDidLoad
{
 [super viewDidLoad];</p>

<p> UINib *cellNib = [UINib nibWithNibName:@&ldquo;TagCollectionViewCell&rdquo; bundle:nil];
 [self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@&ldquo;TagCell&rdquo;];</p>

<p> // get a cell as template for sizing
 _sizingCell = [[cellNib instantiateWithOwner:nil options:nil] objectAtIndex:0];
}</p></li>
</ul>


<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(void)_configureCell:(TagCollectionViewCell <em>)cell forIndexPath:(NSIndexPath </em>)indexPath
{
 if (indexPath.row%2)
 {
    cell.label.text = @&ldquo;A&rdquo;;
 }
 else if (indexPath.row%3)
 {
    cell.label.text = @&ldquo;longer&rdquo;;
 }
 else
 {
    cell.label.text = @&ldquo;much longer&rdquo;;
 }
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 TagCollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> [self _configureCell:cell forIndexPath:indexPath];</p>

<p> return cell;
}</p></li>
<li><p>(CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
 [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p> return [_sizingCell intrinsicContentSize];
}</p></li>
</ul>


<p>@end
```</p>

<p>为Collection view注册了NIB之后，我创建了个元素实例并赋值给了我的实例变量 <em>sizingCell。为了得到实际元素单元，我们有一个 </em>configureCell:forIndexPath:方法，它作用于出列可复用的实例上。为了计算大小，我们应用这个相同的方法到我们的sizing cell,以便我们得到正确的intrinsicContentSize。</p>

<h3>Once More With Auto Layout</h3>

<p>当我救助我的推友们关于如何得到基于约束的元素的大小，<a href="https://twitter.com/pilky">Martin Pilkington</a>迅速将我指向-systemLayoutSizeFittingSize:。一开始在应用中失败了，得到的全是{0,0}。但是当我写完上述解决办法，沉下心来又试了一次。</p>

<p>这一次它正常工作了。所需要做的是替换下面方法：
```objective-c
&ndash; (CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
   [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p>   return [_sizingCell systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
}
```</p>

<p>这个方法决定一个最接近传入大小的布局大小。两个标准值都可行，UILayoutFittingCompressedSize得到基于布局的最小大小，UILayoutFittingExpandedSize得到最大大小。</p>

<p>有了它我们可以很愉快地利用我们之前在intrinsicContentSize做的工作。我们也可以完全使用布局约束来进一步限制元素各个部分的大小。例如说：你可能想要短标签不要窄于某个宽度；如果某个标签太长了就让它截断。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView07" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView07.png" width="394" height="214"></p>

<p>结果如下，证明确实是我们想要的。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView08" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView08.png" width="396" height="744"></p>

<p>是不是很酷？让我们再强调一次：你不需要在Cell方法中计算大小，本质是重复了auto layout将要执行的计算。你只需要向系统要。</p>

<h3>总结</h3>

<p>在这篇博文中，我向你展示了如何为Collection view创建一个来自NIB的Cell。备选方法是在Storyboard中使用Collection view，它在某些方面更方便。这些Cell没有放在单独的XIB文件中，但是是在Collection view的结构层级中。探索如何得到一个sizing cell就作为练习留给读者了。</p>

<p>我们发现UILabel暴露一个intrinsicContentSize方法十分方便，如果你在Interface Builder指定了auto layout，它会用来计算大小。我们探索了一种方法，它使用一个cell实例作为模板来决定最佳的元素大小。然后我们更进一步运用了一个方法告诉我们基于布局约束和固定内容大小的完美尺寸。</p>

<p>例子的代码放在GitHub的<a href="https://github.com/Cocoanetics/Examples">Cocoanetics Examples</a> 仓库中。</p>

<h3>原文</h3>

<p><a href="http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/">http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/19/auto-layout/"/>
    <updated>2014-10-19T17:43:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/19/auto-layout</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>Auto Layout 早在 iOS 6时就引入了，但由于之前 iPhone 的尺寸不多，而且宽度是一样的; 另一方面 Auto Layout增加了学习成本，大部分开发者仍然使用传统坐标布局做屏幕适配。但是随着 iPhone 6, 6 Plus 大屏 iPhone的发布，继续使用坐标布局做适配显得力不从心了，而且从 Apple 的动作来看，Auto Layout是未来的必然趋势，因此，我们很有必要掌握它。</p>

<h3>Auto Layout 是什么</h3>

<p>  Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. —Apple<br/>
  Auto Layout是一个通过创建元素之间关系的数学描述来布局你应用的用户界面的系统。</p>

<p>  You define these relationships in terms of constraints either on individual elements, or between sets of elements.<br/>
  你可以在单个元素，或一系列元素间以约束的形式来定义这些关系。</p>

<h4>Constraint &mdash; 约束</h4>

<p>  约束是 Auto Layout 的基石，它表达着界面元素布局的规则。我们可以把约束想像成人类语言表述的数学形式。例如，设计师可能会说“这个按钮的左边缘应该与容器视图的左边缘有20个点的偏移。”，它可以转化为button.left = (container.left + 20)，进而抽象出更一般的表达，y = m*x + b，这就是约束。这里的 y 和 x 是View的attributes，m 和 b 是浮点值。<br/>
  * attributes 有left, right, top, bottom, leading, trailing, width, height, centerX, centerY 和 baseline； <br/>
  * b 实际上是 Constant value, 是物理大小的偏移；<br/>
  * =，是 Relation, Auto Layout 支持 &lt;=, = , >= 三种关系；<br/>
  * Priority level, 约束还支持优先级，优先级高的先满足。</p>

<h4>Intrinsic Content Size</h4>

<p>  Intrinsic Content Size 是 Auto Layout 中另一个重要概念，身处视图层级末端的视图会为显示特定内容期望得到一个大小，它就叫做Intrinsic Content Size。</p>

<h3>如何使用Auto Layout</h3>

<p>  Auto Layout 的使用方法有两种：一是通过 Interface Builder, 二是 Code。</p>

<h3>Tips</h3>

<p>1,在实际的项目中，由于3.5 到5.5 Inch跨度还是挺大，建议在 ViewController 的 View 上面加一个 UIScrollView， 然后再在 ScrollView 上加一个 View， 其他的视图都布局在它上面，这样布局会容易点。</p>

<p>2,Xcode 自带布局效果预览的功能，可以按下面的步骤最大化预览编辑窗口查看在各个屏幕上的布局效果：<br/>
  * 在工程导航面板中单击 storyboard/XIB 文件，使它在 Xcode 的主窗口中打开；<br/>
  * 双击上述文件使它在新的窗口中打开； <br/>
  * 将新的窗口移动到新的桌面上，最大化它； <br/>
  * 单击下新窗口，确保它是输入焦点，然后按 Option+Command+Enter 在窗口中打开 assistant editor；  <br/>
  * 在 assistant editor 头部选中 Automatic 展开下拉菜单，在下拉菜单中选中 Preview, 可以在 Preview 中一次些查看多个布局效果图，省的来回启动模拟器。</p>

<h3>Demo</h3>

<p><a href="https://github.com/DamianSheldon/AutoLayout">Auto Layout Demo</a></p>

<h3>Reference</h3>

<p>Auto Layout Guide<br/>
WWDC2012 session 202 – Introduction to Auto Layout for iOS and OS X<br/>
WWDC2012 session 228 – Best Practices for Mastering Auto Layout<br/>
WWDC2012 session 232 – Auto Layout by Example<br/>
<a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1  ">http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1  </a>
<a href="http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2">http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2</a>  <br/>
<a href="http://objccn.io/issue-3-5/">http://objccn.io/issue-3-5/</a>  <br/>
<a href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/">http://studentdeng.github.io/blog/2014/06/13/auto-layout/</a>  <br/>
<a href="http://www.onevcat.com/2012/09/autoayout/">http://www.onevcat.com/2012/09/autoayout/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Development--Certificates, Provisioning Profiles]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates/"/>
    <updated>2014-10-09T16:24:09+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates</id>
    <content type="html"><![CDATA[<p>iOS App开发过程的真机调试和开发完成的发布要用合法的 Signing Identity 进行签名，并且要制作相应的Provising Profile。</p>

<p><img name="LaunchApp" src="http://DamianSheldon.github.io/images/LaunchApp.png" width="697" height="573"></p>

<p>开发过程的真机调试需要：</p>

<pre><code>Private Key -- 私钥
iPhone Development Certificate -- 开发证书
Development Provisioning profile
</code></pre>

<p>发布到 App Store 需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
App Store Distribution Provisioning profile
</code></pre>

<p>通过 Ad Hoc 发布需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
Ad Hoc Distribution Provisioning profile
</code></pre>

<h3>Private Key, Certificate, Provisioning Profile 的作用</h3>

<p>Private Key &mdash;私钥， 在iOS App 开发过程中，Xcode用它来签署应用。</p>

<p>Certificate &mdash;证书，它包含公钥，用来认证已签名的程序，通过认证来确定应用的来源是可信任的，并且代码是完整的， 未经修改的。</p>

<p><img name="Certificate" src="http://DamianSheldon.github.io/images/Certificate.png" width="696" height="471"> </p>

<p>Provisioning Profile &mdash;供应配置文件，它包含证书， App ID, 设备信息，它决定Xcode用哪个证书/私钥组合来签署程序, 开发设备也通过它来决定如何认证安装在设备上的程序。</p>

<p><img name="ProvisioningProfile" src="http://DamianSheldon.github.io/images/ProvisioningProfile.png" width="618" height="377"></p>

<h3>Private Key, Certificate, Provisioning Profile 的制作过程</h3>

<p>使用KeyChain申请 Certificate Signing Request (CSR)，这个过程就能生成代码签名的公、私钥对，私钥会保存在KeyChain中，公钥则包含在Certificate中。</p>

<p>Provisioning Profile的制作要复杂些，它要包含App 相应的Certificate， App ID, Development Provision Profile 还会包含 Device 信息。</p>

<h3>Tips</h3>

<p>团队开发时，我们可以通过邮件等方式分发Private Key，这样只需要制作一次 Private Key, Certificate, Provisioning Profile。</p>

<p>Xcode3.2.3预发布版本加入了新功能Team Provisioning Profile,它包含一个Wildcard App ID(*, 匹配所有应用程序)，Team中所有的Development Certificates和所有开发设备信息，增加新设备后，Xcode会自动更新Team Provisioning Profile, 因此， 团队成员可以通过设置Xcode的Provisioning Profile为Team Provisioning Profile，从而可以在所有的开发设备上调试应用程序。</p>

<p><img name="TeamProvisioningProfile" src="http://DamianSheldon.github.io/images/TeamProvisioningProfile.png" width="712" height="406">  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation 笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji/"/>
    <updated>2014-09-03T09:59:58+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji</id>
    <content type="html"><![CDATA[<h2>Core Animation介绍</h2>

<blockquote><p>Core Animation is a graphics rendering and animation infrastructure available on both iOS and OS X that you use to animate the views and other visual elements of your app. &mdash; Apple</p></blockquote>

<p>Core Animation是iOS和OS X上的图形渲染和动画的基础，你可以用它为视图以及应用的其他可见元素加上动画。</p>

<h2>什么时候使用Core Animation?</h2>

<blockquote><p>In places where you want to perform more sophisticated animations, or animations not supported by the UIView class, you can use Core Animation and the view’s underlying layer to create the animation. Because view and layer objects are intricately linked together, changes to a view’s layer affect the view itself.</p></blockquote>

<p>在你想要执行更加复杂的动画，或者UIView类不支持的动画时，你可以使用Core Animation和视图底下的layer去创建动画。因为view和layer复杂地联系在一起，改变视图的layer会影响视图本身。</p>

<p>UIView内置可动画的属性如下表：</p>

<table>
<thead>
<tr>
<th></th>
<th align="center"> Property </th>
<th align="left"> Changes you can make                                                                                       </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="center"> frame    </td>
<td align="left"> Modify this property to change the view’s size and position relative to its superview’s coordinate system. </td>
</tr>
<tr>
<td></td>
<td align="center"> bounds   </td>
<td align="left"> Modify this property to change the view’s size. </td>
</tr>
<tr>
<td></td>
<td align="center"> center   </td>
<td align="left"> Modify this property to change the view’s position relative to its superview’s coordinate system. </td>
</tr>
<tr>
<td></td>
<td align="center"> transform</td>
<td align="left"> Modify this property to scale, rotate, or translate the view relative to its center point. </td>
</tr>
<tr>
<td></td>
<td align="center"> alpha    </td>
<td align="left"> Modify this property to gradually change the transparency of the view. </td>
</tr>
<tr>
<td></td>
<td align="center"> backgroundColor </td>
<td align="left"> Modify this property to change the view’s background color. </td>
</tr>
<tr>
<td></td>
<td align="center"> contentStretch </td>
<td align="left"> Modify this property to change the way the view’s contents are stretched to fill the available space. </td>
</tr>
</tbody>
</table>


<h2>如何使用Core Animation?</h2>

<p>Core Animation提供了不少类供我们在应用中使用，下图反映了这些类的关系：</p>

<div style="text-align:center" markdown="1">

<img name="animations_info_2x" src="http://DamianSheldon.github.io/images/animations_info_2x.png" width="552" height="446">  

</div>


<ul>
<li>CAAnimation是所有动画子类的抽象类。CAAnimation实现了CAMediaTiming协议，它为动画提供duration, speed和repeat count。CAAnimation还实现了CAAction协议，协议提供标准的方法为开始一个动画去响应由layer触发的动作。</li>
</ul>


<p>CAAnimation类还定义了一个动画的timing作为CAMediaTimingFunction的实例。timing函数像简单的Bezier曲线那样描述动画的步调。线性timing function指定动画在整个动画周期内的步调是一致,而ease-in timing function导致动画在开始时会加速。</p>

<ul>
<li><p>CAPropertyAnimation是CAAnimation的一个抽象子类，它为指定key path去动画layer属性提供支持。</p></li>
<li><p>CABasicAnimation是CAPropertyAnimation的子类，它为layer的属性提供简单的插值。</p></li>
<li><p>CAKeyframeAnimation(CAPropertyAnimation的子类)提供关键帧动画支持。你指定要动画的layer属性的key path,数组中的值代表动画每个阶段的值，就像一个包含key frame time和timing function的数组。当动画运行时，数组中的值依次用来插值。</p></li>
<li><p>CATransition提供可以影响整个layer内容的变换效果。当动画时它褪色，推出，或显示layer的内容。在OS X上，股票变化效果可以通过提供你自定义的Core Image filters来扩展。</p></li>
<li><p>CAAnimationGroup允许一个数组的动画对象成一组，同时运行。</p></li>
</ul>


<p>从上述介绍来看，我们日常使用Core Animation就主要和CABasicAnimation, CAKeyframeAnimation, CATransition以及CAAnimationGroup打交道了。在使用它们之前，我们要掌握一些基础知识。</p>

<h3>Core Animation 基础</h3>

<p>Core Animation本身不是绘画系统。它是在硬件中合成和操作你应用内容的基础。这个基础的核心是layer对象，它用来管理和操作你应用的内容。layer捕获你的内容到一个bitmap中，这样它很容易被图形硬件操作。在大多数应用中，layers是视图管理内容的一种方法，但是你也可以根据你的需要创建单独的layer。</p>

<h4>Layer提供绘图和动画的基础</h4>

<p>Layer对象被组织在三维空间的二维表面上并且是你和Core Animation任何交互的核心。像视图，layer管理着它们表面关于几何位置，内容，和可视属性的信息。和视图不同，layer不定义他们自己的外观。layer仅仅管理围绕位图的状态信息。位图自己可以是视图绘制自身的结果，或者是你指定的图片。因为这个原因，你在应用中使用的主图层被认为是模型对象，因为他们主要管理数据。记住这个注解很重要，因为它影响动画的行为。</p>

<h5>基于图层的绘画模型</h5>

<p>你应用中的多数图层并不做任何最终的绘画。相反，图层捕获你应用提供的内容并将它们缓存在位图中，它们有时官能称为后备存储。当你随后改变图层的属性时，你所要做的是改变相应图层的状态信息。当改变触发动画，Core Animation传递图层的位图和状态信息到图形硬件，它用新的信息来渲染位图，像图1-1展示的的那样。在硬件上操作位图可以比软件得到更快的动画。</p>

<p>图1-1，Core Animation是如何绘制内容的。</p>

<div style="text-align:center" markdown="1">
<img name="basics_layer_rendering_2x" src="http://DamianSheldon.github.io/images/basics_layer_rendering_2x.png" width="722" height="270">  
</div>


<p>因为它是操作一张静态位图，所以基于图层的绘画和传统的基于视图的绘画技术有很大的不同。使用基于视图的绘画，视图自身的改变会导致视图的drawRect:方法被调用，它用新的参数重绘内容。但是这种绘画方式十分昂贵，因为它在主线程上用CPU完成的。Core Animation避免了这些开消通过尽可能的在硬件上操作缓存的位图来获得相同或相类似的效果。</p>

<p>虽然Core Animation尽可能的使用缓存的内容，你的应用仍然必须提供初始内容并不停的更新它。有很多方法为你应用的图层对象提供内容，这会在Providing a Layer&rsquo;s Contendts中详细描述。</p>

<h5>基于图层的动画</h5>

<p>图层对象的数据和状态信息是解藕来自屏幕图层内容的可视表示。这种解藕给Core Animation一种方法去干预自己并产生从旧状态值到新状态值的动画。例如，改变图层的位置属性导致Core Animation把图层从当前位置移动到新指定的位置。类似其他属性的改变产生合适的动画。图1-2示例了一些你可以对图层应用的动画。触发动画的图层属性列表，见Animatable Properties。</p>

<p>图1-2 你可以应用到图层的动画实例。</p>

<div style="text-align:center" markdown="1">

<img name="basics_animation_types_2x" src="http://DamianSheldon.github.io/images/basics_animation_types_2x.png" width="627" height="402">

</div>


<p>在动画的过程中,Core Animation在硬件上进行一帧一帧绘画的所有工作。你所要做的是指定动画的起点和终点，让Core Animation做剩下的所有工作。你也可以按需要指定自定义的定时信息和动画参数。而且，如果你不提供，Core Animation会提供合适的默认值。</p>

<h4>图层树反映动画状态的不同方面</h4>

<p>应用使用Core Animation拥有3套图层对象。每套图层在让你应用的内容出现在屏幕上均扮演不同的角色:</p>

<ul>
<li><p>模型图层树（或简称图层树）上的对象是应用交互最多的。树上的模型对象存储着任何动画的目标值。任何时候你改变一个图层的属性，你就使用其中的一个对象。</p></li>
<li><p>表示树上对象包含任何动画的过程值。它不仅包含动画的目标值，还反映屏幕上的当前值。你永远不应该修改这树上的对象。作为替代，你使用这些对象读取当前动画值，也许创建动画开始于某个值。</p></li>
<li><p>渲染树执行最终的动画，它对Core Animation是私有的。</p></li>
</ul>


<p>每套图层对象都被组织成层级结构，就像应用的视图。实际上，对使能了所有视图的图层的应用，每棵树的结构都和视图的层级准备对应。但是，应用也可增加图层对象，图层并不需要和视图中的图层层级相关联。你也许会在优化你应用的内容表现的情境下这么做，它不需要叠加在视图上。图1-9展示了一个简单应用的图层分解。示例中的窗口包含一个内容视图，它自身包含一个按钮视图和两个单独的图层对象。每个视图都有相应的图层对象，它们形成图层层级。</p>

<p>图1-9 窗口关联的图层</p>

<div style="text-align:center" markdown="1">

<img name="sublayer_hierarchy_2x" src="http://DamianSheldon.github.io/images/sublayer_hierarchy_2x.png" width="626" height="380" >

</div>


<p>图层树上的每一个对象，表示树和渲染树上都有相对应的对象，就像图1-10看到的那样。前面提到过，应用主要和图层树上的对象交互，但是有时也会访问表示树上的对象。特别的，访问图层树对象的<strong>presentationLayer</strong>属性可以返回表示树上相应对象。你也许会想访问这些对象去获取动画运行中的当前属性值。</p>

<p>图1-10 窗口的图层树</p>

<div style="text-align:center" markdown="1">

<img name="sublayer_hierarchies_2x" src="http://DamianSheldon.github.io/images/sublayer_hierarchies_2x.png" width="712" height="560" >

</div>


<p>重要提醒：你应该只在动画运行中去访问表示树的对象。当动画在运行中，表示树包含出现在屏幕上的图层的瞬时值。这个行为和图层树是不同的，它只反映你代码设置的最终值，等于动画的最终状态。</p>

<h4>图层和视图之间的关系</h4>

<p>图层不是用来替代你应用的视图的，你不能单独基于图层创建可视界面。图层为你的视图提供基础设施。特别地，图层让绘画更容易和高效，动画视图内容时维持高帧率。然而，有很多事情图层是做不了的。图层不处理事件，绘画内容，参与响应链，还有其他很多事情。出于这个原因，每个应用仍然要有一个或多个视图来处理这种交互。</p>

<p>在iOS中，每个视图都已备份一个相应的图层对象，但是在OS X中，你必须决定哪些视图应该拥有图层。OS X v10.8及以后的版本，为你所有的视图增加图层可能是有意义的。然而，这么做不是必须的，你仍然可以在叠加到视图是不需要的地方禁止图层。图层某种程度上会增加你应用的内存使用，但是它的好处通常会多于坏处，所以在禁用图层之前测试应用的性能是最好的方法。</p>

<p>当你为视图使能了图层支持，你创建的就是所谓的图层后备视图。在图层后备视图中，创建底层的图层对象和保持图层与视图同步是系统的责任。所有的iOS视图以及大多数OS X视图都是图层后备视图。然而，在OS X中，你也可以创建图层托管视图，它是自己为自己提供图层的视图。对于图层托管视图，AppKit提供了便利化的方法去管理图层，并不修改它来响应视图改变。</p>

<p>Note:对于图层后备视图，推荐你任何时候都优先操作视图而不是图层。在iOS中，视图仅仅是图层外面的轻薄包装，所以通常你对图层的操作是能正常工作的。<strong>但是iOS和OS X中都存在操作图层来代替视图时也许不能得到期望结果的地方。</strong>任何可能之处，本文档都会指出这些陷阱并且尝试提供方法帮助你处理它们。</p>

<p><strong>都有哪些地方呢？</strong></p>

<p>除了关联你视图的图层，你也可以创建没有相应视图的图层对象。你可以将这些单独图层嵌入到你应用的其他图层中，包括那些有关联视图的图层。通常使用单独图层作为特定优化路径的一部分。例如，如果你想在多个地方使用同一张图片，你可以加载一次这张图片，把它和多个单独图层对象关联起来，然后把这些对象回到图层树上。每个图层都引用原图而不是在内存中创建自己的副本。</p>

<h3>图层动画</h3>

<p>1)图层本身属性的动画可以通过CABasicAnimation和CAKeyframeAnimation添加；  <br/>
2)图层自定义属性动画可以参看<a href="http://objccn.io/issue-12-2/">Layer 中自定义属性的动画</a>。</p>

<h3>Reference</h3>

<p>Core Animation Programing Guide <br/>
动画解释(<a href="http://objccn.io/issue-12-1/">http://objccn.io/issue-12-1/</a>)  <br/>
Layer 中自定义属性的动画(<a href="http://objccn.io/issue-12-2/">http://objccn.io/issue-12-2/</a>)</p>
]]></content>
  </entry>
  
</feed>
