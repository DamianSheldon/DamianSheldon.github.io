<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-11-05T20:54:50+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Git 小结]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/05/git-summary/"/>
    <updated>2014-11-05T10:13:13+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/05/git-summary</id>
    <content type="html"><![CDATA[<h3>简介</h3>

<p>git &ndash; the stupid content tracker</p>

<p>这是man git中对它的介绍，我们看到它的核心是content tracker。Git是一个分布式的版本控制系统，项目是出于维护Linux内核源码的需求, 由Linus Torvalds启动的，现在已经成为最流行的版本管理系统，学会Git几乎成了开发者的必备技能。</p>

<h3>安装Git</h3>

<p>安装Git主要有两种方法：一种是通过编译源代码来安装;另一种是使用为特定平台预编译好的安装包。</p>

<h3>在服务器上布署Git</h3>

<p>尽管技术上可以从个人的仓库里推送和拉取改变,但是我们不鼓励这样做,因为一不留心就很 容易弄混其他人的进度。另外,你也一定希望合作者们即使在自己不开机的时候也能从仓库获取数据——拥有 一个更稳定的公共仓库十分有用。因此,更好的合作方式是建立一个大家都可以访问的共享仓库,从那里推送和拉取数据。我们将把这个仓库称为 “Git 服务器”;代理一个 Git 仓库只需要花费很少的资源,几乎从不 需要整个服务器来支持它的运行。</p>

<p>架设一个 Git 服务器有很多种选择，这里不打算展开，不是一下子能讲清楚的，让我们看个实例。架设一个使用SSH传输数据和使用 authorized_keys 方法来给用户授权的Git服务器：
```bash
// Step 1:创建一个 ‘git’ 用户并为其创建一个 .ssh 目录
$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh</p>

<p>// Step 2:把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。
// 假设你通过 e-mail 收到了几个 公钥并存到了临时文件里
$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys</p>

<p>// Step 3:使用 &mdash;bare 选项运行 git init 来设定一个空仓库,这会初始化一个不包含工作目录的仓库
$ cd /opt/git
$ mkdir project.git $ cd project.git
$ git &mdash;bare init</p>

<p>// Step 4:Join,Josie 或者 Jessica 就可以把它加为远程仓库,
推送一个分支,从而把第一个版本的工程上 传到仓库里了</p>

<h1>在 John 的电脑上</h1>

<p>$ cd myproject
$ git init
$ git add .
$ git commit -m &lsquo;initial commit&rsquo;
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master</p>

<p>// Step 5:其他人的克隆和推送也一样变得很简单
$ git clone git@gitserver:/opt/git/project.git $ vim README
$ git commit -am &lsquo;fix for the README file&rsquo;
$ git push origin master</p>

<p>// Step 6:用这个方法可以很快捷的为少数几个开发者架设一个可读写的 Git 服务</p>

<p>// 如何生成 SSH 公钥？
// Step 1:首先,确定一下是否已经有一个公钥了。SSH 公钥默认储存 在账户的 ~/.ssh 目录。
// 进入那里并查看其内容,有没有公钥一目了然:
$ cd ~/.ssh
$ ls
authorized_keys2 id_dsa known_hosts config id_dsa.pub</p>

<p>// Step 2:关键是看有没有用 文件名 和 文件名.pub 来命名的一对文件,
// 这个 文件名 通常是 id_dsa 或者 id_rsa。 .pub 文件是公钥,另一个文件是密钥。
// 假如没有这些文件(或者干脆连 .ssh 目录都没有),你可以用 ssh- keygen 的程序来建立它们,
// 该程序在 Linux/Mac 系统由 SSH 包提供, 在 Windows 上则包含在 MSysGit 包 里:
$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/schacon/.ssh/id_rsa.
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#99;&#104;&#x61;&#99;&#x6f;&#x6e;&#64;&#97;&#103;&#97;&#x64;&#x6f;&#114;&#108;&#97;&#x70;&#116;&#111;&#x70;&#x2e;&#x6c;&#111;&#x63;&#x61;&#108;">&#x73;&#x63;&#104;&#x61;&#x63;&#111;&#x6e;&#x40;&#x61;&#103;&#97;&#100;&#111;&#114;&#x6c;&#97;&#112;&#116;&#111;&#112;&#x2e;&#x6c;&#111;&#x63;&#x61;&#x6c;</a></p>

<p>// Step 3:它先要求你确认保存公钥的位置(.ssh/id_rsa),然后它会让你重复一个密码两次,
// 如果不想在使用公钥的 时候输入密码,可以留空。
// 现在,所有做过这一步的用户都得把它们的公钥给你
// 或者 Git 服务器的管理者(假设 SSH 服务被设定为使 用公钥机制)。
// 他们只需要复制 .put 文件的内容然后 e-email 之。公钥的样子大致如下:
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== <a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#58;&#x73;&#x63;&#x68;&#x61;&#99;&#111;&#110;&#64;&#97;&#103;&#97;&#x64;&#x6f;&#114;&#x6c;&#97;&#112;&#x74;&#x6f;&#112;&#x2e;&#108;&#x6f;&#99;&#x61;&#108;">&#115;&#99;&#x68;&#x61;&#x63;&#111;&#110;&#64;&#x61;&#x67;&#x61;&#x64;&#x6f;&#x72;&#x6c;&#97;&#112;&#x74;&#111;&#x70;&#x2e;&#x6c;&#111;&#99;&#x61;&#x6c;</a>
```</p>

<p>作为一个额外的防范措施,你可以用 Git 自带的 git-shell 简单工具来把 git 用户的活动限制在仅与 Git 相关。把它设为 git 用户登入的 shell,那么该用户就不能拥有主机正常的 shell 访问权。为了实现这一 点,需要指明用户的登入shell 是 git-shell ,而不是 bash 或者 csh。你可能得编辑 /etc/passwd 文件:
```bash
// Step 1:
$ sudo vim /etc/passwd</p>

<p>// Step 2:在文件末尾,你应该能找到类似这样的行
git:x:1000:1000::/home/git:/bin/sh</p>

<p>// Step 3:把 bin/sh 改为 /usr/bin/git-shell (或者用 which git-shell 查看它的位置)。该行修改后的样子如下
git:x:1000:1000::/home/git:/usr/bin/git-shell</p>

<p>// Step 4:现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库,而不能直接使用主机 shell。
// 尝试登录的话,你会 看到下面这样的拒绝信息
$ ssh git@gitserver
fatal: What do you think I am? A shell? (你以为我是个啥?shell吗?)
Connection to gitserver closed. (gitserver 连接已断开。)
```</p>

<h3>Git基础</h3>

<p>为了和其他人愉快地的合作开发，我们要掌握Git的基本命令。你不会想看到人民群众仇恨你。  <br/>
1)Git基础要点; <br/>
2)配置Git; <br/>
3)Git分支;
4)记录每次更新到仓库;  <br/>
5)撤消操作; <br/>
6)远程仓库的使用;  <br/>
7)打标签;  <br/>
8)查看提交历史。</p>

<h4>Git基础要点</h4>

<p>对于任何一个文件,在 Git 内都只有三种状态:已提交 (committed),已修改(modified)和已暂存(staged)。已提交表示该文件已经被安全地保存在本地数据 库中了;已修改表示修改了某个文件,但还没有提交保存;已暂存表示把已修改的文件放在下次提交时要保存 的清单中。
由此我们看到 Git 管理项目时,文件流转的三个工作区域:Git 的本地数据目录,工作目录以及暂存区域。</p>

<p>每个项目都有一个 git 目录,它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要,每次克隆 镜像仓库的时候,实际拷贝的就是这个目录里面的数据。
从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录。这些文件实际上都是从 git 目录中的压缩对象数据库中提取出来的,接下来就可以在工作目录中对这些文件进行编辑。
所谓的暂存区域只不过是个简单的文件,一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件,不过标准说法还是叫暂存区域。</p>

<p>基本的 Git 工作流程如下:  <br/>
a)在工作目录中修改某些文件;  <br/>
b)对这些修改了的文件作快照,并保存到暂存区域;  <br/>
c)提交更新,将保存在暂存区域的文件快照转储到 git 目录中.</p>

<h5>配置Git</h5>

<p>一般在新的系统上,我们都需要先配置下自己的 Git 工作环境。配置工作只需一次,以后升级时还会沿用 现在的配置。当然,如果需要,你随时可以用相同的命令修改已有的配置。</p>

<p>Git 提供了一个叫做 git config 的工具(译注:实际是 git-config 命令,只不过可以通过 git 加一个 名字来呼叫此命令。),专门用来配置或读取相应的工作环境变量。而正是由这些环境变量,决定了 Git 在 各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方:  <br/>
1)/etc/gitconfig文件:系统中对所有用户都普遍适用的配置。若使用 git config 时用 &mdash;system 选项,读写 的就是这个文件。  <br/>
2)~/.gitconfig文件:用户目录下的配置文件只适用于该用户。若使用 git config 时用 &mdash;global 选项,读写 的就是这个文件。 <br/>
3)当前项目的 git 目录中的配置文件(也就是工作目录中的 .git/config 文件):这里的配置仅仅针对当前 项目有效。每一个级别的配置都会覆盖上层的相同配置,所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</p>

<p>```bash
// Quilk config
// 用户信息
$ git config &mdash;global user.name &ldquo;John Doe&rdquo;
$ git config &mdash;global user.email <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x6a;&#x6f;&#x68;&#x6e;&#x64;&#x6f;&#101;&#64;&#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#x6a;&#111;&#104;&#110;&#100;&#x6f;&#101;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#46;&#x63;&#x6f;&#109;</a></p>

<p>// 文本编辑器
$ git config &mdash;global core.editor emacs</p>

<p>// 差异分析工具
$ git config &mdash;global merge.tool vimdiff</p>

<p>// 查看配置信息
$ git config &mdash;list</p>

<p>```</p>

<h3>Git分支</h3>

<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来,然后在不影响主线的同时继续工作。
1)新建分支;
```bash
// 新建本地分支
git branch [&mdash;set-upstream | &mdash;track | &mdash;no-track] [-l] [-f] <branchname> [&lt;start-point>]</p>

<p>&mdash;set-upstream
如果指定的分支不存在，或者指定了&mdash;force参数，作用和&mdash;track一样。
否则当创建分支时建立像&mdash;track一样的配置，除了分支的指向没有改变。</p>

<p>&mdash;track</p>

<p>当创建新的分支，从新分支建立branch.<name>.remote和branch.<name>.merge的配置入口
去标记start-point 分支作为“upstream”。
这个配置会告诉git在git status和git branch -v中显示两个分支的关系。
而且，当新的分支被检出时，它会引导git pull在没带参数时去从upstream拉代码。</p>

<p>当我们的start point是remote-tracking分支时，这一行为是默认的。
如果你想让git checkout和git branch总是像给定&mdash;no-track一样执行，设置branch.autosetupmerge 配置变量为false。
当start-point是local或remote-tracking分支时，上述行为是你想要的，那么设置它为always。</p>

<p>&mdash;no-track
不建立"upstream"配置，即使branch.autosetupmerge配置变量的值是true。</p>

<p>-l
创建分支的引用日志。它会激活对分支引用所有改变模式的记录，开启使用基于sha1表达式的日期，
如"<branchname>@{yesterday}&ldquo;。
注意在non-bare仓库中，引用日志由于core.logallrefupdates配置选项默认都开启的。</p>

<p>-f
如果<branchname>已经存在，重置<branchname>到<startpoint>。没有-f git branch将会拒绝改变。</p>

<p><branchname>
要创建或删除分支的名称。新分支的名称必须通过git-check-ref-format(1)定义的所有检查。
有些检查会限制分支名称中能使用的字符。</p>

<p>&lt;start-point>
已经存在的分支名，对它应用和<branchname>相同的限制。</p>

<p>如果我们没有指定&lt;start-point>,它默认是HEAD。
$git branch <branchname> &lt;start-point></p>

<p>// 新建远程仓库分支
git push [远程名] [本地分支]:[远程分支]</p>

<p>```</p>

<p>2)删除分支;
```bash
// 删除本地分支
$ git branch -d <branchname></p>

<p>// 删除远程分支
// 如果想在服务器上删 除 serverfix 分支,运行下面的命令:
$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
&ndash; [deleted] serverfix
```</p>

<p>3)切换分支;
<code>bash
git checkout &lt;branchname&gt;
</code></p>

<p>4)合并分支;
<code>bash
// 将sourceBranchname合并到destinationBranchname
$git checkout destinationBranchname
$git merge sourceBranchname
</code></p>

<p>5)衍合分支。
```bash
// 把一个分支整合到另一个分支的办法有两种:merge(合并) 和 rebase(衍合)。
// 把在 branchA 里产生的变化补丁重新在 branchB 的基础上打一遍。在 Git 里,这种 操作叫做衍合(rebase)。
// 有了 rebase 命令,就可以把在一个分支里提交的改变在另一个分支里重放一遍。
// 例如将experiment衍合到master分支:
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it&hellip; Applying: added staged command</p>

<p>```
关于如何进行分支管理，可以看看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">这篇博文</a>。</p>

<h5>记录每次更新到仓库</h5>

<p>版本控制的主要作用就是记录我们的更新，如果我们不将更新记录到远程仓库就失去意义了。
```bash
// 检查当前文件状态
$ git status</p>

<h1>On branch master</h1>

<p>nothing to commit (working directory clean)</p>

<p>// 跟踪新文件
$ git add newFilename</p>

<p>// 暂存已修改文件
$ git add trackedFilename</p>

<p>// 忽略某些文件
//一般我们总会有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。
我们可以创建一个名为 .gitignore 的文件,列出要忽略的 文件模式。</p>

<p>// 文件 .gitignore 的格式规范如下:
// 1)所有空行或者以注释符号 # 开头的行都会被 Git 忽略。
// 2)可以使用标准的 glob 模式匹配, 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。
// 3)匹配模式最后跟反斜杠(/)说明要忽略的是目录。
/*</p>

<h1>此为注释 – 将被 Git 忽略</h1>

<p><em>.a # 忽略所有 .a 结尾的文件
!lib.a # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件
doc/</em>.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
*/</p>

<p>// 查看已暂存和未暂存的更新
// 实际上 git status 的显示比较简单,仅仅是列出了修改过的文件,如果要查看具体修改了什么地方,可以用 git diff 命令。
$ git diff
diff &mdash;git a/benchmarks.rb b/benchmarks.rb index 3cb747f..da65585 100644
&mdash;&ndash; a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6
+ + + +
+36,10 @@ def main @commit.parents[0].parents[0].parents[0]
end
run_code(x, &lsquo;commits 1&rsquo;) do git.commits.size
end
run_code(x, &lsquo;commits 2&rsquo;) do
log = git.commits(&lsquo;master&rsquo;, 15) log.size</p>

<p>// 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用 git diff &mdash;cached 命令。</p>

<p>// 提交更新
$ git commit</p>

<p>// 跳过使用暂存区域
// 尽管使用暂存区域的方式可以精心准备要提交的细节,但有时候这么做略显繁琐。
Git 提供了一个跳过使用 暂存区域的方式,只要在提交的时候,给 git commit 加上 -a 选项,
Git 就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过 git add 步骤:
$ git commit -a -m &lsquo;added new benchmarks&rsquo;
[master 83e38c7] added new benchmarks
1 files changed, 5 insertions(+), 0 deletions(&ndash;)</p>

<p>// 移除文件
// 要从 Git 中移除某个文件,就必须要从已跟踪文件清单中移除(确切地说,是从暂存区域移除),然后提交。
可以用 git rm 命令完成此项工作,并连带从工作目录中删除指定的文件,这样以后就不会出现在未跟踪 文件清单中了。
// 如果只是简单地从工作目录中手工删除文件,运行 git status 时就会在 “Changed but not updated” 部分(也就是<em>未暂存</em>清单)看到。</p>

<p>// 移动文件
$ git mv file_from file_to</p>

<p>```</p>

<h5>撤消操作</h5>

<p>任何时候,你都有可能需要撤消刚才所做的某些操作。
```bash
// 修改最后一次提交
// 有时候我们提交完了才发现漏掉了几个文件没有加,或者提交信息写错了。想要撤消刚才的提交操作,可以 使用 &mdash;amend 选项重新提交:
$ git commit &mdash;amend</p>

<p>// 取消已经暂存的文件
git reset HEAD <file>&hellip;</p>

<p>// 取消对文件的修改
use &ldquo;git checkout &mdash; <file>&hellip;&rdquo; to discard changes in working directory</p>

<p>```</p>

<h5>远程仓库的使用</h5>

<p>```bash
// 查看当前的远程库
git remote [-v]</p>

<p>// 添加远程仓库
git remote add [shortname] [url]</p>

<p>// 从远程仓库抓取数据
$ git fetch [remote-name]</p>

<p>// 推送数据到远程仓库
git push [remote-name] [branch-name]</p>

<p>// 查看远程仓库信息
git remote show [remote-name]</p>

<p>// 远程仓库的删除和重命名
// 可以用 git remote rename 命令修改某个远程仓库的简短名称,比如想把 pb 改成 paul,可以这么运行:
$ git remote rename pb paul $ git remote
origin
paul</p>

<p>// 移除 对应的远端仓库,可以运行 git remote rm 命令:
$ git remote rm paul $ git remote
origin
```</p>

<h5>打标签</h5>

<p>人们在发布某个软件版本(比如 v1.0 等等)的时候,经常会打上一标签。
```bash
// 列显已有的标签
$ git tag v0.1
v1.3</p>

<p>// 新建标签
// Git 使用的标签有两种类型:轻量级的(lightweight)和含附注的(annotated)。
轻量级标签就像是个不 会变化的分支,实际上它就是个指向特定提交对象的引用。
而含附注标签,实际上是存储在仓库中的一个独立 对象,它有自身的校验和信息,
包含着标签的名字,电子邮件地址和日期,以及标签说明,标签本身也允许使 用 GNU Privacy Guard (GPG) 来签署或验证。
一般我们都建议使用含附注型的标签,以便保留相关信息;
当然,如果只是临时性加注标签,或者不需要旁注额外信息,用轻量级标签也没问题。</p>

<p>// 创建一个含附注类型的标签非常简单,用 -a (译注:取 annotated 的首字母)指定标签名字即可:
$ git tag -a v1.4 -m &lsquo;my version 1.4&rsquo;</p>

<p>// 可以使用 git show 命令查看相应标签的版本信息,并连同显示打标签时的提交对象。
$ git show v1.4
tag v1.4
Tagger: Scott Chacon <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#115;&#x63;&#104;&#97;&#99;&#111;&#110;&#64;&#103;&#101;&#x65;&#x2d;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#x73;&#99;&#x68;&#97;&#99;&#111;&#x6e;&#64;&#103;&#x65;&#101;&#45;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a> Date: Mon Feb 9 14:45:11 2009 -0800
my version 1.4
commit 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge: 4a447f7&hellip; a6b4c97&hellip;
Author: Scott Chacon <a href="&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#x73;&#x63;&#x68;&#x61;&#99;&#x6f;&#110;&#64;&#103;&#x65;&#101;&#45;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#x73;&#x63;&#x68;&#97;&#99;&#111;&#x6e;&#x40;&#x67;&#x65;&#x65;&#45;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a> Date: Sun Feb 8 19:02:46 2009 -0800
Merge branch &lsquo;experiment&rsquo;</p>

<p>// 签署标签
//如果你有自己的私钥,还可以用 GPG 来签署标签,只需要把之前的 -a 改为 -s (译注: 取 Signed 的首
字母)即可:
$ git tag -s v1.5 -m &lsquo;my signed 1.5 tag&rsquo;
You need a passphrase to unlock the secret key for user: &ldquo;Scott Chacon <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x73;&#x63;&#104;&#97;&#99;&#111;&#x6e;&#x40;&#103;&#x65;&#101;&#45;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#115;&#x63;&#104;&#97;&#x63;&#x6f;&#110;&#x40;&#103;&#101;&#x65;&#x2d;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a>&rdquo;
1024-bit DSA key, ID F721C45A, created 2009-02-09</p>

<p>// 轻量级标签
// 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。
要创建这样的标签,一个 -a,-s 或 -m 选项都不用,直接给出标签名字即可:
$ git tag v1.4-lw</p>

<p>// 验证标签
// 可以使用 git tag -v [tag-name] (译注:取 verify 的首字母)的方式验证已经签署的标签。
此命令会调用 GPG 来验证签名,所以你需要有签署者的公钥,存放在 keyring 中,才能验证:
$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano <a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x6a;&#x75;&#x6e;&#107;&#x69;&#111;&#x40;&#x63;&#x6f;&#120;&#46;&#x6e;&#101;&#116;">&#106;&#x75;&#x6e;&#x6b;&#x69;&#x6f;&#x40;&#99;&#111;&#x78;&#46;&#x6e;&#x65;&#x74;</a> 1158138501 -0700
GIT 1.4.2.1
Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &ldquo;Junio C Hamano <a href="&#x6d;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#x6a;&#x75;&#110;&#x6b;&#105;&#111;&#x40;&#x63;&#x6f;&#x78;&#x2e;&#110;&#101;&#x74;">&#x6a;&#117;&#110;&#x6b;&#105;&#x6f;&#64;&#99;&#111;&#x78;&#x2e;&#110;&#x65;&#116;</a>&rdquo;
gpg: aka &ldquo;[jpeg image of size 1513]&rdquo;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A</p>

<p>// 后期加注标签
// 比如在下面展示的提交历史中:
$ git log &mdash;pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &lsquo;experiment&rsquo;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &lsquo;experiment&rsquo;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</p>

<p>// 我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2,没关系,现在也能做。
只要在打标 签的时候跟上对应提交对象的校验和(或前几位字符)即可:
$ git tag -a v1.2 9fceb02</p>

<p>// 分享标签
// 默认情况下,git push 并不会把标签传送到远端服务器上,只有通过显式命令才能分享标签到远端仓库。
其命令格式如同推送分支,运行 git push origin [tagname] 即可:
$ git push origin v1.5
Counting objects: 50, done.
Compressing objects: 100% (38/38), done. Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
* [new tag] v1.5 &ndash;> v1.5</p>

<p>// 如果要一次推送所有(本地新增的)标签上去,可以使用 &mdash;tags 选项:
$ git push origin &mdash;tags
```</p>

<h5>查看提交历史</h5>

<p>```bash
// 在提交了若干更新之后,又或者克隆了某个项目,想回顾下提交历史,可以使用 git log 命令。</p>

<p>// 我们常用 -p 选项展开显示每次提交的内容差异,用 -2 则仅显示最近的两次更新:
$ git log –p -2</p>

<p>// 还有 许多摘要选项可以用,比如 &mdash;stat,仅显示简要的增改行数统计:
$git log &mdash;stat</p>

<p>// 限制输出长度
// 列出所有最近两周内的提交
$ git log &mdash;since=2.weeks</p>

<p>```</p>

<h3>分布式工作流程</h3>

<p>在服务器上布暑好了Git，并建好代码仓库以后，团队成员就可以愉快地合作开发了。由于团队的规模不一样，工作流程也会略有区别，我们先通过最简单的私有的小型团队来掌握基本的流程，其他的情况也就容易理解了。
```bash
//一个私有项目,与你一起协作的还有另外一到两位开发者。这里说私有,是指源代码不公开,其他人无法访问项目仓库。</p>

<h1>John&rsquo;s Machine</h1>

<p>// Step 1: 克隆一份项目代码到本地
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/ &hellip;</p>

<p>// Step 2: 打开项目，编辑，完成属于自己的任务
$ cd simplegit/
$ vim lib/simplegit.rb</p>

<p>// Step 3:更新项目，因为在你完成任务的时间窗口中团队其他成员可能提交过代码
$ git fetch origin
&hellip;
From john@githost:simplegit
+ 049d078&hellip;fbff5bc master &ndash;> origin/master</p>

<p>// Step 4:合并分支，将团队成员的代码和自己的代码合并到一起
$ git merge origin/master Merge made by recursive.
TODO | 1 +
1 files changed, 1 insertions(+), 0 deletions(&ndash;)</p>

<p>// Step 5:合并分支冲突时
$git status</p>

<p>index.html: needs merge</p>

<h1># # # # #</h1>

<p>On branch master
Changed but not updated:
(use &ldquo;git add <file>&hellip;&rdquo; to update what will be committed)
(use &ldquo;git checkout &mdash; <file>&hellip;&rdquo; to discard changes in working directory)
unmerged: index.html</p>

<p>// 任何包含未解决冲突的文件都会以未合并(unmerged)状态列出。
Git 会在有冲突的文件里加入标准的冲突 解决标记,可以通过它们来手工定位并解决这些冲突。
可以看到此文件包含类似下面这样的部分:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</p>

<div id="footer">contact : email.support@github.com</div>


<h1> </h1>

<div id="footer">
please contact us at support@github.com </div>


<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>iss53:index.html</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

<p>// 可以看到 ======= 隔开的上半部分,是 HEAD(即 master 分支,在运行 merge 命令时检出的分支)中的内 容,
下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
比如你可以通过把这段内容替换为下面这样来解决:</p>

<div id="footer">
please contact us at email.support@github.com </div>


<p>// Step 6:手动解决冲突，然后运行 git add 将把它们标记为已解决(resolved),
如果觉得满意了,并且确认所有冲突都已解决,也就是进入了缓存区,就可以用 git commit 来完成这次合并提交。</p>

<p>$ git commit -am &lsquo;removed invalid default value&rsquo;
[master 738ee87] removed invalid default value
1 files changed, 1 insertions(+), 1 deletions(&ndash;)</p>

<p>// Step 7:将完成的代码推送到服务器的代码仓库中
$ git push origin master
&hellip;
To jessica@githost:simplegit.git
1edee6b..fbff5bc master &ndash;> master</p>

<p>```</p>

<h4>Refernce</h4>

<p><a href="http://git-scm.com/book/zh/v1">Pro Git</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)Variable-Sized Items in UICollectionView]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview/"/>
    <updated>2014-11-04T11:27:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview</id>
    <content type="html"><![CDATA[<h3>基本训练</h3>

<p>我们以“Single View Application”为模板新建一个工程。在ViewController.xib上添加一个UICollectionView让它覆盖整个view。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView01" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView01.png" width="1110" height="783"></p>

<p>Collection View和它的祖父类似，有delegate和dataSource两个outlet,我们把它们连接到“File’s Owner”,这里的“File’s Owner”是ViewController类。这样Collection View的内容和交互就受ViewController控制。我们也需要一个outlet来引用Collection View,所以用Assistant editor增加一个。刚在ViewController.h中添加的outlet property可以是weak，因为作为ViewController的视图的子视图，它也会被充分的保留。</p>

<h3>单元格</h3>

<p>我们需要设计一个Cell原型来显示内容。如果你的Collection View是在View controller’s XIB ,你必须在先在代码中注册Cell才能使用。如果你是在Storyboard中新建的CollectionView，并在CollectionView的区域内创建的原型Cell,那么你就不需要注册Cell identifier了。因为我们并没有从Storyboard中开始，所以需要手动来创建。</p>

<p>我们在Interface Builder中创建一个原型Cell，设置它的背影为白色，添加一个UILabel，添加Label到父视图边缘的约束，分别是5 points的距离。因为我们想让Label的文字来决定它的尺寸，所以选中Label,然后从Editor menu中选择“Size to Fit Content”。后面我们会看到它是否会按照我们想像的那样工作。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView02" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView02.png" width="964" height="400"></p>

<p>我们设置Identifier为“TagCell”以便我们能在设计中引用。</p>

<p>这里我们遇到了第一个问题。如果你没有使用Storyboards,并没有办法让Collection View在相同的NIB文件中使用Collection View Cell。有两种可行的方法注册Cell:
```objective-c</p>

<pre><code>– registerClass:forCellWithReuseIdentifier:
– registerNib:forCellWithReuseIdentifier:
</code></pre>

<p>```</p>

<p>方法一为指定的Reuse identifier实例化某个特定的类，如果我们是通过代码来创建Cell的视图层级，我们应该使用这个方法；  <br/>
方法二需要一个NIB,而且NIB文件中只有Cell一个元素。在Storyboard中使用Collection Views避免了这个麻烦，这是它工作量更小的第二个重要原因。</p>

<p>为了解决这个问题，我们创建一个“empty Interface Builder Document”，命名为TagCollectionViewCell。感激零涕我们可以简单地CMD+X Cell设计从一个ViewController NIB中，然后CMD+V它到一个空的文档中。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView03" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView03.png" width="791" height="229"></p>

<p>下一步我们将试着注册Cell在Collection View中使用，并想看到显示一定数量的元素。</p>

<h3>注册设计的单元格</h3>

<p>任何时候我们想要一个标识符为“TagCell”的Cell都需要注册设计好的NIB文件，所以我们在ViewController.m文件的viewDidLoad中加入如下代码。
```objective-c</p>

<pre><code>UINib *cellNib = [UINib nibWithNibName:@"TagCollectionViewCell" bundle:nil];
[self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@"TagCell"];
</code></pre>

<p>```</p>

<p>我们仅需要实现的更多方法属于UICollectionViewDataSource协议，这些方法确保单元格正确显示。</p>

<p>```objective-c</p>

<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 UICollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> return cell;
}
```</p></li>
</ul>


<p>现在启动应用，我们看到100个元素全部是使用我们大概还没获奖的设计原型。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView04" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView04.png" width="396" height="744"></p>

<p>一眼就看出所有的元素都拥有相同的大小，准确的50x50 points。这是因为我们没有修改Interface Builder的默认值。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView05" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView05.png" width="261" height="273"></p>

<p>但是在我们为每个元素指定大小之前，让我们首先来完善一下我们的设计。我们移除白色的背影，新建一个TagCollectionViewCell类，并且将它指定为元素的类。</p>

<h3>漂亮的单元</h3>

<p>与其依赖iOS用单元的背影颜色填充整个矩形，我们想用一个圆角的矩形包围我们的标签。</p>

<p>```objective-c
&ndash; (void)drawRect:(CGRect)rect
{
   // inset by half line width to avoid cropping where line touches frame edges
   CGRect insetRect = CGRectInset(rect, 0.5, 0.5);
   UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:insetRect cornerRadius:rect.size.height/2.0];</p>

<p>   // white background
   [[UIColor whiteColor] setFill];
   [path fill];</p>

<p>   // red outline
   [[UIColor redColor] setStroke];
   [path stroke];
}
```</p>

<p>注意：你需要设置单元的contentMode为redraw,否则修改单元的大小不会触发重绘这个漂亮的背影。</p>

<p>结果看起来像下面这样，有部分黑色的背影发光渗透。注意我们需要轻微缩进一点再绘画轮廓，因为Quartz将裁剪红色圆圈靠近视图边界的部分。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView06" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView06.png" width="394" height="110"></p>

<p>下一步是让单元的大小适合现在标签的内容。</p>

<h3>逐个元素指定大小</h3>

<p>当然我们并不满足用1）一个静态值指定所有的元素大小，所以2）想让大小随我们单元的内容自动调整。还记得我们指定元素标签依靠文本大小来决定自身大小吗？视图的边缘距离标签的边缘是固定的5 points。因此如果有一种方法能得到元素的实际大小，那将十分酷。更酷的是如果我们能告诉collection view用这些值来指定元素的大小。</p>

<p>LLDB的一个快速测试表明元素返回一个-1，-1的固定内容大小值，这个未定义是一样的。我们在TagCollectionViewCell的头文件中为Label加一个outlet,以便我们能找到UILabel返回它们显示当前文本需要的大小。</p>

<p>因为我们知道约束四周的空白，我们把它们和Label的固定内容大小相加就得到了元素的大小。
```objective-c
// cache for margins configured via constraints in XIB
static CGSize _extraMargins = {0,0};</p>

<p>@implementation TagCollectionViewCell</p>

<ul>
<li><p>(CGSize)intrinsicContentSize
{
 CGSize size = [self.label intrinsicContentSize];</p>

<p> if (CGSizeEqualToSize(<em>extraMargins, CGSizeZero))
 {
    // quick and dirty: get extra margins from constraints
    for (NSLayoutConstraint *constraint in self.constraints)
    {
       if (constraint.firstAttribute == NSLayoutAttributeBottom || constraint.firstAttribute == NSLayoutAttributeTop)
       {
          // vertical spacer
          </em>extraMargins.height += [constraint constant];
       }
       else if (constraint.firstAttribute == NSLayoutAttributeLeading || constraint.firstAttribute == NSLayoutAttributeTrailing)
       {
          // horizontal spacer
          _extraMargins.width += [constraint constant];
       }
    }
 }</p>

<p> // add to intrinsic content size of label
 size.width += <em>extraMargins.width;
 size.height += </em>extraMargins.height;</p>

<p> return size;
}</p></li>
</ul>


<p>@end
```</p>

<p>该方法从我们在Interface Builder设置的约束中得到实际的留白宽度。它允许我们在IB中调整大小而不需要在代码中改变常量或宏定义。因为我们不打算修改任何约束，只是在方法第一次被调用时懒散的设置一个静态_extraMargins作为常量。</p>

<p>现在困难的部分是从Collection view中出列一个元素并得到大小。它之所以困难是因为方法会调用数据源的collectionView:cellForItemAtIndexPath:，还会调用collectionView:layout:sizeForItemAtIndexPath:方法。这里禁止我们从后一种方法中出列一个元素，否则会导致无限循环。</p>

<p>有些人从模型对象中得到数据，然后cell有一个类方法来计算需要的大小。然而这没有利用我们想要在Interface Builder中设置的约束。对于这个先有鸡还是先有蛋的问题，我能想到的最简便的方法是使用一个单独的元素作为模板，然后使用它新鲜出炉的intrinsicContentSize方法。</p>

<p>```objective-c
@implementation ViewController
{
   TagCollectionViewCell *_sizingCell;
}</p>

<ul>
<li><p>(void)viewDidLoad
{
 [super viewDidLoad];</p>

<p> UINib *cellNib = [UINib nibWithNibName:@&ldquo;TagCollectionViewCell&rdquo; bundle:nil];
 [self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@&ldquo;TagCell&rdquo;];</p>

<p> // get a cell as template for sizing
 _sizingCell = [[cellNib instantiateWithOwner:nil options:nil] objectAtIndex:0];
}</p></li>
</ul>


<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(void)_configureCell:(TagCollectionViewCell <em>)cell forIndexPath:(NSIndexPath </em>)indexPath
{
 if (indexPath.row%2)
 {
    cell.label.text = @&ldquo;A&rdquo;;
 }
 else if (indexPath.row%3)
 {
    cell.label.text = @&ldquo;longer&rdquo;;
 }
 else
 {
    cell.label.text = @&ldquo;much longer&rdquo;;
 }
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 TagCollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> [self _configureCell:cell forIndexPath:indexPath];</p>

<p> return cell;
}</p></li>
<li><p>(CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
 [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p> return [_sizingCell intrinsicContentSize];
}</p></li>
</ul>


<p>@end
```</p>

<p>为Collection view注册了NIB之后，我创建了个元素实例并赋值给了我的实例变量 <em>sizingCell。为了得到实际元素单元，我们有一个 </em>configureCell:forIndexPath:方法，它作用于出列可复用的实例上。为了计算大小，我们应用这个相同的方法到我们的sizing cell,以便我们得到正确的intrinsicContentSize。</p>

<h3>Once More With Auto Layout</h3>

<p>当我救助我的推友们关于如何得到基于约束的元素的大小，<a href="https://twitter.com/pilky">Martin Pilkington</a>迅速将我指向-systemLayoutSizeFittingSize:。一开始在应用中失败了，得到的全是{0,0}。但是当我写完上述解决办法，沉下心来又试了一次。</p>

<p>这一次它正常工作了。所需要做的是替换下面方法：
```objective-c
&ndash; (CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
   [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p>   return [_sizingCell systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
}
```</p>

<p>这个方法决定一个最接近传入大小的布局大小。两个标准值都可行，UILayoutFittingCompressedSize得到基于布局的最小大小，UILayoutFittingExpandedSize得到最大大小。</p>

<p>有了它我们可以很愉快地利用我们之前在intrinsicContentSize做的工作。我们也可以完全使用布局约束来进一步限制元素各个部分的大小。例如说：你可能想要短标签不要窄于某个宽度；如果某个标签太长了就让它截断。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView07" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView07.png" width="394" height="214"></p>

<p>结果如下，证明确实是我们想要的。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView08" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView08.png" width="396" height="744"></p>

<p>是不是很酷？让我们再强调一次：你不需要在Cell方法中计算大小，本质是重复了auto layout将要执行的计算。你只需要向系统要。</p>

<h3>总结</h3>

<p>在这篇博文中，我向你展示了如何为Collection view创建一个来自NIB的Cell。备选方法是在Storyboard中使用Collection view，它在某些方面更方便。这些Cell没有放在单独的XIB文件中，但是是在Collection view的结构层级中。探索如何得到一个sizing cell就作为练习留给读者了。</p>

<p>我们发现UILabel暴露一个intrinsicContentSize方法十分方便，如果你在Interface Builder指定了auto layout，它会用来计算大小。我们探索了一种方法，它使用一个cell实例作为模板来决定最佳的元素大小。然后我们更进一步运用了一个方法告诉我们基于布局约束和固定内容大小的完美尺寸。</p>

<p>例子的代码放在GitHub的<a href="https://github.com/Cocoanetics/Examples">Cocoanetics Examples</a> 仓库中。</p>

<h3>原文</h3>

<p><a href="http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/">http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iTunes 歌曲信息乱码的解决办法]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/03/music-import-from-windows-text-display-garbled-in-itunes/"/>
    <updated>2014-11-03T10:23:29+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/03/music-import-from-windows-text-display-garbled-in-itunes</id>
    <content type="html"><![CDATA[<p>从Windows迁移过来的歌曲在iTunes中乱码显示，按照Apple support里面的方法添加语言并没有解决问题，因此，我推测问题应该不是出在这。经过查找，发现问题是由于歌曲的ID3中的Enconding by字段的影响，也就是说，编码格式不一样。解决办法： <br/>
1)下载<a href="https://bitbucket.org/lazka/mutagen">Mutagen</a>; <br/>
2)安装Mutagen; <br/>
```bash</p>

<pre><code>$ path_to_mutagen/setup.py build
$ sudo path_to_mutagen/setup.py install
</code></pre>

<p><code>
3)先将所有歌曲备份，防止操作出错；  
4)将目录下的所有MP3歌曲的编码转成Unicode;  
</code>bash</p>

<pre><code>$find . -iname "*.mp3" -execdir mid3iconv -e gbk {} \;  
</code></pre>

<p>```
5)将iTunes中的音乐清空，重新添加。</p>

<p>Reference:<a href="http://floss.zoomquiet.io/data/20070510235547/index.html">http://floss.zoomquiet.io/data/20070510235547/index.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/19/auto-layout/"/>
    <updated>2014-10-19T17:43:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/19/auto-layout</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>Auto Layout 早在 iOS 6时就引入了，但由于之前 iPhone 的尺寸不多，而且宽度是一样的; 另一方面 Auto Layout增加了学习成本，大部分开发者仍然使用传统坐标布局做屏幕适配。但是随着 iPhone 6, 6 Plus 大屏 iPhone的发布，继续使用坐标布局做适配显得力不从心了，而且从 Apple 的动作来看，Auto Layout是未来的必然趋势，因此，我们很有必要掌握它。</p>

<h3>Auto Layout 是什么</h3>

<p>  Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. —Apple<br/>
  Auto Layout是一个通过创建元素之间关系的数学描述来布局你应用的用户界面的系统。</p>

<p>  You define these relationships in terms of constraints either on individual elements, or between sets of elements.<br/>
  你可以在单个元素，或一系列元素间以约束的形式来定义这些关系。</p>

<h4>Constraint &mdash; 约束</h4>

<p>  约束是 Auto Layout 的基石，它表达着界面元素布局的规则。我们可以把约束想像成人类语言表述的数学形式。例如，设计师可能会说“这个按钮的左边缘应该与容器视图的左边缘有20个点的偏移。”，它可以转化为button.left = (container.left + 20)，进而抽象出更一般的表达，y = m*x + b，这就是约束。这里的 y 和 x 是View的attributes，m 和 b 是浮点值。<br/>
  * attributes 有left, right, top, bottom, leading, trailing, width, height, centerX, centerY 和 baseline； <br/>
  * b 实际上是 Constant value, 是物理大小的偏移；<br/>
  * =，是 Relation, Auto Layout 支持 &lt;=, = , >= 三种关系；<br/>
  * Priority level, 约束还支持优先级，优先级高的先满足。</p>

<h4>Intrinsic Content Size</h4>

<p>  Intrinsic Content Size 是 Auto Layout 中另一个重要概念，身处视图层级末端的视图会为显示特定内容期望得到一个大小，它就叫做Intrinsic Content Size。</p>

<h3>如何使用Auto Layout</h3>

<p>  Auto Layout 的使用方法有两种：一是通过 Interface Builder, 二是 Code。</p>

<h3>Tips</h3>

<p>1,在实际的项目中，由于3.5 到5.5 Inch跨度还是挺大，建议在 ViewController 的 View 上面加一个 UIScrollView， 然后再在 ScrollView 上加一个 View， 其他的视图都布局在它上面，这样布局会容易点。</p>

<p>2,Xcode 自带布局效果预览的功能，可以按下面的步骤最大化预览编辑窗口查看在各个屏幕上的布局效果：<br/>
  * 在工程导航面板中单击 storyboard/XIB 文件，使它在 Xcode 的主窗口中打开；<br/>
  * 双击上述文件使它在新的窗口中打开； <br/>
  * 将新的窗口移动到新的桌面上，最大化它； <br/>
  * 单击下新窗口，确保它是输入焦点，然后按 Option+Command+Enter 在窗口中打开 assistant editor；  <br/>
  * 在 assistant editor 头部选中 Automatic 展开下拉菜单，在下拉菜单中选中 Preview, 可以在 Preview 中一次些查看多个布局效果图，省的来回启动模拟器。</p>

<h3>Demo</h3>

<p><a href="https://github.com/DamianSheldon/AutoLayout">Auto Layout Demo</a></p>

<h3>Reference</h3>

<p>Auto Layout Guide<br/>
WWDC2012 session 202 – Introduction to Auto Layout for iOS and OS X<br/>
WWDC2012 session 228 – Best Practices for Mastering Auto Layout<br/>
WWDC2012 session 232 – Auto Layout by Example<br/>
<a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1  ">http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1  </a>
<a href="http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2">http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2</a>  <br/>
<a href="http://objccn.io/issue-3-5/">http://objccn.io/issue-3-5/</a>  <br/>
<a href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/">http://studentdeng.github.io/blog/2014/06/13/auto-layout/</a>  <br/>
<a href="http://www.onevcat.com/2012/09/autoayout/">http://www.onevcat.com/2012/09/autoayout/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Development--Certificates, Provisioning Profiles]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates/"/>
    <updated>2014-10-09T16:24:09+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates</id>
    <content type="html"><![CDATA[<p>iOS App开发过程的真机调试和开发完成的发布要用合法的 Signing Identity 进行签名，并且要制作相应的Provising Profile。</p>

<p><img name="LaunchApp" src="http://DamianSheldon.github.io/images/LaunchApp.png" width="697" height="573"></p>

<p>开发过程的真机调试需要：</p>

<pre><code>Private Key -- 私钥
iPhone Development Certificate -- 开发证书
Development Provisioning profile
</code></pre>

<p>发布到 App Store 需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
App Store Distribution Provisioning profile
</code></pre>

<p>通过 Ad Hoc 发布需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
Ad Hoc Distribution Provisioning profile
</code></pre>

<h3>Private Key, Certificate, Provisioning Profile 的作用</h3>

<p>Private Key &mdash;私钥， 在iOS App 开发过程中，Xcode用它来签署应用。</p>

<p>Certificate &mdash;证书，它包含公钥，用来认证已签名的程序，通过认证来确定应用的来源是可信任的，并且代码是完整的， 未经修改的。</p>

<p><img name="Certificate" src="http://DamianSheldon.github.io/images/Certificate.png" width="696" height="471"> </p>

<p>Provisioning Profile &mdash;供应配置文件，它包含证书， App ID, 设备信息，它决定Xcode用哪个证书/私钥组合来签署程序, 开发设备也通过它来决定如何认证安装在设备上的程序。</p>

<p><img name="ProvisioningProfile" src="http://DamianSheldon.github.io/images/ProvisioningProfile.png" width="618" height="377"></p>

<h3>Private Key, Certificate, Provisioning Profile 的制作过程</h3>

<p>使用KeyChain申请 Certificate Signing Request (CSR)，这个过程就能生成代码签名的公、私钥对，私钥会保存在KeyChain中，公钥则包含在Certificate中。</p>

<p>Provisioning Profile的制作要复杂些，它要包含App 相应的Certificate， App ID, Development Provision Profile 还会包含 Device 信息。</p>

<h3>Tips</h3>

<p>团队开发时，我们可以通过邮件等方式分发Private Key，这样只需要制作一次 Private Key, Certificate, Provisioning Profile。</p>

<p>Xcode3.2.3预发布版本加入了新功能Team Provisioning Profile,它包含一个Wildcard App ID(*, 匹配所有应用程序)，Team中所有的Development Certificates和所有开发设备信息，增加新设备后，Xcode会自动更新Team Provisioning Profile, 因此， 团队成员可以通过设置Xcode的Provisioning Profile为Team Provisioning Profile，从而可以在所有的开发设备上调试应用程序。</p>

<p><img name="TeamProvisioningProfile" src="http://DamianSheldon.github.io/images/TeamProvisioningProfile.png" width="712" height="406">  </p>
]]></content>
  </entry>
  
</feed>
