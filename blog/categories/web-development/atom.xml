<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/web-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2023-02-03T11:20:40+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HotSpot 虚拟机垃圾收集调优总结]]></title>
    <link href="http://DamianSheldon.github.io/blog/hotspot-virtual-machine-garbage-collection-tuning-summary.html"/>
    <updated>2023-02-03T09:34:30+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/hotspot-virtual-machine-garbage-collection-tuning-summary</id>
    <content type="html"><![CDATA[<p>工作中我们可能需要对 HotSpot 虚拟机垃圾收集调优，那么应该怎么做呢？</p>

<p>Oracle 在 HotSpot Virtual Machine Garbage Collection Tuning Guide 提到过一个调优策略：</p>

<blockquote><p>Tuning Strategy</p>

<p>Do not choose a maximum value for the heap unless you know that you need a heap greater than the default maximum heap size. Choose a throughput goal that is sufficient for your application.</p>

<p>The heap will grow or shrink to a size that will support the chosen throughput goal. A change in the application&rsquo;s behavior can cause the heap to grow or shrink. For example, if the application starts allocating at a higher rate, the heap will grow to maintain the same throughput.</p>

<p>If the heap grows to its maximum size and the throughput goal is not being met, the maximum heap size is too small for the throughput goal. Set the maximum heap size to a value that is close to the total physical memory on the platform but which does not cause swapping of the application. Execute the application again. If the throughput goal is still not met, then the goal for the application time is too high for the available memory on the platform.</p>

<p>If the throughput goal can be met, but there are pauses that are too long, then select a maximum pause time goal. Choosing a maximum pause time goal may mean that your throughput goal will not be met, so choose values that are an acceptable compromise for the application.</p>

<p>It is typical that the size of the heap will oscillate as the garbage collector tries to satisfy competing goals. This is true even if the application has reached a steady state. The pressure to achieve a throughput goal (which may require a larger heap) competes with the goals for a maximum pause time and a minimum footprint (which both may require a small heap).</p></blockquote>

<p>这个调优的策略比较粗，可以作为我们调优的总纲领，还需要更细化一下才更具可操作性。</p>

<!--more-->


<blockquote><p>Selecting a Collector</p>

<p>Unless your application has rather strict pause-time requirements, first run your application and allow the VM to select a collector.</p>

<p>If necessary, adjust the heap size to improve performance. If the performance still doesn&rsquo;t meet your goals, then use the following guidelines as a starting point for selecting a collector:</p>

<ul>
<li>If the application has a small data set (up to approximately 100 MB), then select the serial collector with the option <code>-XX:+UseSerialGC</code>. </li>
<li>If the application will be run on a single processor and there are no pause-time requirements, then select the serial collector with the option <code>-XX:+UseSerialGC</code>. </li>
<li>If (a) peak application performance is the first priority and (b) there are no pause-time requirements or pauses of one second or longer are acceptable, then let the VM select the collector or select the parallel collector with <code>-XX:+UseParallelGC</code>. </li>
<li>If response time is more important than overall throughput and garbage collection pauses must be kept shorter, then select the mostly concurrent collector with <code>-XX:+UseG1GC</code>. </li>
<li>If response time is a high priority, then select a fully concurrent collector with <code>-XX:+UseZGC</code>.
 这份指南就更具操作性了。</li>
</ul>
</blockquote>

<p>周志明老师在他的《深入理解 java 虚拟机》中介绍了如何权衡收集器：</p>

<blockquote><p>现在可能有读者要犯选择困难症了，我们应该如何选择一款适合自己应用的收集器呢？这个问题主要受以下三个因素影响：</p>

<ul>
<li><p>应用程序的主要关注点是什么?如果是数据分析、科学计算类的任务，目标是尽可能快算出结果，那吞吐量就是主要关注点；如果是 SLA 应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延时就是主要关注点；而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。</p></li>
<li><p>运行应用的基础设施如何？譬如硬件规格，要涉及的系统架构是x86-32/64、SPAR 还是 ARM/Aarch64；处理器的数量多少，分配的内存大小；选择的操作系统是Linux、Solaris 还是 Windows 等。</p></li>
<li><p>使用 JDK 的发行商是什么？版本号是多少？是 ZingJDK/Zulu、OracleJDK、OpenJDK、OpenJ9 抑或是其他公司的发行版? 该 JDK 对应了《 Java 虚拟机规范 》的哪个版本？</p></li>
</ul>


<p>一般来说，收集器的选择就从以上这几点出发来考虑。举个例子，假设某个直接面向用户提供服务的 B/S 系统准备选择垃圾收集器，一般来说延迟时间是这类应用的主要关注点，那么：</p>

<ul>
<li><p>如果你有充足的预算但没有太多调优经验，那么一套带有商业技术支持的专有硬件或软件解决方案是不错的选择。Azul 公司以前主推的 Vega 系统和现在主推的 Zing VM 是这方面的代表，这样你就可以使用传说中的 C4 收集器。</p></li>
<li><p>如果你虽然没有充足的预算去使用商业解决方案，但能掌握软硬件型号，使用较新的版本，同时又特别注重延时，那 ZGC 很值得尝试。</p></li>
<li><p>如果你对还处于实验状态的收集器的稳定性有顾虑，或者必须运行在 Windows 操作系统下，那 ZGC 无缘了，试试 Shenandoah 吧。</p></li>
<li><p>如果你接手的是遗留系统，软硬件基础设施和 JDK 版本都比较落后，那就根据内存规模衡量一下，对于大概 4GB 到 6GB 以下的堆内存，CMS 一般能处理得比较好，而对于更大的堆内存，可重点考察一下 G1。</p></li>
</ul>


<p>当然，以上都是仅从理论出发的分析，实战中切不可纸上谈兵，根据系统实际情况去测试才是选择收集器的最终依据。</p></blockquote>

<p>这里的建议更具体，结合这两份建议，谈谈我个人的理解。</p>

<p>目前 HotSpot 虚拟机主要有 Serial, Parallel, CMS, Shenandoah 和 ZGC 这几款收集器，Serial, Parallel 主要关注吞吐量; CMS, Shenandoah 和 ZGC 主要关注低延时。</p>

<p>在做 Java 服务端开发时，我们基本可以不考虑 Serial 收集器。而服务端的应用主要是面向用户提供服务的，所以要选择低延时的收集器。根据使用 java 版本和堆内存大小从 CMS, G1 和 ZGC 中选择，然后进行测试，根据测试结果选择。</p>

<p>下面举个 Tomcat 的例子，Tomcat 9 支持 java 8 及以上的版本，可以用来试验各自收集器。</p>

<p>在 Tomcat 的安装包对应的 bin 目录下新建 setenv.sh 文件:</p>

<pre><code>#!/bin/sh
# Set any additional Tomcat options
#CATALINA_OPTS="-Dcatalina.base=$CATALINA_HOME -Dcatalina.home=$CATALINA_HOME"
#CATALINA_OPTS="-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/usr/local/apache-tomcat-9.0.35/logs/parallel-gc.log"
#CATALINA_OPTS="-XX:+UseConcMarkSweepGC -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:/usr/local/apache-tomcat-9.0.35/logs/cms-gc.log"
#CATALINA_OPTS="-XX:+UseG1GC -Xlog:gc*=debug:file=/usr/local/apache-tomcat-9.0.35/logs/g1-gc.log"
#CATALINA_OPTS="-XX:+UseZGC -Xlog:gc*=debug:file=/usr/local/apache-tomcat-9.0.35/logs/z-gc.log"
#JDK_JAVA_OPTIONS="--add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED"
</code></pre>

<p>取消对应行的注释去试验对应的收集器，可以考虑使用 ab 之类压测工具观察性能变化，<a href="gceasy.io">gceasy</a> 可以用来辅助分析 gc 日志。</p>

<h2>Reference</h2>

<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></li>
<li>深入理解 java 虚拟机</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MyBatis 的工作流程(一)]]></title>
    <link href="http://DamianSheldon.github.io/blog/mybatis-workflow.html"/>
    <updated>2022-10-11T16:06:03+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/mybatis-workflow</id>
    <content type="html"><![CDATA[<p>MyBatis 的工作流程主要是以下几步：</p>

<ul>
<li>加载配置并初始化</li>
<li>接收调用请求</li>
<li>处理操作请求</li>
<li>返回处理结果</li>
</ul>


<p>本文我们先具体来看看它与 Spring Boot 集成时的初始化。</p>

<p>MyBatis 官方团队有开发一个 Spring Boot Starter，我们通过它的代码来看下配置加载和初始化。配置的入口是 MybatisAutoConfiguration，它会按需创建 sqlSessionFactory 和 sqlSessionTemplate 这两个 bean 对象，同时它还包含一个内部配置类 MapperScannerRegistrarNotFoundConfiguration:</p>

<pre><code>@org.springframework.context.annotation.Configuration
@Import(AutoConfiguredMapperScannerRegistrar.class)
@ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class })
public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {

  @Override
  public void afterPropertiesSet() {
    logger.debug(
        "Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.");
  }

}
</code></pre>

<p>MapperScannerRegistrarNotFoundConfiguration 导入了 AutoConfiguredMapperScannerRegistrar，它会向 IoC 容器注册 MapperScannerConfigurer。</p>

<!--more-->


<pre><code>/**
 * This will just scan the same base package as Spring Boot does. If you want more power, you can explicitly use
 * {@link org.mybatis.spring.annotation.MapperScan} but this will get typed mappers working correctly, out-of-the-box,
 * similar to using Spring Data JPA repositories.
 */
public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar {

  private BeanFactory beanFactory;

  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

    if (!AutoConfigurationPackages.has(this.beanFactory)) {
      logger.debug("Could not determine auto-configuration package, automatic mapper scanning disabled.");
      return;
    }

    logger.debug("Searching for mappers annotated with @Mapper");

    List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory);
    if (logger.isDebugEnabled()) {
      packages.forEach(pkg -&gt; logger.debug("Using auto-configuration base package '{}'", pkg));
    }

    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
    builder.addPropertyValue("processPropertyPlaceHolders", true);
    builder.addPropertyValue("annotationClass", Mapper.class);
    builder.addPropertyValue("basePackage", StringUtils.collectionToCommaDelimitedString(packages));
    BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
    Set&lt;String&gt; propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    if (propertyNames.contains("lazyInitialization")) {
      // Need to mybatis-spring 2.0.2+
      builder.addPropertyValue("lazyInitialization", "${mybatis.lazy-initialization:false}");
    }
    if (propertyNames.contains("defaultScope")) {
      // Need to mybatis-spring 2.0.6+
      builder.addPropertyValue("defaultScope", "${mybatis.mapper-default-scope:}");
    }
    registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
  }

  @Override
  public void setBeanFactory(BeanFactory beanFactory) {
    this.beanFactory = beanFactory;
  }

}
</code></pre>

<p>MapperScannerConfigurer 是一个 BeanDefinitionRegistryPostProcessor，IoC 会调用它的 postProcessBeanDefinitionRegistry 方法来处理 bean 定义:</p>

<pre><code>/**
 * {@inheritDoc}
 *
 * @since 1.0.2
 */
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
  if (this.processPropertyPlaceHolders) {
    processPropertyPlaceHolders();
  }

  ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
  scanner.setAddToConfig(this.addToConfig);
  scanner.setAnnotationClass(this.annotationClass);
  scanner.setMarkerInterface(this.markerInterface);
  scanner.setSqlSessionFactory(this.sqlSessionFactory);
  scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
  scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
  scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
  scanner.setResourceLoader(this.applicationContext);
  scanner.setBeanNameGenerator(this.nameGenerator);
  scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
  if (StringUtils.hasText(lazyInitialization)) {
    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
  }
  if (StringUtils.hasText(defaultScope)) {
    scanner.setDefaultScope(defaultScope);
  }
  scanner.registerFilters();
  scanner.scan(
      StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
}
</code></pre>

<p>从方法中我们可以知道，它使用 ClassPathMapperScanner 来扫描注册 Mapper，ClassPathMapperScanner 覆盖了父类 ClassPathBeanDefinitionScanner 的 doScan 方法：</p>

<pre><code>/**
 * Calls the parent search that will search and register all the candidates. Then the registered objects are post
 * processed to set them as MapperFactoryBeans
 */
@Override
public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);

  if (beanDefinitions.isEmpty()) {
    LOGGER.warn(() -&gt; "No MyBatis mapper was found in '" + Arrays.toString(basePackages)
        + "' package. Please check your configuration.");
  } else {
    processBeanDefinitions(beanDefinitions);
  }

  return beanDefinitions;
}
</code></pre>

<p>它在 processBeanDefinitions 方法中对 bean 定义进行了进一步的处理，把 bean 的 bean class 换成了 MapperFactoryBean，由它来生成创建对应的 Mapper。另外就是设置按类型自动连线 <code>definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</code>，我在跟代码的过程中一开始很奇怪 ClassPathMapperScanner 注册 MapperFactoryBean 的 bean 定义时 sqlSessionTemplate 为 null，那么是在什么时候设置的 sqlSessionTemplate 呢？经过一番代码追踪，发现是 beanDefinition 设置了 AutowireMode，AbstractAutowireCapableBeanFactory 会帮助自动关联。</p>

<pre><code>private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) {
  AbstractBeanDefinition definition;
  BeanDefinitionRegistry registry = getRegistry();
  for (BeanDefinitionHolder holder : beanDefinitions) {
    definition = (AbstractBeanDefinition) holder.getBeanDefinition();
    boolean scopedProxy = false;
    if (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) {
      definition = (AbstractBeanDefinition) Optional
          .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())
          .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; new IllegalStateException(
              "The target bean definition of scoped proxy bean not found. Root bean definition[" + holder + "]"));
      scopedProxy = true;
    }
    String beanClassName = definition.getBeanClassName();
    LOGGER.debug(() -&gt; "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName
        + "' mapperInterface");

    // the mapper interface is the original class of the bean
    // but, the actual class of the bean is MapperFactoryBean
    definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59
    definition.setBeanClass(this.mapperFactoryBeanClass);

    definition.getPropertyValues().add("addToConfig", this.addToConfig);

    // Attribute for MockitoPostProcessor
    // https://github.com/mybatis/spring-boot-starter/issues/475
    definition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, beanClassName);

    boolean explicitFactoryUsed = false;
    if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {
      definition.getPropertyValues().add("sqlSessionFactory",
          new RuntimeBeanReference(this.sqlSessionFactoryBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionFactory != null) {
      definition.getPropertyValues().add("sqlSessionFactory", this.sqlSessionFactory);
      explicitFactoryUsed = true;
    }

    if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {
      if (explicitFactoryUsed) {
        LOGGER.warn(
            () -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.");
      }
      definition.getPropertyValues().add("sqlSessionTemplate",
          new RuntimeBeanReference(this.sqlSessionTemplateBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionTemplate != null) {
      if (explicitFactoryUsed) {
        LOGGER.warn(
            () -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.");
      }
      definition.getPropertyValues().add("sqlSessionTemplate", this.sqlSessionTemplate);
      explicitFactoryUsed = true;
    }

    if (!explicitFactoryUsed) {
      LOGGER.debug(() -&gt; "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'.");
      definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
    }

    definition.setLazyInit(lazyInitialization);

    if (scopedProxy) {
      continue;
    }

    if (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != null) {
      definition.setScope(defaultScope);
    }

    if (!definition.isSingleton()) {
      BeanDefinitionHolder proxyHolder = ScopedProxyUtils.createScopedProxy(holder, registry, true);
      if (registry.containsBeanDefinition(proxyHolder.getBeanName())) {
        registry.removeBeanDefinition(proxyHolder.getBeanName());
      }
      registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());
    }

  }
}
</code></pre>

<p>MapperFactoryBean 的 getObject 方法如下，它使用上文所述，容器中的 sqlSession bean 来创建 mapper，通常也就是 MybatisAutoConfiguration 定义的 sqlSession bean。</p>

<pre><code>public T getObject() throws Exception {
  return getSqlSession().getMapper(this.mapperInterface);
}
</code></pre>

<p>MybatisAutoConfiguration 是定义 sqlSession bean 的代码如下：</p>

<pre><code>@Bean
@ConditionalOnMissingBean
public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
  ExecutorType executorType = this.properties.getExecutorType();
  if (executorType != null) {
    return new SqlSessionTemplate(sqlSessionFactory, executorType);
  } else {
    return new SqlSessionTemplate(sqlSessionFactory);
  }
}
</code></pre>

<p>它依赖的 SqlSessionFactory MybatisAutoConfiguration 也有定义:</p>

<pre><code>@Bean
@ConditionalOnMissingBean
public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
  SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
  factory.setDataSource(dataSource);
  factory.setVfs(SpringBootVFS.class);
  if (StringUtils.hasText(this.properties.getConfigLocation())) {
    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
  }
  applyConfiguration(factory);
  if (this.properties.getConfigurationProperties() != null) {
    factory.setConfigurationProperties(this.properties.getConfigurationProperties());
  }
  if (!ObjectUtils.isEmpty(this.interceptors)) {
    factory.setPlugins(this.interceptors);
  }
  if (this.databaseIdProvider != null) {
    factory.setDatabaseIdProvider(this.databaseIdProvider);
  }
  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
  }
  if (this.properties.getTypeAliasesSuperType() != null) {
    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
  }
  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
  }
  if (!ObjectUtils.isEmpty(this.typeHandlers)) {
    factory.setTypeHandlers(this.typeHandlers);
  }
  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
    factory.setMapperLocations(this.properties.resolveMapperLocations());
  }
  Set&lt;String&gt; factoryPropertyNames = Stream
      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
      .collect(Collectors.toSet());
  Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
  if (factoryPropertyNames.contains("scriptingLanguageDrivers") &amp;&amp; !ObjectUtils.isEmpty(this.languageDrivers)) {
    // Need to mybatis-spring 2.0.2+
    factory.setScriptingLanguageDrivers(this.languageDrivers);
    if (defaultLanguageDriver == null &amp;&amp; this.languageDrivers.length == 1) {
      defaultLanguageDriver = this.languageDrivers[0].getClass();
    }
  }
  if (factoryPropertyNames.contains("defaultScriptingLanguageDriver")) {
    // Need to mybatis-spring 2.0.2+
    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
  }

  return factory.getObject();
}

private void applyConfiguration(SqlSessionFactoryBean factory) {
  Configuration configuration = this.properties.getConfiguration();
  if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) {
    configuration = new Configuration();
  }
  if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) {
    for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
      customizer.customize(configuration);
    }
  }
  factory.setConfiguration(configuration);
}
</code></pre>

<p>SqlSessionTemplate 是一个代理对象，它的功能依赖 SqlSessionFactory，它的 getMapper 方法如下：</p>

<pre><code>@Override
public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
  return getConfiguration().getMapper(type, this);
}
</code></pre>

<p>实现依赖 getConfiguration, 它的内容如下：</p>

<pre><code>@Override
public Configuration getConfiguration() {
  return this.sqlSessionFactory.getConfiguration();
}
</code></pre>

<p>Configuration 就是使用的 sqlSessionFactory 的配置对象。</p>

<p>现在我们聚焦到 SqlSessionFactory 的 Configuration 对象是怎么来的。 SqlSessionFactory 是由 SqlSessionFactoryBean，MybatisAutoConfiguration 有为它设置一个 Configuration :</p>

<pre><code>private void applyConfiguration(SqlSessionFactoryBean factory) {
  Configuration configuration = this.properties.getConfiguration();
  if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) {
    configuration = new Configuration();
  }
  if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) {
    for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
      customizer.customize(configuration);
    }
  }
  factory.setConfiguration(configuration);
}
</code></pre>

<p>那么最终的 Configuration 就是这个外部设置的对象吗？我们继续看它的 getObject 方法:</p>

<pre><code>@Override
public SqlSessionFactory getObject() throws Exception {
  if (this.sqlSessionFactory == null) {
    afterPropertiesSet();
  }

  return this.sqlSessionFactory;
}
</code></pre>

<p>再看下它的 afterPropertiesSet 方法：</p>

<pre><code>public void afterPropertiesSet() throws Exception {
  notNull(dataSource, "Property 'dataSource' is required");
  notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
  state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),
      "Property 'configuration' and 'configLocation' can not specified with together");

  this.sqlSessionFactory = buildSqlSessionFactory();
}
</code></pre>

<p>是在 buildSqlSessionFactory 方法中创建的 sqlSessionFactory:</p>

<pre><code>
/**
 * Build a {@code SqlSessionFactory} instance.
 *
 * The default implementation uses the standard MyBatis {@code XMLConfigBuilder} API to build a
 * {@code SqlSessionFactory} instance based on a Reader. Since 1.3.0, it can be specified a {@link Configuration}
 * instance directly(without config file).
 *
 * @return SqlSessionFactory
 * @throws Exception
 *           if configuration is failed
 */
protected SqlSessionFactory buildSqlSessionFactory() throws Exception {

  final Configuration targetConfiguration;

  XMLConfigBuilder xmlConfigBuilder = null;
  if (this.configuration != null) {
    targetConfiguration = this.configuration;
    if (targetConfiguration.getVariables() == null) {
      targetConfiguration.setVariables(this.configurationProperties);
    } else if (this.configurationProperties != null) {
      targetConfiguration.getVariables().putAll(this.configurationProperties);
    }
  } else if (this.configLocation != null) {
    xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);
    targetConfiguration = xmlConfigBuilder.getConfiguration();
  } else {
    LOGGER.debug(
        () -&gt; "Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration");
    targetConfiguration = new Configuration();
    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);
  }

  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);
  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);
  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);

  if (hasLength(this.typeAliasesPackage)) {
    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()
        .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())
        .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);
  }

  if (!isEmpty(this.typeAliases)) {
    Stream.of(this.typeAliases).forEach(typeAlias -&gt; {
      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);
      LOGGER.debug(() -&gt; "Registered type alias: '" + typeAlias + "'");
    });
  }

  if (!isEmpty(this.plugins)) {
    Stream.of(this.plugins).forEach(plugin -&gt; {
      targetConfiguration.addInterceptor(plugin);
      LOGGER.debug(() -&gt; "Registered plugin: '" + plugin + "'");
    });
  }

  if (hasLength(this.typeHandlersPackage)) {
    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())
        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))
        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);
  }

  if (!isEmpty(this.typeHandlers)) {
    Stream.of(this.typeHandlers).forEach(typeHandler -&gt; {
      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);
      LOGGER.debug(() -&gt; "Registered type handler: '" + typeHandler + "'");
    });
  }

  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);

  if (!isEmpty(this.scriptingLanguageDrivers)) {
    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; {
      targetConfiguration.getLanguageRegistry().register(languageDriver);
      LOGGER.debug(() -&gt; "Registered scripting language driver: '" + languageDriver + "'");
    });
  }
  Optional.ofNullable(this.defaultScriptingLanguageDriver)
      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);

  if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls
    try {
      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));
    } catch (SQLException e) {
      throw new NestedIOException("Failed getting a databaseId", e);
    }
  }

  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);

  if (xmlConfigBuilder != null) {
    try {
      xmlConfigBuilder.parse();
      LOGGER.debug(() -&gt; "Parsed configuration file: '" + this.configLocation + "'");
    } catch (Exception ex) {
      throw new NestedIOException("Failed to parse config resource: " + this.configLocation, ex);
    } finally {
      ErrorContext.instance().reset();
    }
  }

  targetConfiguration.setEnvironment(new Environment(this.environment,
      this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,
      this.dataSource));

  if (this.mapperLocations != null) {
    if (this.mapperLocations.length == 0) {
      LOGGER.warn(() -&gt; "Property 'mapperLocations' was specified but matching resources are not found.");
    } else {
      for (Resource mapperLocation : this.mapperLocations) {
        if (mapperLocation == null) {
          continue;
        }
        try {
          XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),
              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());
          xmlMapperBuilder.parse();
        } catch (Exception e) {
          throw new NestedIOException("Failed to parse mapping resource: '" + mapperLocation + "'", e);
        } finally {
          ErrorContext.instance().reset();
        }
        LOGGER.debug(() -&gt; "Parsed mapper file: '" + mapperLocation + "'");
      }
    }
  } else {
    LOGGER.debug(() -&gt; "Property 'mapperLocations' was not specified.");
  }

  return this.sqlSessionFactoryBuilder.build(targetConfiguration);
}
</code></pre>

<p>从这段代码可知，由于 MybatisAutoConfiguration 有设置一个 Configuration ，所以 SqlSessionFactoryBean 使用的就是设置的这个 Configuration。</p>

<p>sqlSessionFactoryBuilder 默认是 SqlSessionFactoryBuilder，它的赋值代码为：</p>

<pre><code>private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
</code></pre>

<p>它的 build 方法实现为:</p>

<pre><code>public SqlSessionFactory build(Configuration config) {
  return new DefaultSqlSessionFactory(config);
}
</code></pre>

<p>因此创建的是 DefaultSqlSessionFactory 对象。</p>

<p>现在 SqlSessionFactory, SqlSession, Configuration 的实现来源都清楚了，我们继续来看创建 mapper 的代码，看 mapper 的实现是什么？</p>

<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre>

<p>mapperRegistry 的实现是 MapperRegistry，它的 getMapper 方法如下：</p>

<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
  }
  try {
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException("Error getting mapper instance. Cause: " + e, e);
  }
}
</code></pre>

<p>它是从 knownMappers 取出类型对应的 MapperProxyFactory，那么它是何时如何注册的呢？</p>

<p>前面我们说过， Mapper 对应向 IoC 注册的的 bean 定义是 MapperFactoryBean 对象，MapperFactory 继承自 SqlSessionDaoSupport，而 SqlSessionDaoSupport 继承自 DaoSupport，DaoSupport 实现 InitializingBean 接口，所以在实例化 mapper 时会实例化出 MapperFactory，并先调用它的 afterPropertiesSet 方法：</p>

<pre><code>@Override
public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
    // Let abstract subclasses check their configuration.
    checkDaoConfig();

    // Let concrete implementations initialize themselves.
    try {
        initDao();
    }
    catch (Exception ex) {
        throw new BeanInitializationException("Initialization of DAO failed", ex);
    }
}
</code></pre>

<p>MapperFactory 覆盖了 checkDaoConfig 方法:</p>

<pre><code>protected void checkDaoConfig() {
  super.checkDaoConfig();

  notNull(this.mapperInterface, "Property 'mapperInterface' is required");

  Configuration configuration = getSqlSession().getConfiguration();
  if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) {
    try {
      configuration.addMapper(this.mapperInterface);
    } catch (Exception e) {
      logger.error("Error while adding the mapper '" + this.mapperInterface + "' to configuration.", e);
      throw new IllegalArgumentException(e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
}
</code></pre>

<p>也就是在这个方法中向 Configuration 添加了 mapper 对应的 MapperProxyFactory 类型:</p>

<pre><code>public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
  mapperRegistry.addMapper(type);
}

public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
  if (type.isInterface()) {
    if (hasMapper(type)) {
      throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
    }
    boolean loadCompleted = false;
    try {
      knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));
      // It's important that the type is added before the parser is run
      // otherwise the binding may automatically be attempted by the
      // mapper parser. If the type is already known, it won't try.
      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
      parser.parse();
      loadCompleted = true;
    } finally {
      if (!loadCompleted) {
        knownMappers.remove(type);
      }
    }
  }
}
</code></pre>

<p>从上述代码可以看出 mapper 对应的 MapperProxyFactory 类型是用定义的 mapper 接口类型参数化的 MapperProxyFactory，它的 <code>newInstance(SqlSession sqlSession)</code> 方法如下：</p>

<pre><code>public T newInstance(SqlSession sqlSession) {
  final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
</code></pre>

<p>最后为 mapper 接口创建向 mapperProxy 实例转发调用的代理对象。</p>

<pre><code>protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
</code></pre>

<p>也就是说，mapper 接口类型对象等效于一个 MapperProxy 对象。至此，MyBatis 的初始化过程就梳理清楚了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring MVC 中的异常处理]]></title>
    <link href="http://DamianSheldon.github.io/blog/exception-handling-in-spring-mvc.html"/>
    <updated>2022-09-30T10:06:54+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/exception-handling-in-spring-mvc</id>
    <content type="html"><![CDATA[<p>使用 Spring 来开发 web 应用时很有必要建立一个统一的异常处理体系。想要建立这个体系，我们先要搞清楚 Spring MVC 中的异常处理机制。 Spring MVC 是基于 Servlet，所以它遵循 Servlet 规范。</p>

<p>Servlet 规范中有详细的错误处理说明，简单来说就是 Servlet 在处理请求时可能会抛出异常或者调用 <code>sendError</code> ，这时 Servlet-Container 就要产生相应的错误界面，错误界面是允许自定义的。Spring MVC 的核心之一是 DispatchServlet，它是一个前端控制器，所有的请求处理都由它来驱动，从名字可以看出，它也是一个 Servlet，所以它的错误处理机制自然要遵循 Servlet 规范。从完整性的角度来看，还一种错误处理方法，Servlet 可以自己设置 HTTP 的 status code 和 body，也就是不和 Servlet-Container 联动来处理错误，而是完全自主地处理。</p>

<p>我们先来看 DispatcherServlet 的异常处理机制，Spring 团队将异常处理功能集中到 HandlerExceptionResolver 接口的实现类中，DispatcherServlet 在初始化过程会把 IoC 容器中所有的 HandlerExceptionResolver 的实现类排好序后组装起来用于异常处理。</p>

<p>现在我们使用 Spring 来开发 web 应用时应该都会选择 Spring Boot 来配置 Spring，和异常相关的自动配置类为 ErrorMvcAutoConfiguration 和 WebMvcAutoConfiguration， 它们默认配置两个 HandlerExceptionResolver: DefaultErrorAttributes 和 HandleExceptionResolverComposite。</p>

<p>HandleExceptionResolverComposite 默认包含以下三个 HandlerExceptionResolver:</p>

<blockquote><ul>
<li>ExceptionHandlerExceptionResolver matches uncaught exceptions against suitable @ExceptionHandler methods on both the handler (controller) and on any controller-advices.</li>
<li>ResponseStatusExceptionResolver looks for uncaught exceptions annotated by @ResponseStatus (as described in Section 1)</li>
<li>DefaultHandlerExceptionResolver converts standard Spring exceptions and converts them to HTTP Status Codes (I have not mentioned this above as it is internal to Spring MVC).</li>
</ul>
</blockquote>

<p>Spring 官方博客帮我们总结了 Spring Boot 默认配置的异常处理流程：</p>

<blockquote><ol>
<li>In the event of any unhanded error, Spring Boot forwards internally to /error.</li>
<li>Boot sets up a BasicErrorController to handle any request to /error. The controller adds error information to the internal Model and returns error as the logical view name.</li>
<li>If any view-resolver(s) are configured, they will try to use a corresponding error-view.</li>
<li>Otherwise, a default error page is provided using a dedicated View object (making it independent of any view-resolution system you may be using).</li>
<li>Spring Boot sets up a BeanNameViewResolver so that /error can be mapped to a View of the same name.</li>
<li>If you look in Boot’s ErrorMvcAutoConfiguration class you will see that the defaultErrorView is returned as a bean called error. This is the View bean found by the BeanNameViewResolver.</li>
</ol>
</blockquote>

<p>对于 Servlet-Container 层面的错误处理，Spring 官方博客的介绍如下：</p>

<blockquote><p>Container-Wide Exception Handling</p>

<p>Exceptions thrown outside the Spring Framework, such as from a servlet Filter, are also reported by Spring Boot’s fallback error page.
To do this Spring Boot has to register a default error page for the container. In Servlet 2, there is an <code>&lt;error-page&gt;</code> directive that you can add to your web.xml to do this. Sadly Servlet 3 does not offer a Java API equivalent. Instead Spring Boot does the following:</p>

<ul>
<li>For a Jar application, with an embedded container, it registers a default error page using Container specific API.</li>
<li>For a Spring Boot application deployed as a traditional WAR file, a Servlet Filter is used to catch exceptions raised further down the line and handle it.</li>
</ul>
</blockquote>

<p>我们可以按照上述线索在 Spring Boot 的自动配置代码中找到相关的代码。</p>

<p>当开发 REST API 项目时，我希望业务抛出的异常能契合 Spring Boot 默认配置的异常处理机制，让整个异常体系尽量统一，接口返回给终端统一格式的错误信息，这样终端也能统一处理接口错误。那么我们应该如何做？</p>

<p>我们这里需要的是一个全局的异常处理机制，Spring MVC 提供给我们两种配置全局异常处理的方法：</p>

<ul>
<li>配置 HandlerExceptionResolver</li>
<li>使用 <code>@ControllerAdvice</code> 注解的类</li>
</ul>


<p>相比之下，个人觉得使用 <code>@ControllerAdvice</code> 注解的类会方便一些，能达到感知框架的存在。我们可以定义一个异常处理基类，发布成一个库，然后在需要用到的项目中引入这个库，在项目中继承该基类定义一个 <code>@ControllerAdvice</code> 注解的异常处理类。</p>

<p>选好全局异常处理机制后，那么我们应该如何来设计项目的业务异常类呢?</p>

<p>Spring 官方博客给出了如下建议:</p>

<blockquote><p>As usual, Spring likes to offer you choice, so what should you do? Here are some rules of thumb. However if you have a preference for XML configuration or Annotations, that’s fine too.</p>

<ul>
<li>For exceptions you write, consider adding @ResponseStatus to them.</li>
<li>For all other exceptions implement an @ExceptionHandler method on a @ControllerAdvice class or use an instance of SimpleMappingExceptionResolver. You may well have SimpleMappingExceptionResolver configured for your application already, in which case it may be easier to add new exception classes to it than implement a @ControllerAdvice.</li>
<li>For Controller specific exception handling add @ExceptionHandler methods to your controller.</li>
<li>Warning: Be careful mixing too many of these options in the same application. If the same exception can be handed in more than one way, you may not get the behavior you wanted. @ExceptionHandler methods on the Controller are always selected before those on any @ControllerAdvice instance. It is undefined what order controller-advices are processed.</li>
</ul>
</blockquote>

<!--more-->


<p>这里我们重点来看第一条建议，他建议我们自己写的异常类可以考虑加上 <code>@ResponseStatus</code> 注解，这样 service 就可以往上层传递 HTTP 的 status 信息，然后可以根据异常的类型填充 body 信息。这样做当然可以，只是这样一来异常类数量容易膨胀，定义异常类也是很乏味。我觉得可以定义一个能表达 HTTP status, headers 和 body 信息的类，然后抛出它的实例，他的建议作为补充。</p>

<p>设计好异常类层级后，接口出错时应该返回些什么信息给终端？</p>

<p>《Web API 的设计与开发》作者建议的单个和多个错误信息如下：</p>

<pre><code>// 单个
{
  "error": {
      "code": 2013,
      "message": "Bad authentication token",
      "info": "http://docs.example.com/api/v1/authentication"
  }
}
// 多个
{
  "errors": [
      {
          "code": 2013,
          "message": "Bad authentication token",
          "info": "http://docs.example.com/api/v1/authentication"
      }
  ]
}
</code></pre>

<p>同样，我还是希望业务异常产生的错误信息能够兼容 Spring Boot 默认产生的错误信息，这样终端可以统一处理错误信息。Spring Boot 默认产生的错误信息包含如下字段：</p>

<pre><code>timestamp - The time that the errors were extracted
status - The status code
error - The error reason
exception - The class name of the root exception (if configured)
message - The exception message (if configured)
errors - Any ObjectErrors from a BindingResult exception (if configured)
trace - The exception stack trace (if configured)
path - The URL path when the exception was raised
</code></pre>

<p>综上所述，我们可以定义 REST API 的错误信息为 RestErrorInfo:</p>

<pre><code>public class RestErrorInfo {
    private Integer code;

    private String message;

    private String info;

    // 省略的 Constructor, Getter and Setter
}
</code></pre>

<p>异常类 ServiceException 为：</p>

<pre><code>package com.github.damiansheldon.exception;

import org.springframework.core.NestedRuntimeException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;

public class ServiceException extends NestedRuntimeException {

    private HttpStatus status;

    private HttpHeaders headers;

    private RestErrorInfo errorInfo;

    private ServiceException(Builder builder) {
        super(builder.errorInfo.getMessage(), builder.cause);
        this.errorInfo = builder.errorInfo;
    }

    public HttpStatus getStatus() {
        return status;
    }

    public HttpHeaders getHeaders() {
        return headers;
    }

    public RestErrorInfo getErrorInfo() {
        return errorInfo;
    }

    public static class Builder {
        private HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        private HttpHeaders headers;
        private RestErrorInfo errorInfo;
        private Throwable cause;

        public Builder(RestErrorInfo errorInfo) {
            this.errorInfo = errorInfo;
        }

        public Builder status(HttpStatus status) {
            this.status = status;
            return this;
        }

        public Builder headers(HttpHeaders headers) {
            this.headers = headers;
            return this;
        }

        public Builder cause(Throwable cause) {
            this.cause = cause;
            return this;
        }

        public ServiceException build() {
            return new ServiceException(this);
        }

    }

}
</code></pre>

<p>异常处理类为：</p>

<pre><code>package com.github.damiansheldon.exception;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.Nullable;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.util.WebUtils;

public class ServiceExceptionHandler {

    @ExceptionHandler({ServiceException.class})
    public final ResponseEntity&lt;Object&gt; handleServiceException(ServiceException ex, WebRequest request) {
        return handleExceptionInternal(ex, ex.getErrorInfo(), ex.getHeaders(), ex.getStatus(), request);
    }

    protected ResponseEntity&lt;Object&gt; handleExceptionInternal(
            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request) {

        if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {
            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);
        }
        return new ResponseEntity&lt;&gt;(body, headers, status);
    }
}
</code></pre>

<p>完整代码在<a href="https://github.com/DamianSheldon/Treasure">这里</a>。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc">Exception Handling in Spring MVC</a></li>
<li><a href="https://javaee.github.io/servlet-spec/downloads/servlet-3.1/Final/servlet-3_1-final.pdf">Java™ Servlet Specification</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 开发问题汇总(五)]]></title>
    <link href="http://DamianSheldon.github.io/blog/web-development-notes-part-five.html"/>
    <updated>2022-07-01T09:32:39+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/web-development-notes-part-five</id>
    <content type="html"><![CDATA[<h3>1.</h3>

<pre><code>$ jmap -heap 29104
Attaching to process ID 29104, please wait...
ERROR: attach: task_for_pid(29104) failed: '(os/kern) failure' (5)
Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process. Could be caused by an incorrect pid or lack of privileges.
sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process. Could be caused by an incorrect pid or lack of privileges.
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$BsdDebuggerLocalWorkerThread.execute(BsdDebuggerLocal.java:169)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.attach(BsdDebuggerLocal.java:287)
    at sun.jvm.hotspot.HotSpotAgent.attachDebugger(HotSpotAgent.java:671)
    at sun.jvm.hotspot.HotSpotAgent.setupDebuggerDarwin(HotSpotAgent.java:659)
    at sun.jvm.hotspot.HotSpotAgent.setupDebugger(HotSpotAgent.java:341)
    at sun.jvm.hotspot.HotSpotAgent.go(HotSpotAgent.java:304)
    at sun.jvm.hotspot.HotSpotAgent.attach(HotSpotAgent.java:140)
    at sun.jvm.hotspot.tools.Tool.start(Tool.java:185)
    at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)
    at sun.jvm.hotspot.tools.HeapSummary.main(HeapSummary.java:49)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at sun.tools.jmap.JMap.runTool(JMap.java:201)
    at sun.tools.jmap.JMap.main(JMap.java:130)
Caused by: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process. Could be caused by an incorrect pid or lack of privileges.
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.attach0(Native Method)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.access$100(BsdDebuggerLocal.java:65)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$1AttachTask.doit(BsdDebuggerLocal.java:278)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$BsdDebuggerLocalWorkerThread.run(BsdDebuggerLocal.java:144)
</code></pre>

<p>A: macOS 上的 java 虚拟机基础工具不能附加到 java 进程上，操作系统环境为:</p>

<pre><code>$ sw_vers
ProductName:    Mac OS X
ProductVersion: 10.15.7
BuildVersion:   19H1922
</code></pre>

<p>java 版本:</p>

<pre><code>$ java -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
</code></pre>

<p>google 了一番之后，问题可能是 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8160376">macOS 上的 java 8 部分小版本有问题</a>，于是我打算用虚拟机里面的 RockyLinux 来试下，结果是确定可以。</p>

<!--more-->


<p>这中间还一个小插曲，也很有意思，这里记一下。虚拟机里面的 RockyLinux 之前并没有安装 java 开发环境，于是我就下载安装 eclipse，2022-06 版本的 eclipse 默认要求 <code>java 11+</code> 的运行环境，它默认选择安装的是 java 17，这也确定是一个好选择，一是 ZGC 是从 java 15 开始 Production Ready；二是 java 17 是一个长期支持版本。</p>

<blockquote><p>ZGC was initially introduced as an experimental feature in JDK 11, and was declared Production Ready in JDK 15.</p></blockquote>

<p>RockyLinux 自带的是 java 8，于是我们安装 jdk 8 和 jdk 17，然后使用自带的 alternatives 来切换 java 版本，但是它好像只管理 jre bin 下的命令，并有把 jdk 里面的命令都管理起来。我是使用 jinfo 提示报错发现的:</p>

<pre><code>Type "GenericGrowableArray", referenced in VMStructs::localHotSpotVMStructs in the remote VM, was not present in the remote VMStructs::localHotSpotVMTypes table (should have been caught in the debug build of that VM). Can not continue.
</code></pre>

<p>可以使用 <code>alternatives --display java</code> 去确定一下，从这里也可以看出工具的版本最好对应，所以我们也可以将它们纳入 alternatives 系统来管理。以 jhsdb 为例:</p>

<pre><code>sudo alternatives --add-slave java /usr/lib/jvm/java-17-openjdk-17.0.3.0.7-2.el8_6.x86_64/bin/java /usr/bin/jhsdb jhsdb /usr/lib/jvm/java-17-openjdk-17.0.3.0.7-2.el8_6.x86_64/bin/jhsdb
</code></pre>

<p>虚拟机里面做开发还是有点卡，最后还是决定在 mac 上安装多个版本的 java，macOS 上并没有自带 centOS 上 alternatives 类似的命令，需要安装第三方软件来管理，之前在 Spring 的源码里看到它是用 SDkMan 来管理多个版本的 java，所以也决定用 SDKMan 来管理。但是 SDKMan 和 alternatives 的实现方式有很大差别，它默认是将软件安装在用户目录下的隐藏目录下，这对 eclipse 之类 IDE 来配置相关的类库会稍微有点不方便，需要开启 Finder 的隐藏文件显示，快捷命令是 <code>cmd+shift+.</code>，<code>defaults write com.apple.Finder AppleShowAllFiles true</code> 命令暂时没生效。</p>

<p>Reference:</p>

<ul>
<li><a href="https://blog.csdn.net/Dongguabai/article/details/88736589">Mac 使用 jinfo 出现：Can&rsquo;t attach to the process. Could be caused by an incorrect pid or lack of privileg</a></li>
<li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8160376">JDK-8160376 : DebuggerException: Can&rsquo;t attach symbolicator to the process</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 面试题]]></title>
    <link href="http://DamianSheldon.github.io/blog/redis-interview-questions.html"/>
    <updated>2022-04-27T14:36:10+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/redis-interview-questions</id>
    <content type="html"><![CDATA[<h2>1.什么是 Redis?</h2>

<blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store used as a database, cache, message broker, and streaming engine.</p></blockquote>

<p>Redis是一个开源的内存数据结构存储，被用作数据库、缓存、消息代理和流媒体引擎。</p>

<h2>2.Redis的内存占用量是多少？</h2>

<p>我们看几个例子（都是使用64位实例得到的。</p>

<ul>
<li>一个空的实例使用~3MB的内存。</li>
<li>100万个小键->字符串值对使用~85MB的内存。</li>
<li>100万个键->哈希值，代表一个有5个字段的对象，使用~160 MB的内存。</li>
</ul>


<h2>3.为什么Redis将其整个数据集保存在内存中？</h2>

<p>在过去，Redis的开发者尝试了虚拟内存和其他系统来允许大于RAM的数据集，但最终我们很高兴能做好一件事：数据从内存中提供，磁盘用于存储。所以现在还没有计划为Redis创建一个磁盘上的后端。Redis是当前设计的结果。</p>

<h2>4.你能将Redis与基于磁盘的数据库一起使用吗？</h2>

<p>可以，一个常见的设计模式是在Redis中保存频繁写的小数据（以及你需要Redis数据结构以有效方式为你的问题建模的数据），而大块的数据保存到 SQL或最终一致的磁盘数据库。同样，有时Redis被用来在内存中获取存储在磁盘数据库中的相同数据子集的另一个副本。这看起来类似于缓存，但实际上是一个更高级的模型，因为通常Redis数据集与磁盘数据库数据集一起更新，而不是在缓存错过时刷新。</p>

<h2>5.如何减少Redis的整体内存用量？</h2>

<p>如果可以的话，使用Redis的32位实例。同时善用小的哈希值、列表、排序集和整数集，因为Redis能够在少数元素的特殊情况下以更紧凑的方式表示这些数据类型。</p>

<h2>6.如果Redis的内存用完了会怎样？</h2>

<p>Redis有内置的保护措施，允许用户设置内存使用的最大限制，使用配置文件中的maxmemory选项，对Redis可以使用的内存进行限制。如果达到这个限制，Redis将开始对写命令回复错误（但会继续接受只读命令）。</p>

<p>你也可以配置Redis在达到最大内存限制时驱逐键值。</p>

<!--more-->


<h2>7.Redis的磁盘快照是原子的吗？</h2>

<p>是的，Redis的后台保存过程总是在服务器没有执行命令时创建，所以每个在RAM中报告为原子的命令从磁盘快照的角度看也是原子的。</p>

<h2>8.Redis如何使用多个CPU或核心？</h2>

<p>CPU成为你使用Redis的瓶颈并不是很常见，因为通常Redis的问题不是内存就是网络带宽。例如，当使用 piplelining 时，在一个普通的Linux系统上运行的Redis实例每秒可以提供100万个请求，所以如果你的应用程序主要使用O(N)或O(log(N))命令，它几乎不会使用太多的CPU。</p>

<p>然而，为了最大限度地提高CPU的使用率，你可以在同一个机器里启动多个Redis的实例，并把它们当作不同的服务器。在某些时候，一个机器可能无论如何也不够用，所以如果你想使用多个CPU，你可以提前开始考虑一些方法来分片。</p>

<h2>9.一个Redis实例能容纳的最大键数是多少？Hash、List、Set和Sorted Set中元素的最大数量是多少？</h2>

<p>Redis最多可以处理<code>2^32</code>个键，经实践测试，每个实例至少可以处理2.5亿个键。</p>

<p>每个哈希、列表、集合和排序集，都可以容纳<code>2^32</code>个元素。</p>

<p>换句话说，你的极限可能是你系统中的可用内存。</p>

<h2>10.为什么我的复制节点与主实例的键数量不同？</h2>

<p>如果你使用有效期有限的键（Redis过期），这是正常行为。下面是问题的原因：</p>

<ul>
<li>主节点在与复制节点的第一次同步中生成一个RDB文件。</li>
<li>RDB文件将不包括在主服务器中已经过期但仍在内存中的密钥。</li>
<li>这些键仍然在Redis主节点的内存中，即使在逻辑上已经过期。它们将被认为是不存在的，它们的内存将在以后被回收，要么是增量的，要么是访问时明确的。虽然这些键在逻辑上不是数据集的一部分，但它们在INFO输出和DBSIZE命令中被计算在内。</li>
<li>当复制节点读取由主文件生成的RDB文件时，这组键将不会被加载。</li>
</ul>


<p>正因为如此，对于有很多过期键的用户来说，在复制节点中看到较少的键是很常见的。然而，从逻辑上讲，主节点和复制节点将有相同的内容。</p>

<h2>11.Redis 哨兵和集群的区别是什么？</h2>

<blockquote><p>Redis Sentinel provides high availability for Redis when not using Redis Cluster.
Redis scales horizontally with a deployment topology called Redis Cluster.</p></blockquote>

<h2>12.Memcache 与 Redis 的区别都有哪些？</h2>

<ul>
<li>Command-Line</li>
<li>Disk I/O Dumping</li>
<li>Data Structures</li>
<li>Replication</li>
<li>Transactions</li>
<li>Publish and Subscribe Messaging</li>
<li>Geospatial Support</li>
<li>Architecture</li>
<li>LUA Scripting</li>
<li><p>Memory Usage</p></li>
<li><p><a href="https://www.baeldung.com/memcached-vs-redis">Memcached vs Redis</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
