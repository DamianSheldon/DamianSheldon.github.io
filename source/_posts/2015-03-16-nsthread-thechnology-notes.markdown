---
layout: post
title: "iOS 并发编程之 Thread"
date: 2015-03-16 16:27:17 +0800
comments: true
categories: [Archives, iOS Development]
keywords: NSThread, NSRunLoop, Concurrent programming
discription: NSThread technology notes
---

在 iOS 并发编程之 Operation 中，我们说过 GCD 是将线程管理的代码从应用层移到了系统层，它是基于线程技术的。虽然在 iOS 和 OS X 平台不鼓励直接使用线程实现并发，但它还是有它的应用场景。那么什么时候应该使用线程呢？

当我们的代码实时运行时用线程实现是一个好方法。虽然分发队列会尽可能快的执行你的任务，但是它们不能解决实时约束。如果你想让运行在后台的代码给你更可预期的行为，线程是一个更好的选择。

既然线程仍然有它的应用场景，我们还是有必要掌握它。

##Thread是什么

线程是一种在应用中实现多条运行路径相对轻量的方法。在系统层，程序并排运行，系统根据其需要和其他程序的需要为每个程序分配执行时间。但是在每个程序内部存在一个或多个线程运行，它们可以被用来以同时或接近同时的方式执行不同的任务。系统本身实际上管理这些线程的运行，调度它们运行在可用的核上，根据需要中断它们以允许其他线程运行。

从技术角度看, 线程是管理代码执行所需的内核级和应用程序级数据结构的组合。内核级结构将事件分派到线程, 并在一个可用内核上协调线程的抢先调度。应用程序级结构包括用于存储函数调用的调用堆栈和需要管理和操作线程的属性和状态的应用程序结构。

在非并发应用中只有一个运行线程。它在应用的主程序中开始和结束并一个一个地调用不同的方法或函数实现应用的行为。与些相反，支持并发的应用以一个线程开始，根据需要添加创建的附加执行路径。每个新路径有它自定义的开始程序，它和应用的主程序是独立运行的。拥有多线程的应用提供两个重要的潜在优势：

* 多线程可以改善应用的响应性
* 多线程在多核系统上可以改善应用的实时性

如果你的应用只有一个线程，那么它需要做所有的事情。它必须响应事件，更新你应用的窗口和执行实现你应用行为需要的所有计算。单线程的问题在于它一个只有做一件事。当你的某个计算需要花费很长时间完成会发生什么叫？当你的代码忙于计算它需要的值，你的应用停止响应用户的事件和更新窗口。如果这种行为持续足够长的时间，用户也许认为你的应用已经挂起，于是尝试强制退出。但是，如果将自定义计算移到单独的线程上，则应用程序的主线程可以自由地响应用户交互。

在多核计算机如此普遍的今天，线程为某些类型的应用提供了一种提高性能的方法。线程可以在处理器不同的核上同时执行不同的任务，让应用在指定时间增加它工作数量成为了一种可能。

当然，线程并不是解决应用性能问题的万用药。提供好处的同时它也带来各种潜在问题。在应用内拥有多个可执行路径会增加你代码的复杂度。每个线程需要协调它和其他线程的行为以防止损坏应用的状态信息。因为单个应用的线程共享相同的内存空间，它们访问所有相同的数据结构。如果两个线程同时尝试操作相同的数据，一个线程可能覆盖另一个线程的修改，最终导致数据被损坏。即使在这里有了正确防护，你还是要当心编译器优化会在你的代码中引入隐蔽的问题。
<!--more-->
##iOS中如何使用Thread

线程编程肯定会牵涉到线程的管理，线程同步，线程间通信，在 iOS 平台，Apple 还带来了它特有的技术 Run Loop。

###线程的管理
线程管理主要是创建线程，设置线程相关的属性，配置线程的事件响应代码和终止线程。

#### 创建线程
iOS中的Thread技术主要有两种：Cocoa 线程 和 POSIX 线程。

* Cocoa 线程
	
	Cocoa 线程是用 NSThread 实现的，还为 NSObject 提供了生成新线程以及在已经运行的线程上执行代码的方法。所以使用 Cocoa 线程有四种:
	
	* 使用 `detachNewThreadSelector:toTarget:withObject:` 类方法生成新线程。
	* 创建一个新 NSThread 对象，调用它的 `start` 方法。（仅支持 iOS 和 OS X v10.5 及以上）
	* 使用 NSObject 的 `performSelectorInBackground:withObject:` 方法生成新线程并用指定的方法作为新线程的入口。（仅支持 iOS 和 OS X v10.5 及以上）
	* 使用 NSObject 的 `performSelector:onThread:withObject:waitUntilDone:` 几个类似方法在指定线程上执行代码。

	
* POSIX 线程
	
	POSIX 线程提供基于 C 接口来创建线程。如果你不是在编写 Cocoa 应用程序，这是你创建线程最好的选择。POSIX 接口使用相对比较简单并且为你配置线程提供了很大的灵活性。
	
	创建 POSIX 线程的方法名为 `pthread_create`，下面是个示例:
	
```
#include <assert.h>

#include <pthread.h>

void* PosixThreadMainRoutine(void* data)
{
    // Do some work here.
    
    return NULL;
}

void LaunchThread()
{
    // Create the thread using POSIX routines.
    pthread_attr_t  attr;

    pthread_t       posixThreadID;

    int             returnVal;

    returnVal = pthread_attr_init(&attr);
    assert(!returnVal);

    returnVal = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    assert(!returnVal);

    int     threadError = pthread_create(&posixThreadID, &attr, &PosixThreadMainRoutine, NULL);

    returnVal = pthread_attr_destroy(&attr);
    assert(!returnVal);

    if (threadError != 0) {
         // Report an error.
    }
}
```

####设置线程相关的属性
线程的配置项有： 
 
	* 线程的栈大小
	* Thread-Local 存储
	* 线程的 Detached 状态
	* 线程优先级

设置线程的栈大小

对于每个你创建的新线程，系统在你进程空间分配指定大小的内存充当它的栈。栈管理栈帧也是声明局部变量的地方。如果你想改变指定线程栈的大小，你需要在创建它之前就改变。所有的线程技术都提供一些设置栈大小的方法，虽然使用 NSThread 设置大小只在 iOS 和 OS X v10.5 及以上可用。下表列出了每种技术不同的方法。

| 技术 | 方法 |
| --- | ---- |
| Cocoa | 在 iOS 和 OS X v10.5 及以上，分配和初始化一个 NSThread 对象(不要使用 `detachNewThreadSelector:toTarget:withObject:` 方法)。在调用 `start` 方法之前，使用 `setStackSize:`方法来指定新的栈大小。 |
| POSIX | 创建新的 `pthread_attr_t` 并使用 `pthread_attr_setstacksize` 来改变默认的栈大小。当创建线程时传递该属性给 `pthread_create` 函数。 |

配置 Thread-Local 存储

每个线程维护了一个在线程任务地方都可以存取的键-值对字典。你可以使用这个字典存储你在想在你线程整个运行期间持久化的信息。例如，你可以使用它存储那些你想在你线程运行循环多次遍历中保持的状态信息。

Cocoa 和 POSIX 用不同的方法存储线程字典，所以你不能混用这两种技术。只要你在线程代码中坚持使用相同的技术，最终的结果是相似的。在 Cocoa 中，你使用 NSThread 对象的 `threadDictionary` 方法来获取 NSMutableDictionary 对象，你可以使用它来添加你线程需要键。在 POSIX 中，你使用 `pthread_setspecific`和`pthread_getspecific` 函数来存取你线程的键值。

设置线程的 Detached 状态

大多数上层线程技术默认创建 detached 的线程。在大多数情况下，detached 线程是更好的，因为他们允许系统在线程完成时立即释放线程的数据结构。Detached 线程不需要显示地与你的程序交互。从线程获取结果的方法是留给你自己决定。相反地，系统不会回收 joinable 的线程的资源直到其它线程显示地 join 它, 进程可能会阻塞执行 join 的线程。

你可以把 joinable 线程想像成子线程。虽然他们仍然是独立运行的线程，一个 joinable 线程在系统回收资源前必须被另一个线程 join。在退出前，一个 joinable 线程可以传递一个数据指针或其它返回值给 pthread_exit 函数。另一个线程然后可能得到这个数据通过调用 pthread_join 函数。

如果你确实想创建 joinable 线程，唯一的方法是使用 POSIX 线程。POSIX 默认创建的线程就是 joinable 。为了标记线程是 detached 或者 joinable ，在创建线程前使用 `pthread_attr_setdetachstate` 函数修改线程的属性。

设置线程的优先级

任何你新创建的线程都有一个默认的优先级。内核的调度算法在决定哪个线程运行时会把线程的优先级考虑进来，优先级高的比优先级低的更可能运行。优先级并不会保证执行指定时长，仅仅是和低优先级比起来更可能被调度器选中。

如果你想修改线程的优先级，Cocoa 和 POSIX 都提供了方法。对于 Cocoa 线程，你可以使用 NSThread 的类方法 `setThreadPriority:` 来改变当前运行线程的优先级。对于 POSIX 线程，你使用 `pthread_setschedparam` 函数。

####配置线程的事件响应代码
OS X 上你线程入口程序的结构大部分和其他平台是一样的。你初始化你的数据结构，做一些工作或者选择性的设置运行循环，完成时做好清理。依赖你的设计，这里可能有些额外的步骤。

创建自动释放池

因为最上层的自动释放池在线程退出时才释放它持有的对象，长驻线程应用创建额外的自动释放池来更加频繁地释放对象。例如，一个使用运行循环的线程也许在每个循环创建和释放一个自动释放池。更加频繁地释放对象防止你应用的内存增长得太大，那会导致性能问题。和任何性能相关的行为一样，你应该测试你代码的实际性能然后合适地调节你自动释放池的使用。

设置异常处理程序

如果你的应用程序捕获和处理异常，你的线程代码应该准备捕获所有可能发生的异常。虽然最好处理异常最好的地方是它发生的地方，但是漏掉一个异常会导致应用程序退出。在你线程的入口程序中安装一个最终的 try/catch 允许你捕获任何未知的异常和提供合适的响应。

设置运行循环

当你编写想要在单独线程上运行的代码，你有两个选项。第一个选项是为一个很少或不被打断的长时间任务线程编写代码。第二个选项是把你的代码放到一个循环中并且让它处理动态到达的请求。第一个选项你的代码不需要特别的设置；你只需要开始做你想做的工作。但是第二个选项牵涉到设置你线程的运行循环。

OS X 和 iOS 为每个线程实现运行循环提供内建支持。应用程序框架自动开始你应用主线程的运行循环。如果你创建任务其他线程，你必须配置运行循环并手动开始它。

####终止线程

退出线程推荐的方法是让它正常地退出入口程序。虽然 Cocoa， POSIX 提供程序直接杀掉线程，使用这些程序是强烈不推荐的。杀掉线程会妨碍线程清理它自己。线程分配的内存可能会潜在泄露，并且正常使用的资源可能不会被正确的回收，导致潜在的问题。

如果你需要在中途终止线程，你应该设计你的线程可以响应取消和退出消息。对于长时间运行的操作，这可能是周期性的停止工作然后检查有没有这种消息。如果收到请求退出的消息，线程拥有机会执行任务清理工作并优雅地退出；如果没有，它可以返回继续工作并处理后续的数据块。

一种响应取消消息的方法是使用运行循环输入源来接收这样的消息。

###Run Loop

####剖析 Run Loop

运行循环是与线程关联的基本基础结构的一部分。运行循环是一个事件处理循环，用于调度工作并协调传入事件的接收。运行循环的目的是在有工作要做时保持线程忙碌，并在没有工作时将其置于休眠状态。

运行循环非常像它的名字。它是你线程进入的一个循环，并且用来运行事件响应程序来响应进来的事件。你代码中的控件语句用来实现真正的循环部分，换句话说，你的代码提供的 while 或者 for 循环驱动运行循环。在你的循环里面，你使用一个运行循环对象来运行事件处理代码，它接收事件并且调用安装的响应程序。

运行循环接收两种不同类型的事件源。Input sources 传递异步事件，经常是来看其他线程或应用的消息。 Timer source 传递同步的事件，发生在调度的时间或者间隔重复。两种类型的源使用应用指定的响应程序来处理到来的事件。

下图以展示了运行循环的概念结构和各种源。Input sources 传递异步的事件给相应的响应程序并导致 `runUntilDate` 方法退出。 Timer sources 传递事件到他们的响应程序但是不会导致运行循环退出。

除了处理输入源，运行循环也产生关于它行为通知。注册 run-loop observers 可以接收这些通知并在线程中使用它们做额外的处理。你使用 Core Foundation 来安装 run-loop observers 到你的线程。

Run Loop Modes

Run Loop mode 是一个需要监视的 input sources 和 timers 集合加需要通知的 run loop observers 的集合。每次你运行你的运行循环，你指定(显式或隐式)一个特定的模式。当事件经过运行循环，只有和该模式关联的源会被监视并允许传递它们的事件。（类似的，只有和该模式关联的观察者会被通知。）和其他模式关联的源会保留到新的事件直到通过合适模式的循环。

在你的代码中，你用名字标识模式。Cocoa 和 Core Foundation 都定义了默认的模式和几个常用的模式，还有在你代码中用来指定这些模式的字符串。你可以通过指定自定义字符串来定义自定义模式。虽然自定义模式的名字可以是任意的，但是它们的内容却不可以。为了他们有用，你必须添加一个或多个 input sources, timers 或者 run-loop observers 来你创建的任意模式。

你使用模式在源通过运行循环时过滤掉不想要的源。大多数时候，你会想要在系统定义的默认模式下运行你的运行循环。但是，一个模态面板可能运行在模态模式。当在这个模式的时候，只有和模态面板相关的源会传递事件到线程。对于次要线程，你可能想使用自定义模式防止在时间关键地操作过程中低优先级源传递事件。

总结一下，运行循环是与线程关联的基本基础结构的一部分，它是一个事件处理循环。接收的事件可以分为异步和同步两大类。Input sources 传递异步事件；Timer source 传递同步事件。我们是通过指定 run loop mode 来指定想要监视的源，Cocoa 和 Core Foundation 定义了默认的模式和几个常用的模式，我们也可以自定义模式。除了接收处理事件，它还可以生成与自身进度相关的消息通知观察者。

那么 Input sources 具体有哪些源呢？它由三部分组成:1.基于端口的源；2.自定义的源；3.Cocoa Perform Selector 源；

Cocoa 和 Core Foundation 为创建一个基于端口的输入源使用端口相关的对象和函数提供内建的支持。例如，在 Cocoa 中，你绝不需要直接创建一个输入源。你简单的创建一个端口对象并使用 NSPort 的方法把端口添加到运行循环。端口对象为你创建和配置需要的输入源。在 Core Foundation 中，你必须手动创建端口和它的运行循环源。在两种情况中，你使用端口不透明类型（CFMachPortRef, CFMessagePortRef or CFSocketRef）关联的函数来创建合适的对象。

何时需要使用运行循环

你唯一需要隐式运行循环的地方是当你为你的应用创建线程的时候。你应用主线程的运行循环是基础设施中重要的一块。因此，应用框架为运行主应用循环提供了代码并自动启动了循环。在 iOS 中 UIApplication（NSApplication 在 OS X）的 run 方法启动了应用的主循环作为正常启动的一部分。如果你使用 Xcode 模板工程来创建你的应用，你应该绝不需要显式调用这些程序。

对于子线程，你决定是否需要运行循环，如果需要，你自己配置和启动它。例如，如果你使用线程执行某些长时间运行并预先确定的任务，你可以避免启动运行循环。运行循环适用于你想要和线程有更多的交互的场景。例如，如果你打算做任何下列事情时需要启动运行循环:

* 使用端口或自定义输入源来和其他线程通信
* 在线程上使用定时器
* 在 Cocoa 应用程序中使用任何 performSelector...方法
* 使用线程执行周期性的任务

如果你选择使用运行循环，配置和设置很直接了当。就像所有其他的线程编程，你应该有一个计划让子线程在合适时机退出。退出干净地结束一个线程总是好过强制终止它。


####使用运行循环对象

运行循环提供了主接口去添加 input sources, timers 和 run-loop observers 到你的运行循环并运行它。每个线程有一个关联它的单一的运行循环对象。在 Cocoa 中，这个对象是 NSRunLoop 类的实例。在一个抽象度低的应用，这是一个 CFRunLoopRef 不透明类型指针。

得到一个运行循环对象

为了从当前线程得到运行循环，你可以使用以下方法之一:

* 在 Cocoa 应用程序中，使用 NSRunLoop 的类方法 currentRunLoop 获取一个 NSRunLoop 对象
* 使用 CFRunLoopGetCurrent 函数

虽然它们并不是自由桥接的类型，当你需要时你可以从 NSRunLoop 对象得到一个 CFRunLoopRef 不透明类型。因为两个对象是指向相同的运行循环，你可以根据需要混合 NSRunLoop 对象和 CFRunLoopRef 不透明类型的调用。

配置运行循环

在子线程上运行运行循环之前，你必须为它至少添加一个输入源或定时器。如果运行循环没有任何要监视的源，当你尝试运行它时它马上就退出了。

除了安装源，你也安装运行循环观察者来检测运行循环不同的执行阶段。为了安装运行循环观察者，你创建一个 CFRunLoopObserverRef 不透明类型，使用 CFRunLoopAddObserver 函数添加它到你的运行循环。运行循环观察者必须使用 Core Foundation 创建，即使是 Cocoa 应用程序。

启动运行循环

有很多方法启动运行循环，展示如下：

* 无条件的
* 有时间限制的
* 在特定模式的

无条件进入运行循环是最简单的选项，但是它也是最不可取的。无条件运行运行循环将你的线程置于永久的循环中，这使你对运行循环本身有很少的控制。你可以添加和移除输入源和定时器，但是你只能通过杀死它来停止它。也没办法让它运行在自定义模式下。与其无条件的运行一个运行循环，使用一个超时值来运行运行循环更好。当你使用超时值时，运行循环会一直运行直到事件到来或者分配的时间过期。如果一个事件到达，它会被分发到响应程序处理然后退出运行循环；如果分配的时候过期了，你可以简单地重启运行循环或者用这个时间去做任何清扫工作。

除了超时值，你可以用一个特定的模式来运行你的运行循环。模式和超时值不是互斥的，它们可以一起用来启动运行循环。

退出运行循环

在处理事件前有两种方法退出运行循环：

* 用超时值配置运行循环
* 告诉运行循环停止

如果你能管理它，使用超时值肯定是推荐的。指定一个超时值在退出前完成所有的处理，包括传递通知到运行循环观察者。

用 CFRunLoopStop 函数显式地停止运行循环产生和超时相似的结果。它发出任何遗留的运行循环通知然后退出。不同的地方在于你不可以在无条件启动的运行循环中使用这种技术。

虽然从运行循环中移除输入源和定时器也会导致运行循环退出，但是这不是停止运行循环可靠的方法。某些系统程序添加输入源到运行循环来处理需要的事件。因为你的代码可能意识不到这些输入源，它可能不能移除他们，这会阻止运行循环退出。

####配置运行循环源

###线程间通信

虽然一个好的设计最小化了通信的需求，在某些时候，线程间通信是需要的。（一个线程的职责是为你的应用程序工作，如果它工作的结果从来没补使用，它有什么好处呢？）线程也许需要处理新的工作请求或者向你应用的主线程报告它们的进度。在这些情况，你需要一种从一个线程到另一个线程获取信息的方法。很幸运，线程共享相同的进程空间的事实意味着你有很多选项来通信。

线程间通信有很多方法，每个者有自己的优缺点。配置 Thread-Local 存储是 OS X 是最常用的通信机制。下面的通信技术按复杂度递增。

直接消息

Cocoa 应用程序支持在其他线程上执行方法的能力。这种能力意味着一个线程可以任意地执行另一个线程的方法。因为它们在目标线程的上下文中运行，这种方式发送的消息在目标线程是串行的。

全局变量，共享内存和对象

另一种在两个线程间通信的简单方法是使用一个全局变量，共享对象或者共享一块内存。虽然共享变量很快并且简单，它们比直接消息更加脆弱。共享变量必须用锁或者其他同步机制小心地保护来保证你代码的正确性。如果不这么做可能导致竞争条件，数据损坏或崩溃。

条件

条件是一个你用来控制一个线程何时执行某部分代码的同步工具。你可以把它想像成门卫，仅仅当条件满足时才让线程运行。

Run loop sources

一个自定义的 run loop source 是你设置在线程上接收应用指定消息的装置。因为它们是事件驱动，当没什么事要做时 run loop source 让你的线程自动去休眠，这样可以提高你线程的效率。

端口和 sockets

基于端口的通信是一种更精密的方法，但是它也是非常可靠的技术。更重要的是，端口和 sockets 可以用来和外部的实体通信，例如其他的进程和服务。为了提高效率，端口是用 run loop sources 实现的，所以当端口没有数据等待时你的线程是休眼的。

消息队列

传统的多进程服务定义一个先进先出的队列抽象用来管理数据的进出。虽然消息队列简单方便，它们并不如其他通信技术高效。

Cocoa distributed objects

Distributed objects 是一个 Cocoa 技术，它提供了一个基于端口通信的高层实现。虽然可以使用它来进行线程间通信，因为它经常性开销的数量，这么做是非常不推荐的。Distributed objects 更加适合用来和其他进程通信，这里进程间的开销本来已经很高了。


###线程同步

## Reference

* Thread Programming Guide

