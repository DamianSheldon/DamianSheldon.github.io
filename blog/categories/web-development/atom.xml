<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/web-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2022-04-26T17:16:56+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(翻译)Spring Boot 面试题]]></title>
    <link href="http://DamianSheldon.github.io/blog/spring-boot-interview-questions.html"/>
    <updated>2022-04-19T10:03:03+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/spring-boot-interview-questions</id>
    <content type="html"><![CDATA[<h1>1. 概述</h1>

<p>自推出以来，Spring Boot一直是Spring生态系统中的一个重要角色。这个项目凭借其自动配置能力使我们的生活变得更加轻松。</p>

<p>在本教程中，我们将介绍一些在求职面试中可能出现的与Spring Boot有关的最常见问题。</p>

<h1>2. 题目</h1>

<h2>Q1. 什么是Spring Boot，其主要特点是什么？</h2>

<p>Spring Boot本质上是一个建立在Spring框架之上的快速应用开发框架。凭借其自动配置和嵌入式应用服务器支持，再加上其享有的大量文档和社区支持，Spring Boot是迄今为止Java生态系统中最受欢迎的技术之一。</p>

<p>这里有几个突出的特点。</p>

<ul>
<li><strong>启动器</strong> &ndash; 一组依赖性描述符，可以一次性包括相关的依赖性</li>
<li><strong>自动配置</strong> &ndash; 一种基于classpath上的依赖关系自动配置应用程序的方法</li>
<li><strong>执行器</strong> &ndash; 获得生产就绪的功能，如监控</li>
<li><strong>安全性</strong></li>
<li><strong>记录</strong></li>
</ul>


<h2>Q2. Spring和Spring Boot之间的区别是什么？</h2>

<p>Spring框架提供了多种功能，使Web应用的开发更加容易。这些功能包括依赖性注入、数据绑定、面向方面的编程、数据访问等等。</p>

<p>多年来，Spring越来越复杂，这种应用所需的配置量可能令人生畏。这就是Spring Boot的用武之地&ndash;它使配置一个Spring应用程序变得轻而易举。</p>

<p>从本质上讲，Spring是没有主见的，而Spring Boot对平台和库有主见，让我们快速上手。</p>

<p>下面是Spring Boot带来的两个最重要的好处。</p>

<ul>
<li>根据它在classpath上找到的库自动配置应用程序</li>
<li>提供生产中的应用程序常见的非功能特性，如安全或健康检查</li>
</ul>


<p>请查看我们的其他教程，了解<a href="https://www.baeldung.com/spring-vs-spring-boot">普通Spring和Spring Boot的详细比较</a>。</p>

<!--more-->


<h2>Q3. 我们如何用Maven设置Spring Boot应用程序？</h2>

<p>我们可以像对待其他库一样，将Spring Boot纳入Maven项目中。不过，最好的方法是从spring-boot-starter-parent项目中继承，并声明对Spring Boot starters的依赖关系。这样做可以让我们的项目重用Spring Boot的默认设置。</p>

<p>继承spring-boot-starter-parent项目很简单，我们只需要在pom.xml中指定一个父元素:</p>

<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.4.0.RELEASE&lt;/version&gt;
&lt;/parent&gt;
</code></pre>

<p>我们可以在Maven中心找到最新版本的spring-boot-starter-parent。</p>

<p>使用启动器父项目很方便，但并不总是可行的。例如，如果我们公司要求所有项目都继承自标准POM，那么我们仍然可以通过使用<a href="https://www.baeldung.com/spring-boot-dependency-management-custom-parent">自定义父项目</a>来受益于Spring Boot的依赖性管理。</p>

<h2>Q4. 什么是Spring Initializr？</h2>

<p>Spring Initializr是一种创建Spring Boot项目的便捷方式。</p>

<p>我们可以去<a href="https://start.spring.io/">Spring Initializr</a>网站，选择一个依赖管理工具（Maven或Gradle）、一种语言（Java、Kotlin或Groovy）、一种打包方案（Jar或War）、版本和依赖性，然后下载项目。</p>

<p>这为我们创建了一个骨架项目，节省了设置时间，这样我们就可以集中精力添加业务逻辑。</p>

<p>即使我们使用IDE的（如STS或带有STS插件的Eclipse）新项目向导来创建Spring Boot项目，它也会在底下使用Spring Initializr。</p>

<h2>Q5. 外面有哪些Spring Boot启动器？</h2>

<p>每个启动器都扮演着一站式服务的角色，提供我们需要的所有 Spring 技术。其他所需的依赖项也会被拉进来，并以一致的方式进行管理。</p>

<p>所有启动器都在org.springframework.boot组下，其名称以spring-boot-starter-开头。这种命名模式使我们很容易找到启动器，特别是在使用支持按名称搜索依赖关系的IDE时。</p>

<p>在写这篇文章的时候，有超过50个启动器供我们使用。这里，我们将列出最常见的：</p>

<ul>
<li><strong>spring-boot-starter</strong>：核心启动器，包括自动配置支持、日志和YAML</li>
<li><strong>spring-boot-starter-aop</strong>: 使用Spring AOP和AspectJ进行面向方面的编程</li>
<li><strong>spring-boot-starter-data-jpa</strong>：用于在Hibernate中使用Spring Data JPA。</li>
<li><strong>spring-boot-starter-security</strong>: 用于使用Spring Security。</li>
<li><strong>spring-boot-starter-test</strong>: 用于测试Spring Boot应用程序</li>
<li><strong>spring-boot-starter-web</strong>: 用于使用Spring MVC构建Web（包括RESTful）应用程序。</li>
</ul>


<p>有关启动程序的完整列表，请参见该<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters">资源库</a>。</p>

<p>要找到关于Spring Boot启动程序的更多信息，请看<a href="https://www.baeldung.com/spring-boot-starters">Spring Boot启动程序介绍</a>。</p>

<h2>Q6. 如何禁用一个特定的自动配置？</h2>

<p>如果我们想禁用一个特定的自动配置，我们可以使用@EnableAutoConfiguration注解的exclude属性来设置它。</p>

<p>例如，这个代码片断禁用了DataSourceAutoConfiguration:</p>

<pre><code>// other annotations
@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
</code></pre>

<p>如果我们用@SpringBootApplication注解启用了自动配置&ndash;该注解将@EnableAutoConfiguration作为元注解&ndash;我们可以用同名的属性禁用自动配置:</p>

<pre><code>// other annotations
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
</code></pre>

<p>我们也可以用spring.autoconfigure.exclude环境属性禁用自动配置。在application.properties文件中的配置与之前做的设置是做相同的事情:</p>

<pre><code>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
</code></pre>

<h2>Q7. 如何注册一个自定义的自动配置？</h2>

<p>要注册一个自动配置类，我们必须在META-INF/spring.factories文件的EnableAutoConfiguration键下列出其完全限定名称:</p>

<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.baeldung.autoconfigure.CustomAutoConfiguration
</code></pre>

<p>如果我们用Maven构建项目，该文件应放在resources/META-INF目录下，在打包阶段最终会出现在上述位置。</p>

<h2>Q8. 如何告诉自动配置在Bean存在时退缩？</h2>

<p>为了指示自动配置类在Bean已经存在时退缩，我们可以使用 @ConditionalOnMissingBean 注解。</p>

<p>这个注解最值得注意的属性是:</p>

<ul>
<li>value &ndash; 要检查的Bean的类型</li>
<li>name &ndash; 要检查的bean的名字</li>
</ul>


<p>当放在一个用@Bean装饰的方法上时，目标类型默认为该方法的返回类型:</p>

<pre><code>@Configuration
public class CustomConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public CustomService service() { ... }
}
</code></pre>

<h2>Q9. 如何将Spring Boot Web应用部署为Jar和War文件？</h2>

<p>传统上，我们将Web应用打包成WAR文件，然后将其部署到外部服务器上。这样做可以让我们在同一台服务器上安排多个应用程序。在CPU和内存稀缺的时候，这是一个节省资源的好方法。</p>

<p>但事情已经发生了变化。现在计算机硬件相当便宜，人们的注意力已经转向服务器配置。在部署过程中，配置服务器的一个小错误可能会导致灾难性的后果。</p>

<p>Spring通过提供一个插件，即spring-boot-maven-plugin，将网络应用打包成可执行的JAR，来解决这个问题。</p>

<p>要包含这个插件，只需在pom.xml中添加一个插件元素:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
</code></pre>

<p>有了这个插件，我们在执行打包阶段后会得到一个扁平的JAR。这个JAR包含所有必要的依赖，包括一个嵌入式服务器。因此，我们不再需要担心配置外部服务器的问题。</p>

<p>然后我们可以像运行普通的可执行JAR一样运行该应用程序。</p>

<p>注意，pom.xml文件中的打包元素必须设置为jar来构建JAR文件:</p>

<pre><code>&lt;packaging&gt;jar&lt;/packaging&gt;
</code></pre>

<p>如果我们不包括这个元素，它也默认为jar。</p>

<p>要构建一个WAR文件，我们把包装元素改为war:</p>

<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;
</code></pre>

<p>并将容器的依赖关系从打包的文件中删除:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>在执行Maven打包阶段后，我们会有一个可部署的WAR文件。</p>

<h2>Q10. 如何在命令行应用程序中使用Spring Boot？</h2>

<p>就像其他Java程序一样，Spring Boot命令行应用程序必须有一个main方法。</p>

<p>这个方法作为一个入口点，它调用<code>SpringApplication#run</code>方法来启动应用程序:</p>

<pre><code>@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class);
        // other statements
    }
}
</code></pre>

<p>然后SpringApplication类启动Spring容器并自动配置Bean。</p>

<p>注意我们必须向run方法传递一个配置类，作为主要的配置源。按照惯例，这个参数就是入口类本身。</p>

<p>在调用运行方法后，我们可以像普通程序一样执行其他语句。</p>

<h2>Q11. 外部配置的可能来源是什么？</h2>

<p>Spring Boot提供了对外部配置的支持，使我们能够在不同的环境中运行同一个应用程序。我们可以使用属性文件、YAML文件、环境变量、系统属性和命令行选项参数来指定配置属性。</p>

<p>然后，我们可以使用@Value注解、通过<a href="https://www.baeldung.com/configuration-properties-in-spring-boot">@ConfigurationProperties注解</a>的绑定对象或环境抽象来访问这些属性。</p>

<h2>Q12. Spring Boot支持宽松的绑定是什么意思？</h2>

<p>Spring Boot中的宽松绑定适用于<a href="https://www.baeldung.com/configuration-properties-in-spring-boot">配置属性的类型安全绑定</a>。</p>

<p>通过宽松的绑定，属性的键不需要与属性名完全匹配。这样的环境属性可以用camelCase、kebab-case、snake_case，或者用大写字母，用下划线隔开单词。</p>

<p>例如，如果一个带有 @ConfigurationProperties 注解的 bean 类中的一个属性被命名为 myProp，它可以被绑定到这些环境属性中的任何一个：myProp、my-prop、my_prop 或 MY_PROP。</p>

<h2>Q13. Spring Boot DevTools的用途是什么？</h2>

<p>Spring Boot开发者工具，或称DevTools，是一套使开发过程更容易的工具。</p>

<p>为了包括这些开发时的功能，我们只需要在pom.xml文件中添加一个依赖项:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>如果应用程序在生产中运行，spring-boot-devtools模块会自动禁用。重新打包的归档文件也默认排除了这个模块。所以，它不会给我们的最终产品带来任何开销。</p>

<p>默认情况下，DevTools应用适合于开发环境的属性。这些属性禁用了模板缓存，启用了网络组的调试日志，诸如此类。因此，我们有了这种合理的开发时配置，而无需设置任何属性。</p>

<p>只要classpath上的文件发生变化，使用DevTools的应用程序就会重新启动。这在开发中是一个非常有帮助的功能，因为它可以快速反馈修改情况。</p>

<p>默认情况下，静态资源，包括视图模板，不会引发重启。相反，资源变化会触发浏览器刷新。请注意，只有在浏览器中安装了LiveReload扩展，以便与DevTools包含的嵌入式LiveReload服务器进行交互时，这才会发生。</p>

<p>关于这一主题的进一步信息，请参见<a href="https://www.baeldung.com/spring-boot-devtools">Spring Boot DevTools概述</a>。</p>

<h2>Q14. 如何编写集成测试？</h2>

<p>在为Spring应用程序运行集成测试时，我们必须有一个ApplicationContext。</p>

<p>为了让我们的生活更轻松，Spring Boot为测试提供了一个特殊的注解&ndash;@SpringBootTest。该注解从其classes属性所指示的配置类中创建一个ApplicationContext。</p>

<p>如果classes属性没有设置，Spring Boot会搜索主要的配置类。搜索从包含测试的包开始，直到找到一个用@SpringBootApplication或@SpringBootConfiguration注解的类。</p>

<p>有关详细说明，请查看我们的<a href="https://www.baeldung.com/spring-boot-testing">Spring Boot测试教程</a>。</p>

<h2>Q15. Spring Boot Actuator的用途是什么？</h2>

<p>从本质上讲，Actuator通过启用生产就绪的功能，使Spring Boot应用程序活起来。这些功能使我们能够在应用程序在生产中运行时监控和管理它们。</p>

<p>将Spring Boot Actuator集成到一个项目中非常简单。我们所要做的就是在pom.xml文件中包括spring-boot-starter-actuator启动器:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>Spring Boot Actuator可以使用HTTP或JMX端点来暴露操作信息。但大多数应用程序都会选择HTTP，其中端点的身份和/actuator前缀构成了一个URL路径。</p>

<p>下面是Actuator提供的一些最常见的内置端点。</p>

<ul>
<li><strong>env</strong> 暴露环境属性</li>
<li><strong>health</strong> 显示应用程序的健康信息</li>
<li><strong>httptrace</strong> 显示HTTP跟踪信息</li>
<li><strong>info</strong> 显示任意的应用程序信息</li>
<li><strong>metrics</strong> 显示度量信息</li>
<li><strong>loggers</strong> 显示并修改应用程序中的记录器配置</li>
<li><strong>mappings</strong> 显示所有@RequestMapping路径的列表</li>
</ul>


<p>请参考我们的<a href="https://www.baeldung.com/spring-boot-actuators">Spring Boot Actuator教程</a>，了解详细情况。</p>

<h2>Q16. 配置Spring Boot项目时，属性和YAML哪个更好？</h2>

<p>与属性文件相比，YAML有很多优点。</p>

<ul>
<li>更加清晰，可读性更好</li>
<li>非常适合分层的配置数据，也可以用更好、更易读的格式来表示</li>
<li>支持地图、列表和标量类型</li>
<li>可以在同一个文件中包含多个<a href="https://www.baeldung.com/spring-profiles">配置文件</a>（从Spring Boot 2.4.0开始，属性文件也可以这样做了）</li>
</ul>


<p>但是，由于它的缩进规则，编写它可能有点困难，而且容易出错。</p>

<p>有关细节和工作样本，请参考我们的<a href="https://www.baeldung.com/spring-yaml-vs-properties">Spring YAML与属性</a>教程。</p>

<h2>Q17. Spring Boot提供了哪些基本注解？</h2>

<p>Spring Boot提供的主要注释位于org.springframework.boot.autoconfigure及其子包中。</p>

<p>以下是一些基本的注释：</p>

<ul>
<li><strong>@EnableAutoConfiguration</strong> &ndash; 使Spring Boot在其classpath上寻找自动配置豆并自动应用它们。</li>
<li><strong>@SpringBootApplication</strong> &ndash; 表示Boot Application的主类。该注解将@Configuration、@EnableAutoConfiguration和@ComponentScan注解与它们的默认属性结合起来。</li>
</ul>


<p><a href="https://www.baeldung.com/spring-boot-annotations">Spring Boot注解</a>提供了对这一主题的更多见解。</p>

<h2>Q18. 如何改变Spring Boot中的默认端口？</h2>

<p>我们可以通过以下方式改变嵌入Spring Boot中的服务器的默认端口。</p>

<ul>
<li>使用属性文件 &ndash; 我们可以在application.properties（或application.yml）文件中使用属性server.port来定义。</li>
<li>通过编程 &ndash; 在我们的主@SpringBootApplication类中，我们可以在SpringApplication实例上设置server.port。</li>
<li>使用命令行 &ndash; 当以jar文件的形式运行应用程序时，我们可以将server.port设置为java命令参数:</li>
</ul>


<pre><code>java -jar -Dserver.port=8081 myspringproject.jar
</code></pre>

<h2>Q19. Spring Boot支持哪些嵌入式服务器，以及如何改变默认值？</h2>

<p>截至目前，Spring MVC支持Tomcat、Jetty和Undertow。Tomcat是Spring Boot的Web Starter支持的默认应用服务器。</p>

<p>Spring WebFlux支持Reactor Netty、Tomcat、Jetty和Undertow，其中Reactor Netty为默认。</p>

<p>在Spring MVC中，如果要改变默认，比方说改变为Jetty，我们需要排除Tomcat，在依赖关系中包括Jetty:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>同样，要把WebFlux的默认值改为UnderTow，我们需要排除Reactor Netty，并把UnderTow纳入依赖关系。</p>

<p><a href="https://www.baeldung.com/spring-boot-servlet-containers">比较Spring Boot中的嵌入式Servlet容器</a>有更多关于我们可以在Spring MVC中使用的不同嵌入式服务器的细节。</p>

<h2>Q20. 为什么我们需要Spring Profiles？</h2>

<p>在为企业开发应用程序时，我们通常要处理多种环境，如开发、QA和生产。这些环境的配置属性是不同的。</p>

<p>例如，我们可能在开发中使用嵌入式H2数据库，但开发中可能有专有的Oracle或DB2。即使DBMS在不同的环境中是相同的，URLs也肯定是不同的。</p>

<p>为了使这个问题简单明了，Spring提供了配置文件，以帮助分离每个环境的配置。因此，可以将这些属性保存在不同的文件中，如application-dev.properties和application-prod.properties，而不是通过编程来维护这些属性。默认的application.properties使用spring.profiles.active指向当前活动的配置文件，这样就可以获得正确的配置。</p>

<p><a href="https://www.baeldung.com/spring-profiles">Spring Profiles</a>给出了关于这个主题的全面观点。</p>

<h1>3. 总结</h1>

<p>本文介绍了技术面试中可能出现的关于Spring Boot的一些最关键问题。</p>

<p>我们希望这些问题能够帮助你找到理想的工作。</p>

<h1>4. 原文</h1>

<ul>
<li><a href="https://www.baeldung.com/spring-boot-interview-questions">Spring Boot Interview Questions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)Spring MVC 面试题]]></title>
    <link href="http://DamianSheldon.github.io/blog/spring-mvc-interview-questions.html"/>
    <updated>2022-04-12T11:42:30+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/spring-mvc-interview-questions</id>
    <content type="html"><![CDATA[<h1>1. 简介</h1>

<p>Spring MVC是Spring公司在Servlet API基础上建立的原创Web框架。它提供了模型-视图-控制器架构，可用于开发灵活的Web应用。</p>

<p>在本教程中，我们将重点讨论与之相关的问题，因为它经常是Spring开发者求职面试的一个话题。</p>

<p>关于Spring框架的更多问题，你可以查看我们<a href="https://www.baeldung.com/tag/interview/">面试问题系列</a>中另一篇与<a href="https://www.baeldung.com/spring-interview-questions">Spring有关的文章</a>。</p>

<h1>2.基础 Spring MVC 题</h1>

<h2>Q1. 为什么我们要使用Spring MVC？</h2>

<p>Spring MVC实现了清晰的关注点分离，使我们能够轻松开发和单元测试我们的应用程序。</p>

<p>像如下概念：</p>

<ul>
<li>Dispatcher Servlet</li>
<li>Controllers</li>
<li>View Resolvers</li>
<li>Views, Models</li>
<li>ModelAndView</li>
<li>Model and Session Attributes</li>
</ul>


<p>是完全相互独立的，它们只负责一件事。</p>

<p>因此，MVC给了我们相当大的灵活性。它是基于接口的（有提供的实现类），我们可以通过使用自定义接口来配置框架的每一部分。</p>

<p>另一件重要的事情是，我们并没有被束缚在一个特定的视图技术上（例如JSP），而是可以选择我们最喜欢的技术。</p>

<p>另外，我们不只在Web应用开发中使用Spring MVC，在创建RESTful Web服务时也是如此。</p>

<!--more-->


<h2>Q2. <code>@Autowired</code>注解的作用是什么？</h2>

<p><code>@Autowired</code>注解可以与字段或方法一起使用，用于按类型注入Bean。这个注解允许Spring解析并将协作Bean注入你的Bean中。</p>

<p>更多细节，请参考关于<a href="https://www.baeldung.com/spring-autowire"><code>@Autowired</code> in Spring</a>的教程。</p>

<h2>Q3. 解释一下模型属性</h2>

<p><code>@ModelAttribute</code>注解是Spring MVC中最重要的注解之一。它将一个方法参数或方法返回值绑定到一个命名的模型属性上，然后将其暴露给Web视图。</p>

<p>如果我们在方法层面使用它，它表明该方法的目的是添加一个或多个模型属性。</p>

<p>另一方面，当作为方法参数使用时，它表示该参数应该从模型中获取。当不存在时，我们应该首先将其实例化，然后将其添加到模型中。一旦出现在模型中，我们应该从所有具有匹配名称的请求参数中填充参数字段。</p>

<p>关于这个注解的更多信息可以在我们与<a href="https://www.baeldung.com/spring-mvc-and-the-modelattribute-annotation"><code>@ModelAttribute</code>注解有关的文章</a>中找到。</p>

<h2>Q4. 解释一下@Controller和@RestController之间的区别？</h2>

<p><code>@Controller</code>和<code>@RestController</code>注释的主要区别在于，<code>@RestController</code>注释会自动包含<code>@ResponseBody</code>。这意味着我们不需要用<code>@ResponseBody</code>来注释我们的处理方法。如果我们想直接在HTTP响应体中写入响应类型，在<code>@Controller</code>类中需要这样做。</p>

<h2>Q5. 描述一下PathVariable</h2>

<p>我们可以使用<code>@PathVariable</code>注解作为处理方法参数，来提取URI模板变量的值。</p>

<p>例如，如果我们想从<code>www.mysite.com/user/123</code>，通过id获取一个用户，我们应该把控制器中的方法映射为<code>/user/{id}</code>:</p>

<pre><code>@RequestMapping("/user/{id}")
public String handleRequest(@PathVariable("id") String userId, Model map) {}
</code></pre>

<p>@PathVariable只有一个名为value的元素。它是可选的，我们用它来定义URI模板变量的名称。如果我们省略value元素，那么URI模板变量的名称必须与方法参数名称相匹配。</p>

<p>也允许有多个@PathVariable注解，可以通过一个接一个地声明它们:</p>

<pre><code>@RequestMapping("/user/{userId}/name/{userName}")
public String handleRequest(@PathVariable String userId,
  @PathVariable String userName, Model map) {}
</code></pre>

<p>或将它们全部放在一个<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>中:</p>

<pre><code>@RequestMapping("/user/{userId}/name/{userName}")
public String handleRequest(@PathVariable Map&lt;String, String&gt; varsMap, Model map) {}
</code></pre>

<h2>Q6. 使用Spring MVC进行验证</h2>

<p>Spring MVC默认支持JSR-303规范。我们需要在我们的Spring MVC应用中添加JSR-303及其实现的依赖性。例如，Hibernate Validator就是我们可以使用的JSR-303的实现之一。</p>

<p>JSR-303是用于bean验证的Java API规范，是Jakarta EE和JavaSE的一部分，它使用<code>@NotNull</code>、<code>@Min</code>和<code>@Max</code>等注解，确保bean的属性满足特定的标准。关于验证的更多信息，请参见<a href="https://www.baeldung.com/javax-validation">Java Bean验证基础知识</a>一文。</p>

<p>Spring提供了<code>@Validator</code>注解和BindingResult类。当我们有无效的数据时，Validator实现将在控制器的请求处理方法中触发错误。然后我们可以使用BindingResult类来获取这些错误。</p>

<p>除了使用现有的实现，我们还可以制作自己的实现。要做到这一点，我们首先创建一个符合JSR-303规范的注解。然后，我们实现Validator类。另一种方法是实现Spring的Validator接口，并通过控制器类中的<code>@InitBinder</code>注解将其设置为验证器。</p>

<p>要查看如何实现和使用你自己的验证器，请看关于<a href="https://www.baeldung.com/spring-mvc-custom-validator">Spring MVC中自定义验证</a>的教程。</p>

<h2>Q7. 什么是<code>@RequestBody</code>和<code>@ResponseBody</code>注解？</h2>

<p><code>@RequestBody</code>注解，作为处理方法参数使用，将HTTP请求主体与传输或域对象绑定。Spring使用Http消息转换器自动将传入的HTTP请求反序列化为Java对象。</p>

<p>当我们在Spring MVC控制器中的处理方法上使用<code>@ResponseBody</code>注解时，它表明我们将把该方法的返回类型直接写入HTTP响应体中。我们不会把它放在Model中，Spring也不会把它解释为视图名称。</p>

<p>请查看关于<a href="https://www.baeldung.com/spring-request-response-body"><code>@RequestBody</code>和<code>@ResponseBody</code></a>的文章，了解关于这些注解的更多细节。</p>

<h2>Q8. 解释一下Model、ModelMap和ModelAndView？</h2>

<p>Model接口定义了一个模型属性的持有人。ModelMap也有类似的目的，它能够传递一个值的集合。然后，它把这些值当作是在一个Map内。我们应该注意，在模型（ModelMap）中我们只能存储数据。我们把数据放进去并返回一个视图名称。</p>

<p>另一方面，在ModelAndView中，我们返回对象本身。我们把所有需要的信息，比如数据和视图名称，都设置在我们要返回的对象中。</p>

<p>你可以在关于<a href="https://www.baeldung.com/spring-mvc-model-model-map-model-view">Model、ModelMap和ModelView</a>的文章中找到更多细节。</p>

<h2>Q9. 解释SessionAttributes和SessionAttribute</h2>

<p><code>@SessionAttributes</code>注解是用来在用户会话中存储模型属性的。我们在控制器类中使用它，如我们关于Spring MVC中的会话属性的文章中所示:</p>

<pre><code>@Controller
@RequestMapping("/sessionattributes")
@SessionAttributes("todos")
public class TodoControllerWithSessionAttributes {

    @GetMapping("/form")
    public String showForm(Model model,
      @ModelAttribute("todos") TodoList todos) {
        // method body
        return "sessionattributesform";
    }

    // other methods
}
</code></pre>

<p>在前面的例子中，如果<code>@ModelAttribute</code>和<code>@SessionAttributes</code>有相同的名称属性，模型属性 &ldquo;todos "将被添加到会话中。</p>

<p>如果我们想从一个全局管理的会话中获取现有的属性，我们将使用<code>@SessionAttribute</code>注解作为方法参数：</p>

<pre><code>@GetMapping
public String getTodos(@SessionAttribute("todos") TodoList todos) {
    // method body
    return "todoView";
}
</code></pre>

<h2>Q10. <code>@EnableWebMVC</code>的目的是什么？</h2>

<p><code>@EnableWebMvc</code>注解的目的是通过Java配置启用Spring MVC。它等同于XML配置中的<code>&lt;mvc: annotation-driven&gt;</code>。这个注解从WebMvcConfigurationSupport导入Spring MVC配置。它能够支持<code>@Controller</code>注解的类，这些类使用<code>@RequestMapping</code>将传入的请求映射到处理方法。</p>

<p>你可以在我们的<a href="https://www.baeldung.com/spring-enable-annotations">Spring <code>@Enable</code>注解指南</a>中了解更多关于这个和类似注解的信息。</p>

<h2>Q11. 什么是Spring中的ViewResolver？</h2>

<p>ViewResolver通过将视图名称映射到实际视图，使应用程序能够在浏览器中渲染模型，这样无需将实现与特定的视图技术联系起来。</p>

<p>关于ViewResolver的更多细节，请看我们的<a href="https://www.baeldung.com/spring-mvc-view-resolver-tutorial">Spring MVC中的ViewResolver指南</a>。</p>

<h2>Q12. 什么是BindingResult？</h2>

<p>BindingResult是<code>org.springframework.validation</code>包中的一个接口，表示绑定结果。我们可以用它来检测和报告提交表单中的错误。它很容易被调用&ndash;我们只需要确保把它作为一个参数放在我们要验证的表单对象之后。可选的Model参数应该在BindingResult之后，这在<a href="https://www.baeldung.com/spring-mvc-custom-validator">自定义验证器教程</a>中可以看到:</p>

<pre><code>@PostMapping("/user")
public String submitForm(@Valid NewUserForm newUserForm, 
  BindingResult result, Model model) {
    if (result.hasErrors()) {
        return "userHome";
    }
    model.addAttribute("message", "Valid form");
    return "userHome";
}
</code></pre>

<p>当Spring看到<code>@Valid</code>注解时，它首先会尝试为被验证的对象找到验证器。然后，它将拾起验证注解并调用验证器。最后，它将把发现的错误放在BindingResult中，并把后者添加到视图模型中。</p>

<h2>Q13. 什么是表单后备对象？</h2>

<p>表单后备对象或命令对象只是一个POJO，它从我们要提交的表单中收集数据。</p>

<p>我们应该记住，它不包含任何逻辑，只包含数据。</p>

<p>要了解如何在Spring MVC中使用表单支持对象，请看我们关于<a href="https://www.baeldung.com/spring-mvc-form-tutorial">Spring MVC中表单</a>的文章。</p>

<h2>Q14.<code>@Qualifier</code>注解的作用是什么？</h2>

<p>它与<code>@Autowired</code>注解同时使用，以避免一个bean类型的多个实例出现时的混淆。</p>

<p>让我们看一个例子。我们在XML配置中声明了两个类似的Bean:</p>

<pre><code>&lt;bean id="person1" class="com.baeldung.Person" &gt;
    &lt;property name="name" value="Joe" /&gt;
&lt;/bean&gt;
&lt;bean id="person2" class="com.baeldung.Person" &gt;
    &lt;property name="name" value="Doe" /&gt;
&lt;/bean&gt;
</code></pre>

<p>当我们试图连接Bean时，我们会得到一个<code>org.springframework.beans.factory.NoSuchBeanDefinitionException</code>。为了解决这个问题，我们需要使用<code>@Qualifier</code>来告诉Spring关于哪个Bean应该被连接:</p>

<pre><code>@Autowired
@Qualifier("person1")
private Person person;
</code></pre>

<h2>Q15. <code>@Required</code>注解的作用是什么？</h2>

<p><code>@Required</code>注解用于setter方法，它表示在配置时必须填充具有该注解的bean属性。否则，Spring容器将抛出一个BeanInitializationException异常。</p>

<p>另外，<code>@Required</code>与<code>@Autowired</code>不同&ndash;因为它只限于 setter ，而<code>@Autowired</code>则不是。<code>@Autowired</code>也可以用来与构造函数和字段进行连接，而<code>@Required</code>只检查该属性是否被设置。</p>

<p>让我们看一个例子:</p>

<pre><code>public class Person {
    private String name;

    @Required
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>

<p>现在，Person Bean的名字需要像这样在XML配置中设置:</p>

<pre><code>&lt;bean id="person" class="com.baeldung.Person"&gt;
    &lt;property name="name" value="Joe" /&gt;
&lt;/bean&gt;
</code></pre>

<p>请注意，<code>@Required</code>默认情况下不能与基于Java的<code>@Configuration</code>类一起工作。如果你需要确保所有的属性都被设置，你可以在<code>@Bean</code>注解的方法中创建Bean时这样做。</p>

<p>译者点评：<code>@Required</code> 是如何实现的？</p>

<h2>Q16. 描述一下前台控制器模式</h2>

<p>在前端控制器模式中，所有的请求将首先进入前端控制器，而不是Servlet。它将确保响应已经准备好，并将它们送回给浏览器。这样，我们就有一个地方可以控制来自外部世界的一切。</p>

<p>前端控制器将识别应该首先处理请求的Servlet。然后，当它从servlet那里得到数据后，它将决定渲染哪个视图，最后，它将把渲染好的视图作为一个响应发送回去：</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2018/12/front_end_controller.png" alt="Front end controller" /></p>

<p>要查看实现细节，请查看我们的<a href="https://www.baeldung.com/java-front-controller-pattern">Java中的前端控制器模式指南</a>。</p>

<h2>Q17. 什么是 Model1和Model2的架构？</h2>

<p> Model1和Model2代表了在设计Java Web应用时经常使用的两种设计模式。</p>

<p>在Model1中，一个请求被送到一个servlet或JSP那里进行处理。Servlet或JSP处理请求，处理业务逻辑，检索和验证数据，并生成响应:</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2018/12/Model_1-1.png" alt="Model 1" /></p>

<p>由于这种架构很容易实现，我们通常在小型和简单的应用程序中使用它。</p>

<p>另一方面，它对于大规模的网络应用并不方便。这些功能通常在JSP中重复使用，其中业务和表现逻辑是耦合的。</p>

<p>Model2是基于模型-视图-控制器设计模式的，它将视图与操作内容的逻辑分开。</p>

<p>此外，我们可以区分MVC模式中的三个模块：模型、视图和控制器。模型代表一个应用程序的动态数据结构。它负责数据和业务逻辑的操作。视图负责显示数据，而控制器作为前两者之间的接口。</p>

<p>在Model2中，一个请求被传递给控制器，控制器处理所需的逻辑，以便获得应该显示的正确内容。然后，控制器将内容放回请求中，通常是作为一个JavaBean或POJO。它还决定哪个视图应该渲染内容，最后将请求传递给它。然后，视图就会渲染数据:</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2018/12/Model_2.png" alt="Model 2" /></p>

<h1>3.进阶 Spring MVC 题</h1>

<h2>Q18. Spring中的@Controller、@Component、@Repository和@Service注解之间有什么区别？</h2>

<p>根据Spring官方文档，@Component是任何Spring管理的组件的通用定型。@Repository、@Service和@Controller是@Component的特殊化，用于更具体的使用情况，例如，分别用于持久层、服务层和表现层。
让我们来看看后三者的具体使用情况:</p>

<ul>
<li><strong>@Controller</strong> &ndash; 表示该类扮演着控制器的角色，并在该类中检测@RequestMapping注解</li>
<li><strong>@Service</strong> &ndash; 表示该类持有业务逻辑并调用存储库层的方法</li>
<li><strong>@Repository</strong> &ndash; 表示该类定义了一个数据存储库；它的工作是捕捉平台特定的异常，并将其作为Spring统一的未检查的异常之一重新抛出</li>
</ul>


<h2>Q19. 什么是DispatcherServlet和ContextLoaderListener？</h2>

<p>简单地说，在前端控制器设计模式中，一个控制器负责将传入的HttpRequests引导到应用程序的所有其他控制器和处理程序。</p>

<p>Spring的DispatcherServlet实现了这种模式，因此，它负责正确协调HttpRequests到正确的处理程序。</p>

<p>另一方面，ContextLoaderListener启动和关闭了Spring的根WebApplicationContext。它将ApplicationContext的生命周期与ServletContext的生命周期联系起来。我们可以用它来定义在不同Spring上下文中工作的共享bean。</p>

<p>关于DispatcherServlet的更多细节，请参考<a href="https://www.baeldung.com/spring-dispatcherservlet">本教程</a>。</p>

<h2>Q20. 什么是MultipartResolver，我们什么时候应该使用它？</h2>

<p>MultipartResolver接口是用来上传文件的。Spring框架提供了一个使用Commons FileUpload 的 MultipartResolver实现，另一个使用Servlet 3.0多部分请求解析。</p>

<p>使用这些，我们可以在我们的Web应用程序中支持文件上传。</p>

<h2>Q21. 什么是Spring MVC拦截器以及如何使用它？</h2>

<p>Spring MVC拦截器允许我们拦截一个客户端请求，并在三个地方进行处理&ndash;在处理之前、处理之后或完成之后（当视图被渲染时）。
拦截器可以用于跨领域的关注，避免重复的处理程序代码，如记录、改变Spring模型中全局使用的参数等。</p>

<p>关于细节和各种实现，请看<a href="https://www.baeldung.com/spring-mvc-handlerinterceptor">Spring MVC HandlerInterceptor介绍</a>这篇文章。</p>

<h2>Q22. 什么是Init Binder？</h2>

<p>一个用@InitBinder注解的方法被用来定制一个请求参数、URI模板和后备/命令对象。我们在控制器中定义它，它有助于控制请求。在这个方法中，我们注册和配置我们的自定义PropertyEditors，格式化器和验证器。</p>

<p>注解中有'value'元素。如果我们不设置它，@InitBinder注解的方法将在每个HTTP请求中被调用。如果我们设置了这个值，这些方法将只适用于特定的命令/表单属性，与/或名称与'value'元素对应的请求参数。</p>

<p>重要的是要记住，其中一个参数必须是WebDataBinder。其他参数可以是处理方法支持的任何类型，除了命令/表单对象和相应的验证结果对象。</p>

<h2>Q23. 解释一下控制器增强</h2>

<p>@ControllerAdvice注解允许我们编写适用于广泛的控制器的全局代码。我们可以将控制器的范围与选定的包或特定的注解联系起来。</p>

<p>默认情况下，@ControllerAdvice适用于用@Controller（或@RestController）注释的类。如果我们想更具体一些，我们还有一些属性可以使用。</p>

<p>如果我们想把适用的类限制在一个包内，我们应该在注释中加入包的名字:</p>

<pre><code>@ControllerAdvice("my.package")
@ControllerAdvice(value = "my.package")
@ControllerAdvice(basePackages = "my.package")
</code></pre>

<p>也可以使用多个包，但这次我们需要使用一个数组而不是String。</p>

<p>除了通过包的名字限制到包之外，我们还可以通过使用该包中的一个类或接口来实现:</p>

<pre><code>@ControllerAdvice(basePackageClasses = MyClass.class)
</code></pre>

<p>&ldquo;assignableTypes"元素将@ControllerAdvice应用于特定的类，而 "annotations"则是针对特定的注释。</p>

<p>值得注意的是，我们应该把它和@ExceptionHandler一起使用。这种组合将使我们能够配置一个全局的、更具体的错误处理机制，而不需要每次都为每个控制器类实现它。</p>

<h2>Q24. @ExceptionHandler注解的作用是什么？</h2>

<p>@ExceptionHandler注解允许我们定义一个处理异常的方法。我们可以独立使用该注解，但将其与@ControllerAdvice一起使用是更好的选择。因此，我们可以建立一个全局性的错误处理机制。这样一来，我们就不需要在每个控制器中编写异常处理的代码。</p>

<p>让我们看看<a href="https://www.baeldung.com/exception-handling-for-rest-with-spring">Spring的REST错误处理</a>这篇文章中的例子:</p>

<pre><code>@ControllerAdvice
public class RestResponseEntityExceptionHandler
  extends ResponseEntityExceptionHandler {

    @ExceptionHandler(value = { IllegalArgumentException.class,
      IllegalStateException.class })
    protected ResponseEntity&lt;Object&gt; handleConflict(RuntimeException ex,
      WebRequest request) {
        String bodyOfResponse = "This should be application specific";
        return handleExceptionInternal(ex, bodyOfResponse, new HttpHeaders(),
          HttpStatus.CONFLICT, request);
    }
}
</code></pre>

<p>我们还应该注意，这将为所有抛出IllegalArgumentException或IllegalStateException的控制器提供@ExceptionHandler方法。用@ExceptionHandler声明的异常应该与作为方法参数的异常相匹配。否则，异常解析机制将在运行时失败。</p>

<p>这里需要记住的一点是，为同一个异常定义多个@ExceptionHandler是可能的。但我们不能在同一个类中这样做，因为Spring会通过抛出一个异常并在启动时失败来抱怨。</p>

<p>另一方面，如果我们在两个独立的类中定义这些，应用程序就会启动，但它会使用它找到的第一个处理程序，可能是错误的。</p>

<h2>Q25. Web应用中的异常处理</h2>

<p>在Spring MVC中，我们有三种处理异常的方法。</p>

<ul>
<li>每个异常</li>
<li>每个控制器</li>
<li>全局</li>
</ul>


<p>如果在Web请求处理过程中抛出一个未处理的异常，服务器将返回一个HTTP 500响应。为了防止这种情况，我们应该用@ResponseStatus注解来注释我们的任何自定义异常。这类异常由HandlerExceptionResolver来解决。</p>

<p>当一个控制器方法抛出我们的异常时，这将导致服务器以指定的状态码返回一个适当的HTTP响应。我们应该记住，我们不应该在其他地方处理我们的异常，这种方法才会有效。</p>

<p>另一种处理异常的方法是使用@ExceptionHandler注解。我们在任何控制器中添加@ExceptionHandler方法，用它们来处理从该控制器中抛出的异常。这些方法可以在没有@ResponseStatus注解的情况下处理异常，将用户重定向到一个专门的错误视图，或者建立一个完全自定义的错误响应。</p>

<p>我们也可以传入与Servlet相关的对象（HttpServletRequest, HttpServletResponse, HttpSession, 和Principal）作为处理方法的参数。但是，我们应该记住，我们不能把模型对象直接作为参数。</p>

<p>处理错误的第三个选择是通过@ControllerAdvice类。它将允许我们应用同样的技术，只是这次是在应用层面，而不仅仅是在特定的控制器上。为了实现这一点，我们需要同时使用@ControllerAdvice和@ExceptionHandler。这样，异常处理程序将处理任何控制器抛出的异常。</p>

<p>关于这个话题的更多详细信息，请浏览<a href="https://www.baeldung.com/exception-handling-for-rest-with-spring">Spring的REST错误处理</a>文章。</p>

<p>译者点评：Spring 官方博客的这篇<a href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc">Exception Handling in Spring MVC</a>，对 Spring MVC 的异常处理介绍的很全面，值得反复研读。</p>

<h1>4. 结论</h1>

<p>在这篇文章中，我们已经探讨了一些Spring MVC相关的问题，这些问题可能会在Spring开发者的技术面试中出现。你应该把这些问题作为进一步研究的起点，因为这绝不是一个详尽的列表。</p>

<p>我们祝愿你在即将到来的面试中有好运气!</p>

<h1>5. 原文</h1>

<ul>
<li><a href="https://www.baeldung.com/spring-mvc-interview-questions">Spring MVC Interview Questions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)常见 Spring 框架面试题]]></title>
    <link href="http://DamianSheldon.github.io/blog/top-spring-framework-interview-questions.html"/>
    <updated>2022-04-11T10:07:29+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/top-spring-framework-interview-questions</id>
    <content type="html"><![CDATA[<h1>1.概述</h1>

<p>在本教程中，我们将看看在求职面试中可能出现的一些最常见的与 Spring 有关的问题。</p>

<h1>2. Spring Core</h1>

<h2>Q1. 什么是 Spring 框架？</h2>

<p>Spring是开发 Java 企业版应用程序最广泛使用的框架。此外，Spring 的核心功能可用于开发任何 Java 应用程序。</p>

<p>我们使用它的扩展功能在 Jakarta EE 平台之上构建各种网络应用。我们也可以在简单的独立应用程序中使用它的依赖注入条款。</p>

<h2>Q2. 使用 Spring 的好处是什么？</h2>

<p>Spring 的目标是使 Jakarta EE的 开发更容易，所以我们来看看它的好处:</p>

<ul>
<li><strong>轻量级</strong>&ndash;在开发中使用该框架的开销很小</li>
<li><strong>反转控制（IoC）</strong>&ndash;Spring 容器负责连接各种对象的依赖关系，而不是创建或寻找依赖对象</li>
<li><strong>面向方面的编程（AOP）</strong>&ndash;Spring支持AOP，将业务逻辑与系统服务分开</li>
<li><strong>IoC容器</strong>&ndash;管理 Spring Bean 的生命周期和项目特定的配置</li>
<li><strong>MVC框架</strong>&ndash;用于创建 Web 应用程序或 RESTful Web服务，能够返回XML/JSON响应</li>
<li><strong>事务管理</strong> &ndash; 通过使用 Java 注解或 Spring Bean 的 XML 配置文件，减少JDBC操作、文件上传等方面的模板代码量</li>
<li><strong>异常处理</strong>&ndash;Spring 提供了一个方便的 API，用于将特定技术的异常转化为未检查的异常</li>
</ul>


<h2>Q3. 您知道哪些 Spring 子项目？简要描述一下吧。</h2>

<ul>
<li><strong>核心</strong>&ndash;提供框架基础部分的关键模块，如 IoC 或 DI</li>
<li><strong>JDBC</strong>&ndash;实现了一个 JDBC 抽象层，不需要为特定的供应商数据库进行 JDBC 编码</li>
<li><strong>ORM 集成</strong> &ndash; 为流行的对象关系映射 API 提供集成层，如 JPA、JDO 和 Hibernate</li>
<li><strong>Web</strong>&ndash;一个面向网络的集成模块，提供多部分文件上传、Servlet监听器和面向网络的应用程序上下文功能</li>
<li><strong>MVC 框架</strong>&ndash;一个实现模型-视图-控制器设计模式的 Web 模块</li>
<li><strong>AOP 模块</strong>&ndash;面向切面的编程实现，允许定义干净的方法拦截器和切点</li>
</ul>


<!--more-->


<h2>Q4. 什么是依赖性注入？</h2>

<p>依赖注入是控制反转（IoC）的一个方面，它是一个一般的概念，即我们不手动创建我们的对象，而是描述它们应该如何被创建。然后IoC容器将在需要时实例化所需的类。</p>

<p>更多细节，请看<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">这里</a>。</p>

<h2>Q5. 我们如何在 Spring 中注入 Bean？</h2>

<p>为了注入Spring Bean，有几个不同的选择。</p>

<ul>
<li>Setter 方法注入</li>
<li>构造器注入</li>
<li>字段注入</li>
</ul>


<p>配置可以使用XML文件或注解来完成。</p>

<p>更多细节，请查看<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">这篇文章</a>。</p>

<h2>Q6. 哪种方式是注入 Bean 的最佳方式，为什么？</h2>

<p>推荐的方法是对强制性的依赖使用构造函数参数，对选择性的依赖使用设置器。这是因为构造函数注入允许向不可变的字段注入值，使测试更容易。</p>

<h2>Q7. BeanFactory 和 ApplicationContext 之间的区别是什么？</h2>

<p>BeanFactory 代表一个提供和管理 Bean 实例的容器接口。默认的实现是在调用 <code>getBean()</code>时懒惰地将 Bean 实例化。</p>

<p>相比之下，ApplicationContext 代表一个容纳了应用程序中元数据和 bean 等所有信息、元数据和bean 的容器接口。它也扩展了 BeanFactory 接口，但默认实现是在应用程序启动时迫切地实例化 Bean。然而，这种行为可以为单个 Bean 重写。</p>

<p>关于所有的区别，请参考<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html">文档</a>。</p>

<p>译者点评：正如它们的名字一样，BeanFactory 是代表它是 Bean 工厂，它的主要功能是像工厂一样生产管理 Bean；ApplicationContext 则表示它是应用上下文，它是 BeanFactory 的子接口，扩展了很多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。</p>

<h2>Q8. 什么是 Spring Bean？</h2>

<p>Spring Bean 是由 Spring IoC 容器初始化的 Java 对象。</p>

<p>译者点评：个人觉得 Spring 官方文档的解释更好:</p>

<blockquote><p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans.</p></blockquote>

<p>在 Spring 中， 那些被 Spring IoC 容器管理并形成应用骨架的对象称为 beans。</p>

<h2>Q9. Spring 框架中默认的 Bean 作用域是什么？</h2>

<p>默认情况下，Spring Bean 被初始化为一个单例。</p>

<h2>Q10. 如何定义一个 Bean 的作用域？</h2>

<p>为了设置Spring Bean的作用域，我们可以使用 <code>@Scope</code> 注解或在 XML 配置文件中使用 <code>"scope"</code> 属性。请注意，有五个支持的作用域。</p>

<ul>
<li>Singleton</li>
<li>Prototype</li>
<li>Request</li>
<li>Session</li>
<li>Global-session</li>
</ul>


<p>关于差异，请看<a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch03s05.html">这里</a>。</p>

<h2>Q11. 单例 bean 是线程安全的吗？</h2>

<p>单例 Bean 不是线程安全的，因为线程安全是关于执行的，而单例是一种专注于创建的设计模式。线程安全只取决于Bean的实现本身。</p>

<h2>Q12. Spring Bean 的生命周期是怎样的？</h2>

<p>首先，Spring Bean 需要根据 Java 或 XML Bean 定义进行实例化。它可能还需要执行一些初始化，使其进入可用状态。之后，当不再需要该 Bean 时，它将被从IoC 容器中删除。</p>

<p>所有初始化方法的整个周期显示在图片中（<a href="http://www.dineshonjava.com/2012/07/bean-lifecycle-and-callbacks.html">来源</a>）。</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2017/06/Spring-Bean-Life-Cycle.jpg" alt="Spring Bean Life Cycle" /></p>

<h2>Q13. 什么是基于 Java 的 Spring 配置？</h2>

<p>它是一种以类型安全的方式配置基于 Spring 的应用程序的方法。它是基于 XML 的配置的替代品。</p>

<p>另外，要把一个项目从 XML 配置迁移到 Java 配置，请参考<a href="https://www.baeldung.com/spring-xml-vs-java-config">这篇文章</a>。</p>

<h2>Q14. 我们可以在一个项目中拥有多个 Spring 配置文件吗？</h2>

<p>是的，在大型项目中，建议拥有多个 Spring 配置以提高可维护性和模块化程度。</p>

<p>我们可以加载多个基于 Java 的配置文件:</p>

<pre><code>@Configuration
@Import({MainConfig.class, SchedulerConfig.class})
public class AppConfig {
</code></pre>

<p>或者我们可以加载一个XML文件，该文件将包含所有其他配置:</p>

<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext("spring-all.xml");
</code></pre>

<p>在这个XML文件中，我们将有以下内容:</p>

<pre><code>&lt;import resource="main.xml"/&gt;
&lt;import resource="scheduler.xml"/&gt;
</code></pre>

<h2>Q15. 什么是 Spring Security？</h2>

<p>Spring Security 是 Spring 框架的一个独立模块，主要是在 Java 应用程序中提供认证和授权方法。它还负责处理大多数常见的安全漏洞，如CSRF攻击。</p>

<p>要在Web应用程序中使用Spring Security，我们可以通过简单的注解 @EnableWebSecurity 来开始。</p>

<p>欲了解更多信息，我们有一系列与<a href="https://www.baeldung.com/security-spring">安全</a>有关的文章。</p>

<h2>Q16. 什么是 Spring Boot？</h2>

<p>Spring Boot 是一个提供了一套预配置框架以减少模板配置的项目。这样，我们就可以用最少的代码来启动和运行一个 Spring 应用程序。</p>

<h2>Q17. 请说出 Spring 框架中使用的一些设计模式？</h2>

<ul>
<li><strong>单例模式</strong>&ndash;单例范围的 bean</li>
<li><strong>工厂模式</strong>&ndash; Bean 工厂类</li>
<li><strong>原型模式</strong>（Prototype Pattern）&ndash;原型作用域的 Bean。</li>
<li><strong>适配器模式</strong>&ndash;Spring Web和Spring MVC</li>
<li><strong>代理模式</strong>&ndash;支持Spring面向切面的编程</li>
<li><strong>模板方法模式</strong>&ndash;JdbcTemplate、HibernateTemplate等。</li>
<li><strong>前端控制器</strong>&ndash;Spring MVC DispatcherServlet</li>
<li><strong>数据访问对象</strong>&ndash;支持Spring DAO</li>
<li><strong>模型视图控制器</strong>&ndash;Spring MVC</li>
</ul>


<p>译者点评：可能按照创建型、结构型和行为模式从 GoF 23 个设计模式中匹配会容易记忆点：</p>

<ul>
<li><p><strong>创建型模式</strong></p>

<ul>
<li>生成器(Builder)</li>
<li>工厂(Factory)</li>
<li>原型(Prototype)</li>
<li>单例(Singleton)</li>
</ul>
</li>
<li><p><strong>结构型模式</strong></p>

<ul>
<li>适配器(Adatper)</li>
<li>组成(Composite)</li>
<li>外观(Facade)</li>
<li>代理(Proxy)</li>
</ul>
</li>
<li><p><strong>行为模式</strong></p>

<ul>
<li>职责链(Chain of responsibility)</li>
<li>迭代器(Iterator)</li>
<li>策略(Strategy)</li>
<li>模板(Template Method)</li>
</ul>
</li>
</ul>


<h2>Q18. 原型作用域是如何工作的？</h2>

<p>原型作用域意味着每次我们需要 Bean 的一个实例时，Spring都会创建一个新的实例并返回它。这与默认的单例作用域不同，在单例作用域中，每个 Spring IoC 容器只实例化一个对象实例。</p>

<h1>3. Spring Web MVC</h1>

<h2>Q19. 如何在 Spring Bean 中获取 ServletContext 和 ServletConfig 对象？</h2>

<p>我们可以通过实现 Spring-aware 的接口来做到这一点。<a href="http://www.buggybread.com/2015/03/spring-framework-list-of-aware.html">这里</a>有完整的列表。</p>

<p>我们也可以在这些 Bean 上使用 @Autowired 注解:</p>

<pre><code>@Autowired
ServletContext servletContext;

@Autowired
ServletConfig servletConfig;
</code></pre>

<h2>Q20. 什么是 Spring MVC 中的控制器？</h2>

<p>简单地说，所有由 DispatcherServlet 处理的请求都会被引导到带有 <code>@Controller</code> 注解的类。每个控制器类都将映射一个或多个请求到方法中，这些方法处理和执行携带输入的请求。</p>

<p>退一步讲，我们建议看一下<a href="https://www.baeldung.com/spring-controllers">典型的Spring MVC架构中的前端控制器</a>的概念。</p>

<p>译者点评：个人觉得原文这题给的答案不是很好，题目是问什么是 Spring MVC 中的控制器，答案应该重点解释是什么，而且说所有由 DispatcherServlet 处理的请求都会被引导到带有 <code>@Controller</code> 注释的类太绝对了，例如 BeanNameUrlHandlerMapping 就支持将 URL 映射到对应名字的 bean。</p>

<p>Spring MVC 中的控制器是处理请求的组件，充当模型-视图-控制器模式中的控制器角色，通常是由 <code>@Controller</code> 的类。</p>

<h2>Q21. <code>@RequestMapping</code> 注解是如何工作的？</h2>

<p><code>@RequestMapping</code> 注解用于将 Web 请求映射到Spring 控制器方法。除了简单的用例之外，我们还可以用它来映射 HTTP 头，用 <code>@PathVariable</code> 来绑定URI的部分内容，以及用 URI 参数和 <code>@RequestParam</code> 注解来工作。</p>

<p>关于 <code>@RequestMapping</code> 的更多细节可以在<a href="https://www.baeldung.com/spring-requestmapping">这里</a>找到。</p>

<p>更多关于 Spring MVC 的问题，请查看我们关于 <a href="https://www.baeldung.com/spring-mvc-interview-questions">Spring MVC 面试问题</a>的文章。</p>

<p>译者点评：个人觉得这个题出得不怎么好，给的答案也有点答非所问。单纯说 <code>@RequestMapping</code> 注解是如何工作的？那答案应该重点说<code>@RequestMapping</code> 注解会将映射请求所需的匹配信息保留到 Java 运行时，出题者更多想考察的应该是 Spring MVC 是如何将请求映射到 <code>@RequestMapping</code> 注解的方法。</p>

<h1>4. Spring Data Access</h1>

<h2>Q22. 什么是 Spring JdbcTemplate 类以及如何使用它？</h2>

<p>Spring JDBC 模板是数据库操作主要的API，我们可以通过它访问我们感兴趣的数据：</p>

<ul>
<li>创建和关闭连接</li>
<li>执行语句和存储过程调用</li>
<li>遍历结果集并返回结果</li>
</ul>


<p>为了使用它，我们需要定义 DataSource 的简单配置：</p>

<pre><code>@Configuration
@ComponentScan("org.baeldung.jdbc")
public class SpringJdbcConfig {
    @Bean
    public DataSource mysqlDataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/springjdbc");
        dataSource.setUsername("guest_user");
        dataSource.setPassword("guest_password");

        return dataSource;
    }
}
</code></pre>

<p>如需进一步解释，请查看<a href="https://www.baeldung.com/spring-jdbc-jdbctemplate">这篇快速文章</a>。</p>

<h2>Q23. 如何在 Spring 中启用事务，其好处是什么？</h2>

<p>有两种不同的方式来配置事务&ndash;使用注解或使用面向切面的编程（AOP）&ndash;每种方式都有其优势。</p>

<p>根据官方文档，以下是使用 Spring Transactions 的好处。</p>

<ul>
<li>在不同的事务API中提供一致的编程模型，如 JTA、JDBC、Hibernate、JPA 和 JDO</li>
<li>支持声明式事务管理</li>
<li>与 JTA 等一些复杂的事务 API 相比，为编程式事务管理提供了更简单的 API</li>
<li>与 Spring 的各种数据访问抽象结合得非常好</li>
</ul>


<h2>Q24. 什么是 Spring DAO？</h2>

<p>Spring 数据访问对象（DAO）是 Spring 为 JDBC、Hibernate 和 JPA 等数据访问技术提供的支持，其工作方式一致且简单。</p>

<p>有一个<a href="https://www.baeldung.com/persistence-with-spring-series/">完整的系列</a>讨论了 Spring 的持久性，提供了一个更深入的解释。</p>

<h2>5. Spring Aspect-Oriented Programming</h2>

<h2>Q25. 什么是面向切面的编程（AOP）？</h2>

<p>切面使跨领域的关注点模块化，如事务管理，它跨越多种类型和对象，在不修改受影响的类的情况下为已有的代码增加额外的行为。</p>

<p>下面是<a href="https://www.baeldung.com/spring-aop-annotation">基于切面的执行时间记录</a>的例子。</p>

<h2>Q26. 什么是AOP中的Aspect、Advice、Pointcut和JoinPoint？</h2>

<ul>
<li>Aspect &ndash; 一个实现交叉关注的类，如事务管理</li>
<li>Advice &ndash;当应用程序运行到与 Pointcut 相匹配的特定 JoinPoint 时被执行的方法</li>
<li>Pointcut &ndash; 一组与 JoinPoint 匹配的正则表达式，以确定是否需要执行 Advice</li>
<li>JoinPoint &ndash; 程序执行过程中的一个点，例如一个方法的执行或一个异常的处理</li>
</ul>


<h2>Q27. 什么是编织？</h2>

<p>根据<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html">官方文档</a>，编织是一个将各个切面与其他应用程序类型或对象联系起来以创建一个增强对象的过程。这可以在编译时、加载时或运行时完成。Spring AOP 和其他纯 Java AOP 框架一样，在运行时执行织入。</p>

<h1>6. 总结</h1>

<p>在这篇长文中，我们已经探讨了一些关于 Spring 技术面试最重要的问题。</p>

<p>我们希望这篇文章能对即将到来的Spring面试有所帮助。祝您好运!</p>

<h1>7. 原文</h1>

<ul>
<li><a href="https://www.baeldung.com/spring-interview-questions">Top Spring Framework Interview Questions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次 docker 网络问题排查]]></title>
    <link href="http://DamianSheldon.github.io/blog/remembering-a-docker-network-issue-troubleshooting.html"/>
    <updated>2021-03-30T14:40:26+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/remembering-a-docker-network-issue-troubleshooting</id>
    <content type="html"><![CDATA[<p>最近在学 docker，虽然很早之前就简单体验过一次，但限于时间没有深入，最近有点空余时间，于是准备深入学习一下。但没想到一开始就遇到了拦路虎，照着官方文档 Get Started 一步一步往下，在构建一个自己的镜像时就遇到了问题，在多容器之间也无法通信，这可愁坏我了，只能硬着头皮来排查问题。</p>

<p>构建镜像时问题表现是牵涉到连接网络的命令会失败，google 一圈之后，找到使用 <code>--network=host</code> 的偏方，成功绕过问题。而多容器之间无法通信却一时措手无策。现在就只有 <code>--network=host</code> 这一个线索，于是就想加上这个参数后有什么区别呢？</p>

<p>在官方文档上搜寻一圈之后我没查到有用信息，于是我想相关的书可能会讲讲 docker 网络这块，在微信读书上找了杨保华、戴王剑和曹亚仑合著的《Docker 技术入门与实战(第3版)》。因为 docker 技术在快速发展，所以书中的命令与当前版本有些许差异，但问题不大，不妨碍理解。这本书有两节专门介绍 docker 网络，于是我便先看了这两节，从这里得到一条重要线索：docker 和宿主机的通信是依靠防火墙转发。<code>--network=host</code> 也验证了这条线索，加上这参数会直接使用宿主机的网络配置，这样 docker 和宿主机的通信就不需要防火墙转发了。</p>

<p>问题现在定位到了防火墙，那么为什么防火墙不转发 docker 的网络数据包呢？是不是哪条防火墙规则没配对？另外我还怀疑是不是我的实践环境有问题？我的实践环境是这样的:物理主机是 macOS，上面安装 virtulbox，使用 virtulbox 创建了一个 CentOS 8 的虚拟机, 虚拟机的网络模式是 NAT。这种情况无疑增加了问题排查的难度，怎么来排查呢？</p>

<p>我先看了一下 virtulbox 的用户手册中的网络模式介绍，NAT 是可以连接到宿主机，而且现在虚拟机是可以访问网络的。如果想快速定位问题，我想还得从网络请求的数据包入手，想办法来跟踪数据包。</p>

<p>于是就来查怎么调试 iptables。查到可以通过 TRACE 和 LOG 来输出日志，看介绍也没看出这俩有什么区别。凭经验觉得 TRACE 好像比 LOG 后出来，看起来也高大上一点，先试着用 TRACE 。Google 了一圈，找到都是 CentOS 6 或 CentOS 7 相关的配置，也只能先将就着用吧。</p>

<p>我先是参考的 <a href="https://www.programmersought.com/article/68601428960/">CentOS implements iptables log output and debugging through raw table</a></p>

<pre><code>$sudo modprobe ipt_LOG
$sudo sysctl net.netfilter.nf_log.2
</code></pre>

<p>输出的结果是 NONE，于是尝试显示设置 <code>sudo sysctl net.netfilter.nf_log.2=ipt_LOG</code></p>

<!--more-->


<p>结果给我报一个 <code>sysctl: setting key "net.netfilter.nf_log.2": No such file or directory</code>, 为什么没有这个 key 呢？于是我查询一下:</p>

<pre><code>$ sudo sysctl -a | grep net.netfilter.nf_log
net.netfilter.nf_log.0 = NONE
net.netfilter.nf_log.1 = NONE
net.netfilter.nf_log.10 = NONE
net.netfilter.nf_log.11 = NONE
net.netfilter.nf_log.12 = NONE
net.netfilter.nf_log.2 = NONE
net.netfilter.nf_log.3 = NONE
net.netfilter.nf_log.4 = NONE
net.netfilter.nf_log.5 = NONE
net.netfilter.nf_log.6 = NONE
net.netfilter.nf_log.7 = NONE
net.netfilter.nf_log.8 = NONE
net.netfilter.nf_log.9 = NONE
net.netfilter.nf_log_all_netns = 0
</code></pre>

<p>明明有这个 key 啊, Google 一圈不得要领。继续搜索, 找到这篇 <a href="https://vocon-it.com/2020/03/30/tracing-iptables-on-centos-cheat-sheet/">Tracing iptables on CentOS – Cheat sheet</a>, 它提到的方法如下:</p>

<pre><code>modprobe nf_log_ipv4
sudo sysctl net.netfilter.nf_log.2=nf_log_ipv4
</code></pre>

<p>因为我对 linux 模块相关命令还是有点了解，知道 <code>modprobe</code> 是用来加载模块， <code>modinfo</code> 可以查看模块的信息,我发现 <code>nf_log_ipv4</code> 这个模块在我的系统中已经加载，所以我就直接尝试 <code>sudo sysctl net.netfilter.nf_log.2=nf_log_ipv4</code>, 得到的仍然是 <code>sysctl: setting key "net.netfilter.nf_log.2": No such file or directory</code>，不得不说这很迷，为什么会一直报这么一个不相关的错误。</p>

<p>没办法，继续搜索, 找到 <a href="https://forums.centos.org/viewtopic.php?t=54411">IPTables. Setting nf_log kernel parameter</a>,它其中提到：</p>

<blockquote><p>I think they split the xt_LOG code in newer kernel versions and you need to modprobe nf_log_ipv4 now and sysctl net.netfilter.nf_log.2=nf_log_ipv4 (assuming you want to trace ipv4 packets)</p></blockquote>

<p>很奇怪，为什么其他人都可以设置，我这里却不行，而且这三篇文章用的方法都类似，不至于啊，google 到的也就这几篇文章，于是我回过头去再次研读第一篇文章，在想要不要试下作者提供 CentOS 7 系列的配置方法，毕竟版本更接近，而且这三篇文章都提到用 <code>nf_log_ipv4</code>, 这时我发现他的方法里 <code>modprobe nf_log_ipv4</code> 之后并不需要设置， <code>net.netfilter.nf_log.2</code> 的值便设置了,于是我也照做，终于配置成功。我觉得这里可能是 CentOS 8 有 bug，因为明明有 key 却设置不上，现在设置成功，也就不管那么多了，继续解决问题要紧。</p>

<p>我到 <code>/etc/rsyslog.conf</code> 中开启内核日志输出：</p>

<pre><code>kern.*                                                 /var/log/messages
</code></pre>

<p>重启日志输出服务 <code>sudo systemctl restart rsyslog.service</code>,往防火墙里添加 TRACE 规则:</p>

<pre><code>sudo iptables -t raw -A OUTPUT     -p tcp -j TRACE
sudo iptables -t raw -A PREROUTING -p tcp -j TRACE
</code></pre>

<p>监视系统日志 <code>sudo tail -f /var/log/messages</code></p>

<p>重启 docker 服务 <code>sudo systemctl restart docker.service</code>, 运行容器 <code>sudo docker run -it busybox</code>, 然后在 busybox 容器中触发网络请求:</p>

<pre><code>cd /tmp/
wget http://www.bing.com/
</code></pre>

<p>系统日志并没有输出， 查看 <code>sudo dmesg</code> 也没有日志输出。真是让挫败啊，没办法，只能退而求其次改用 LOG。</p>

<pre><code># 删除 TRACE 规则
sudo iptable -t raw -D PREROUTING 1
sudo iptable -t raw -D OUTPUT 1

## 添加 LOG 规则
sudo iptables -t raw -A OUTPUT     -p tcp -j LOG --log-level debug
sudo iptables -t raw -A PREROUTING     -p tcp -j LOG --log-level debug
</code></pre>

<p>同样重启日志服务 <code>sudo systemctl restart rsyslog.service</code>, 监视系统日志 <code>sudo tail -f /var/log/messages</code>，重启 docker 服务 <code>sudo systemctl restart docker.service</code>, 运行容器 <code>sudo docker run -it busybox</code>, 然后在 busybox 容器中触发网络请求:</p>

<pre><code>cd /tmp/
wget http://www.bing.com/
</code></pre>

<p>日志是成功输出了，内心着实高兴了一把，但由于我的规则设置太宽泛，输出的太多了，很难找到有用的信息，脑中闪过一个念头，那把规则设置更严格一点不就可以了，搓搓小手，兴奋地实践起来，于是我把规则调整成容器发出的网络数据包：</p>

<pre><code>sudo iptables -t raw -A OUTPUT     -p tcp -s 172.17.0.0/16 -j LOG --log-level debug
sudo iptables -t raw -A PREROUTING     -p tcp -s 172.17.0.0/16 -j LOG --log-level debug
</code></pre>

<p>果然，相关日志输出少多了，只有两条,具体如下:</p>

<pre><code>Mar 29 15:51:46 centos kernel: IN=docker0 OUT= PHYSIN=vethfeab609 MAC=02:42:5d:dd:2d:af:02:42:ac:11:00:02:08:00 SRC=172.17.0.2 DST=222.246.1
29.80 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=30005 DF PROTO=TCP SPT=60366 DPT=80 WINDOW=29200 RES=0x00 SYN URGP=0 
Mar 29 15:51:47 centos kernel: IN=docker0 OUT= PHYSIN=vethfeab609 MAC=02:42:5d:dd:2d:af:02:42:ac:11:00:02:08:00 SRC=172.17.0.2 DST=222.246.1
29.80 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=30006 DF PROTO=TCP SPT=60366 DPT=80 WINDOW=29200 RES=0x00 SYN URGP=0 
</code></pre>

<p>这对解决问题帮助不大，摔！这几乎要击垮我了，但还是心有不甘。于是只能把希望再次寄托给 TRACE，我在 CentOS 8 上直接 <code>man iptables</code>，发现它和网络上找到的 man page 内容确实有些差异, 它的 target 专门独立到 <code>iptables-extensions</code>:</p>

<blockquote><p>iptables  can  use  extended packet matching and target modules.  A list of these is available in the iptables-extensions(8) man‐page.</p></blockquote>

<p>继续 <code>man 8 iptables-extensions</code>，搜索 TRACE, 相关介绍如下:</p>

<blockquote><p>This  target  marks  packets so that the kernel will log every rule which match the packets as those traverse the tables, chains,rules. It can only be used in the raw table.</p>

<p>With iptables-legacy, a logging backend, such as ip(6)t_LOG or nfnetlink_log, must be loaded for this to be visible.  The packets are  logged  with the string prefix: &ldquo;TRACE: tablename:chainname:type:rulenum &rdquo; where type can be &ldquo;rule&rdquo; for plain rule, &ldquo;return&rdquo; for implicit rule at the end of a user defined chain and &ldquo;policy&rdquo; for the policy of the built in chains.</p>

<p>With iptables-nft, the target is translated into nftables' meta nftrace expression. Hence  the  kernel  sends  trace  events  via netlink to userspace where they may be displayed using xtables-monitor &ndash;trace command. For details, refer to xtables-monitor(8).</p></blockquote>

<p>原来配合 <code>iptables-nft</code> 时, 日志是使用  <code>xtables-monitor --trace</code>, 似乎又看到了一丝曙光,于是赶紧删除 LOG 规则，添加 TRACE 规则:</p>

<pre><code># 删除 LOG 规则
sudo iptable -t raw -D PREROUTING 1
sudo iptable -t raw -D OUTPUT 1

# 添加 TRACE 规则
sudo iptables -t raw -A OUTPUT     -p tcp -j TRACE
sudo iptables -t raw -A PREROUTING -p tcp -j TRACE
</code></pre>

<p>准备就绪之后就按前面相关的步骤触发网络请求，果然成功输出日志，而且输出了很多日志，我往屏幕下面翻，最后竟然输出的 &ldquo;Failed to received netlink message: No buffer space available&rdquo;,为什么报错了呢？我尝试 <code>man xtables-monitor</code>,文档上明明说的是： xtables-monitor will run until the user aborts execution, typically by using CTRL-C.我这里为什么报错终止了呢？Google 一圈一无所获，想到之前 LOG 因为规则太宽松输出了很多日志，就想是不是这规则太宽松导致日志太多，缓冲区不够用，赶紧调整 TRACE 规则:</p>

<pre><code># 删除 TRACE 规则
sudo iptable -t raw -D PREROUTING 1
sudo iptable -t raw -D OUTPUT 1

# 添加 TRACE 规则
sudo iptables -t raw -A OUTPUT     -p tcp -s 172.17.0.0/16  -j TRACE
sudo iptables -t raw -A PREROUTING -p tcp -s 172.17.0.0/16 -j TRACE
</code></pre>

<p>这下好了，日志正常输出，也没有报错了。于是仔细查看日志，终于找到： <code>firewalld:filter_FORWARD:rule:0x93:DROP</code>,原来是 firewall 将包丢掉了。可是对 firewall 一点也不熟，先找了一遍 firewall 教程看了一下，但是还不知道怎么在 firewall 中添加规则，要学会添加规则也得花点力气，这时脑海中冒出另一个想法：我何不直接停止 firewall，确认下是不是 firewall 导致的问题。</p>

<pre><code>sudo systemctl stop firewalld.service
sudo systemctl stop docker.service
sudo systemctl start docker.service
sudo docker run -it busybox
</code></pre>

<p>尝试一下,发现可以了，确定确实是 firewall 导致的问题。那么现在是自己研究 firewall 添加规则吗？有点复杂啊，我在想是不是我 docker 版本太低了，检查一下确实比最新的版本要低，新版本可能解决了。在文档也确实找到了对应描述:</p>

<blockquote><p>If you are running Docker version 20.10.0 or higher with firewalld on your system with &ndash;iptables enabled, Docker automatically creates a firewalld zone called docker and inserts all the network interfaces it creates (for example, docker0) into the docker zone to allow seamless networking.</p></blockquote>

<p>于是升级新版本，新版本也确实解决了这个问题，嗯，这下暂时不用研究 firewall 添加规则了。</p>

<p>这次能成功排查 docker 的网络问题还是挺开心的，说实话一开始我是没信心的，毕竟才开始接触 docker，另一方面 linux 网络这块牵涉到的知识非常多，甚至在心里想实在解决不了就算了,直接在 macOS 上来学好了。得到的启发是不管有没有解决问题，首先解决问题的方法要对，方法对了之后还得要坚持；其次是注意自己软件使用的版本，相关的命令参数可能需要查看对应版本的文档去核实；最后是虽然项目的官方文档是入门的不错材料，但很多时候官方文档写得很浅或者对新手不友好，这时候如果觉得项目值得投入时间学习的话，看相关的书籍是一个很好的选择，对系统学习和精进大有禆益。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://www.programmersought.com/article/68601428960/">CentOS implements iptables log output and debugging through raw table</a></li>
<li><a href="https://vocon-it.com/2020/03/30/tracing-iptables-on-centos-cheat-sheet/">Tracing iptables on CentOS – Cheat sheet</a></li>
<li><a href="https://forums.centos.org/viewtopic.php?t=54411">IPTables. Setting nf_log kernel parameter</a></li>
<li><a href="https://stackoverflow.com/questions/37536687/what-is-the-relation-between-docker0-and-eth0">What is the relation between docker0 and eth0?</a></li>
<li><a href="https://serverfault.com/questions/78240/debugging-rules-in-iptables">Debugging rules in Iptables</a></li>
<li><a href="https://unix.stackexchange.com/questions/199966/how-to-configure-centos-7-firewalld-to-allow-docker-containers-free-access-to-th">How to configure Centos 7 firewallD to allow docker containers free access to the host&rsquo;s network ports?</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-8">How To Set Up a Firewall Using firewalld on CentOS 8</a></li>
<li><a href="https://firewalld.org/documentation/howto/enable-and-disable-firewalld.html">Enable and Disable firewalld</a></li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UI 设计与屏幕适配]]></title>
    <link href="http://DamianSheldon.github.io/blog/ui-design-and-screen-adaptation.html"/>
    <updated>2021-03-17T15:12:26+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ui-design-and-screen-adaptation</id>
    <content type="html"><![CDATA[<p>目前移动设备的尺寸很多，所以前端 (iOS, Android, Web, 小程序等)开发需要适配多种尺寸屏幕。在适配时我们可能会有困惑，设计稿通常是 px 来表示尺寸，设备的分辨率也是以 px 来表示，它们之间是一样的吗？还是存在什么关系？iOS 开发者用 point 来表示视图的尺寸； Android 开发者用 dp 来表示视图尺寸； Web 开发者用 px 来表示尺寸？它们和设计稿的 px 是什么关系？设计师应该以什么基准尺寸来设计会有利于屏幕适配？应该输出几套切图？除了切图，设计师还可以做些什么来配合开发者做屏幕适配？要搞清楚这些问题，我们需要翻翻历史了。</p>

<p>Tim Chien 和 Robert Nyman 的这篇 <a href="https://hacks.mozilla.org/2013/09/css-length-explained/">CSS Length Explained</a> 帮了我的大忙，本文就是基于它而写成。</p>

<h2>英寸</h2>

<p>我们经常是用英寸为度量单位来表示手机屏幕尺寸，一英寸相当于2.54厘米或0.0254米。</p>

<h2>设备像素(device pixel)</h2>

<p>计算机屏幕显示事物的单位是像素。显示屏上的单个物理 &ldquo;光点"，能够独立于它的邻居显示出完整的颜色，被称为像素（图片元素）。我们把屏幕上的物理像素称为 "设备像素"。</p>

<h2>DPI, PPI</h2>

<p>DPI 是 dots per inch 的英文缩写，即每英寸点数； PPI 是 pixels per inch 的缩写，即每英寸像素。 它们都用来表示显示像素密度 (Display pixel density)。</p>

<p>计算机屏幕是由大量发光二极管整齐排列构成的集成电路，由于屏幕制造商工艺水平差异，每英寸集成电路上排列的二极管的数量会不一样，屏幕出厂时我们可以从厂商那里得知屏幕的 PPI。</p>

<p>于是我们可以知道:</p>

<pre><code>width or height of one device pixel = 1 / device's DPI  
</code></pre>

<p>例如 MacBook Air(2011) 的 DPI 为 125 ， 所以：</p>

<pre><code>(width or height of one device pixel) = 1/125 inch = 0.008 inch = 0.02032 cm
</code></pre>

<!--more-->


<h2>The CSS pixel (px)</h2>

<p>CSS像素的尺寸大致可以看成是人的肉眼能够舒适地看到的尺寸，不要太小，这样你就得眯着眼睛，也不要大到让你看到像素化。"看得很舒服 &ldquo; 的定义比较笼统，<a href="http://www.w3.org/TR/CSS2/syndata.html%23length-units">W3C CSS规范</a>中给我们一个推荐的参考。</p>

<blockquote><p>The reference pixel is the visual angle of one pixel on a device with a pixel density of 96 DPI and a distance from the reader of an arm’s length.</p></blockquote>

<h2>The viewing distance</h2>

<p>如前所述，观看距离因人而异，因设备而异，这就是为什么我们必须将设备按外形因素分类的原因。推荐的参考观看距离(&ldquo;一臂之长&rdquo;)和参考像素密度(&ldquo;96 DPI&rdquo;)其实是历史数据。</p>

<p>对于21世纪的日常设备，我们有不同的参考建议:</p>

<table>
<thead>
<tr>
<th> Device </th>
<th> Baseline pixel density </th>
<th> Width/height of one CSS pixel </th>
<th> Viewing distance</th>
</tr>
</thead>
<tbody>
<tr>
<td> A 20th century PC with CRT display </td>
<td> 96 DPI </td>
<td> ~0.2646 mm (1/96in) </td>
<td> 28 in (71.12cm) </td>
</tr>
<tr>
<td> Modern laptop with LCD </td>
<td> 125 DPI </td>
<td> 0.2032 mm (1/125in) </td>
<td> 21.5 in (54.61cm)</td>
</tr>
<tr>
<td> Smartphones/Tablets </td>
<td> 160 DPI </td>
<td> ~0.159mm (1/160 in) </td>
<td> 16.8in (42.672cm) </td>
</tr>
</tbody>
</table>


<p>因此，我们在 CSS 的世界里建立了一个基本的事实：一个 CSS 像素会以不同的物理尺寸显示，但它总是以正确的尺寸显示，让浏览者感到舒适。</p>

<h2>Device pixel ratio (DPPX)</h2>

<p>随着我们步入未来，现在很多智能手机在出厂时都采用了高密度的显示屏。为了保证 CSS 像素在每一个访问网络的设备(即一切有屏幕和网络连接的设备)上的尺寸一致，设备制造商不得不将多个设备像素映射到一个 CSS 像素上，以弥补它相对更大的物理尺寸。CSS 像素相对于设备像素的尺寸比就是设备像素比(DPPX)。</p>

<p>我们以 iPhone 4 为最著名的例子。它配备了一块 326 DPI 的显示屏。根据我们上面的表格，作为一款智能手机，它的典型观看距离是 16.8 英寸，它的基准像素密度是 160DPI。为了创建一个 CSS 像素，苹果选择将设备像素比设置为 2，这就等于让 iOS Safari 显示网页的方式和 163 DPI 手机上一样。</p>

<p>在我们继续之前，先回头看看上面的数字。其实我们可以做得更好，不把设备像素比设置为2，而是设置为<code>326/160=2.0375</code>，让一个 CSS 像素与参考尺寸相比完全一样。不幸的是，这样的比例会导致一个意想不到的结果：由于每个 CSS 像素并不是由整个设备像素来显示的，所以浏览器不得不对所有的位图图像、边框等进行反锯齿，因为它们几乎总是被当作整个 CSS 像素来显示。浏览器很难利用2.0375个设备像素来绘制你的1个CSS像素宽的边框：如果比例是简单的2，那就容易多了。</p>

<p>顺带一提，163 DPI恰好是上一代 iPhone 的像素密度，所以网页的工作方式也是一样的，不需要开发者对自己的网站进行任何特殊的"升级"。</p>

<p>设备制造商通常选择1.5，或2，或其他整数作为 DPPX 值。偶尔，有些设备决定不这么玩了，发货时使用1.325 DPPX这样的值；作为开发者，我们也许应该忽略这些设备。</p>

<p>现在我们就比较清楚 CSS pixel 和 device pixel 的关系了。接下来我们看下 iOS 的 point 和 device pixel 的关系。</p>

<h2>point</h2>

<blockquote><p>The coordinate system iOS uses to place content onscreen is based on measurements in points, which map to pixels in the display. A standard-resolution display has a <code>1:1</code> pixel density (or <code>@1x</code>), where one pixel is equal to one point. High-resolution displays have a higher pixel density, offering a scale factor of 2.0 or 3.0 (referred to as <code>@2x</code> and <code>@3x</code>). As a result, high-resolution displays demand images with more pixels.</p></blockquote>

<p>从 Apple 这段描述可知， scale factor (<code>@1x</code>, <code>@2x</code> 和 <code>@3x</code>) 就是我们上面据说的设备像素比（DPPX)。point 和 css pixel 是对应的。</p>

<h2>dp</h2>

<p>那 dp 和 device pixel 又是什么关系呢？</p>

<blockquote><p>To preserve the visible size of your UI on screens with different densities, you must design your UI using density-independent pixels (dp) as your unit of measurement. One dp is a virtual pixel unit that&rsquo;s roughly equal to one pixel on a medium-density screen (160dpi; the &ldquo;baseline&rdquo; density). Android translates this value to the appropriate number of real pixels for each other density.</p></blockquote>

<p>Google 这段描述更加直接，dp 是一个虚拟的像素单位，大致相当于中密度屏幕上的一个像素(160dpi;&ldquo;基线"密度)，所以 dp 和 css pixel 也是对应的。而 xhdpi, xxhdpi 和 xxxhdpi 是表示设备像素比(DPPX)2、3 和 4。</p>

<p>现在我们还剩下设计稿的 px。我们回忆一下在前端开发时，如果我们不指定图片尺寸而直接去显示设计师的切图，这时图片是有一个固有尺寸的，在设备像素比为1的设备上，这个固有尺寸就是图片的尺寸，而在设备像素比为2上尺寸是图片的尺寸除以2，所以设计稿的 px是对应设备像素(device pixel)的，这也是为什么我们需要提供多套图片来做适配。假设我们不提供多套图片，现在我们有一个 <code>100 x 100 css pixel</code>的图片， 在设备像素比为3的设备上也会去加载 <code>100 x 100 device pixel</code> 尺寸的资源图，按上面的分析，实际它应该加载 <code>300 x 300 device pixel</code> 尺寸的资源图，那么相当于资源图上一个像素点会对应显示三个设备像素点，这样可能会出现模糊或锯齿的情况。</p>

<p>理清了各平台尺寸单位的关系以及它们与设备像素的关系后，我们来看下设备尺寸。</p>

<h2>设备尺寸</h2>

<p>我们先看下 iOS 设备尺寸分布:</p>

<table>
<thead>
<tr>
<th> 型号 </th>
<th> points </th>
<th> 物理像素 </th>
<th style="text-align:center;"> 设备像素比(DPPX) </th>
</tr>
</thead>
<tbody>
<tr>
<td> 2G,3G,3GS </td>
<td> 320 x 480 </td>
<td> 320 x 480</td>
<td style="text-align:center;"> 1 </td>
</tr>
<tr>
<td> 4,4S </td>
<td> 320 x 480 </td>
<td> 640 x 960 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 5,5C,5S,SE </td>
<td> 320 x 568 </td>
<td> 640 x 1136 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 6,6S,7,8,SE2</td>
<td> 375 x 667 </td>
<td> 750 x 1334 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 6+,6S+,7+,8+ </td>
<td> 414 x 736 </td>
<td> 1080 x 1920 </td>
<td style="text-align:center;"> 3 </td>
</tr>
<tr>
<td> 11Pro,X,Xs </td>
<td> 375 x 812 </td>
<td> 1125 x 2436 </td>
<td style="text-align:center;"> 3 </td>
</tr>
<tr>
<td> 11, Xr </td>
<td> 414 x 896 </td>
<td> 828 x 1792 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 11Pro Max,Xs Max </td>
<td> 414 x 896 </td>
<td> 1242 x 2688 </td>
<td style="text-align:center;"> 3 </td>
</tr>
</tbody>
</table>


<p>对于 iOS 来说，现在的主流设备应该是从 <code>6,6S,7,8,SE2</code> 开始，对应的设备像素是<code>750 x 1334 px</code>。</p>

<p>再来看下 android 这边， Google 有一个 <a href="https://developer.android.com/about/dashboards/index.html#Screens">Screen sizes and densities</a> 统计表，本文写作时查询的结果如下:</p>

<table>
<thead>
<tr>
<th> </th>
<th> ldpi </th>
<th> mdpi </th>
<th> tvdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> Total </th>
</tr>
</thead>
<tbody>
<tr>
<td> Small </td>
<td> 0.1% </td>
<td>  </td>
<td>  </td>
<td> </td>
<td> 0.1% </td>
<td>  </td>
<td> 0.2% </td>
</tr>
<tr>
<td> Normal </td>
<td>  </td>
<td> 0.3% </td>
<td> 0.3% </td>
<td> 14.8% </td>
<td> 41.3% </td>
<td> 26.1% </td>
<td> 82.8% </td>
</tr>
<tr>
<td> Large </td>
<td>  </td>
<td> 1.7% </td>
<td> 2.2% </td>
<td> 0.8% </td>
<td> 3.2% </td>
<td> 2.0% </td>
<td> 9.9%  </td>
</tr>
<tr>
<td> Xlarge </td>
<td>  </td>
<td> 4.2% </td>
<td> 0.2% </td>
<td> 2.3% </td>
<td> 0.4% </td>
<td>  </td>
<td> 7.1% </td>
</tr>
<tr>
<td> Total </td>
<td> 0.1% </td>
<td> 6.2% </td>
<td> 2.7% </td>
<td>  17.9% </td>
<td> 45.0% </td>
<td> 28.1% </td>
<td>  </td>
</tr>
</tbody>
</table>


<p><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#ScreenSizeQualifier">Small,Normal,Large 和 Xlarge</a> 是屏幕的尺寸分类，具体含义如下:</p>

<blockquote><ul>
<li><p>small: Screens that are of similar size to a low-density QVGA screen. The minimum layout size for a small screen is approximately 320x426 dp units. Examples are QVGA low-density and VGA high density.</p></li>
<li><p>normal: Screens that are of similar size to a medium-density HVGA screen. The minimum layout size for a normal screen is approximately 320x470 dp units. Examples of such screens a WQVGA low-density, HVGA medium-density, WVGA high-density.</p></li>
<li><p>large: Screens that are of similar size to a medium-density VGA screen. The minimum layout size for a large screen is approximately 480x640 dp units. Examples are VGA and WVGA medium-density screens.</p></li>
<li><p>xlarge: Screens that are considerably larger than the traditional medium-density HVGA screen. The minimum layout size for an xlarge screen is approximately 720x960 dp units. In most cases, devices with extra-large screens would be too large to carry in a pocket and would most likely be tablet-style devices. Added in API level 9.</p></li>
</ul>
</blockquote>

<p>从上表的数据可知，目前 android 设备的主流尺寸分布是从 normal-hdpi 这个分类开始，根据 google 对 normal 的解释，它的大小相当于 medium-density HVGA 屏幕上的 <code>320x470 dp</code>，换算成设备像素就是 <code>480x705 px</code>，注意如果我们以这个尺寸去设计的话，那么得到的切图就是对应 hdpi(1.5)，要输出xhdpi(2) 的切图则要放大 1.3333 倍，这就有点不方便了，很容易得到奇数的像素尺寸，所以我们将 <code>480x705 px</code> 换算到 xhdpi(2) 的设备像素，得到 <code>640x940 px</code>。</p>

<p>我们知道宽屏比窄屏能显示更多内容，如果我们以宽屏为其准尺寸设计，那么在窄屏上就可能出现控件放不下、文字截断的情况。反过来，如果我们以窄屏为基准设计，那么在宽屏上布局时会容易处理，控件的宽度增加或者间隔增加就可以了。高度和宽度存在同样的问题，所以也应该选高度小的作为基准。设计时扣除固定元素高度之和后分配给可滚动区域，这样方便界面的元素布局能够动态响应，开发更好做屏幕适配。</p>

<p>所以选择基准尺寸和我们想支持的设备紧密相关，这需要基于多方面的因素考虑。 例如，如果我们希望支持尽可能多的设备，就越有可能获取更多用户，但开发的兼容工作量就相应增加，很多新特性就可能不适合作为应用的主要功能，而只适合作为增强功能。通常可以考虑覆盖 90% 以上，团队资金和人员比较充足的话可以考虑覆盖 95%，98% 甚至更多。</p>

<p>以覆盖 90% 以上为例，如果我们同时支持 iOS 和 android，或只支持 android 时，应该选 <code>640x940 px</code>作为基准尺寸，而如果只支持 iOS ， 我们应该选 <code>750 x 1334 px</code> 作为基准尺寸。</p>

<p>iOS 的设备像素比主要分布在2和3，而 android 这边设备像素比主要分布在 1.5(hdpi), 2(xhdpi)和 3(xxhdpi)，所以 iOS 需要输出<code>@2x</code> 和 <code>@3x</code> 两套切图； android 需要输出 hdpi, xhdpi 和 xxhdpi 三套切图。</p>

<h2>总结</h2>

<p>现在我们知道，设计基准尺寸的选择以及切图的输出是和我们想支持的设备紧密相关，写作本文时：</p>

<h3>基准尺寸</h3>

<ul>
<li>仅支持 iOS ， 应该选 <code>750 x 1334 px</code> 作为基准尺寸，对应的设备像素比是2</li>
<li>仅支持 android 时，应该选 <code>640x940 px</code> 作为基准尺寸，对应的设备像素比是2</li>
<li>支持 iOS 和 android，应该选 <code>640x940 px</code> 作为基准尺寸，对应的设备像素比是2</li>
</ul>


<h3>切图</h3>

<ul>
<li>支持 iOS 需要输出<code>@2x</code> 和 <code>@3x</code> 两套切图</li>
<li>支持 android 需要输出 hdpi, xhdpi 和 xxhdpi 三套切图</li>
</ul>


<p>基准尺寸对应的切图是 <code>@2x</code> 和 xhdpi，输出 hdpi(1.5) 则是切图缩小 0.75, <code>@3x</code> 和 xxhdpi(3) 则是切图放大 1.5 。</p>

<p>我们需要需要注意，随着设备的更新换代，我们的基准尺寸和切图会发生变化，就像以前我们可能需要为 android 提供 mdpi 的切图。</p>

<p>另外想说一下，设计师在设计之初就要把屏幕适配这事放在心上，将界面的元素看成水流一样，尽量让它们能自由流动，这样开发者就能更好地也更容易地做屏幕适配。Apple 在屏幕适配这块提出了 auto layout 的解决方案，这是一个设计师视角的解决方案，也是我们日常的生活中的视角，用界面元素的之间的约束来表达布局，推荐设计师用约束这种方式去做设计并最终输出。可以看到 google 实际上也很认可 auto layout 用约束来布局的想法，在新版本的 android 开发中默认的根布局容器就是 ConstraintLayout，它就是用约束来表达布局。最后我们再看 web 开发布局这边，css 布局的核心就是流，为支持屏幕适配，目前的主流方案是响应式布局，而这种布局的核心我认为仍然是约束。可以看到在屏幕适配这块，各平台最终的想法其实是一样的。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://hacks.mozilla.org/2013/09/css-length-explained/">CSS Length Explained</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution</a></li>
<li><a href="https://developer.android.google.cn/training/multiscreen/screendensities">Support different pixel densities</a></li>
<li><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#ScreenSizeQualifier">ScreenSizeQualifier</a></li>
<li><a href="https://developer.android.google.cn/training/multiscreen/screensizes">Support different screen sizes</a></li>
<li><a href="https://developer.android.com/about/dashboards/index.html#Screens">Screen sizes and densities</a></li>
<li><a href="https://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions">The Ultimate Guide To iPhone Resolutions</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
