
<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="utf-8">
        <title>Spring MVC Interview Questions  | Hello World</title>

        <meta name="author" content="Sheldon"> 
        
        <meta name="description" content="Spring MVC Interview Questions"> <meta name="keywords" content="Spring, Spring MVC, interview">

        <meta name="viewport" content="width=device-width">
        
        
        <link rel="canonical" href="http://DamianSheldon.github.io/blog/spring-mvc-interview-questions.html">

        <link href="/atom.xml" rel="alternate" title="Hello World" type="application/atom+xml">
        <link href="/favicon.png" rel="icon">
        <link href="/stylesheets/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
        
        <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
        <script src="/javascripts/navigation-toggle.js" type="text/javascript"></script>
        
    </head>



<body>
	<header id="header" class="inner"><h1><a href="/">Hello World</a></h1>
<h4>Here's where it all happens for me.</h4>

<!-- Navigation -->

<nav role="navigation">
    <div class="inner">
        <a href="#nav" class="nav-collapse" id="nav-collapse">Navigation</a>
        <ul class="nav" id="nav">
    <li class="active"><a href="/">Blog</a></li>
    <li><a href="/archives">Archive</a></li>
    <li><a href="/ios-development">iOS</a></li>
    <li><a href="/android">Android</a></li>
    <li><a href="/web-development">Web</a></li>
    <li><a href="/english">English</a></li>
    <li><a href="/about">About</a></li>
    
    <form action="https://www.bing.com/search" method="get" accept-charset="utf-8" target="_blank">
        <input type="text" name="q" maxlength="255" placeholder="Search">
        <input type="hidden" name="q1" value="site:DamianSheldon.github.io">
    </form>
</ul>
    </div>
</nav>

<a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a>
</header>

	<div id="content" class="inner"><article class="post">
	<h2 class="title">Spring MVC Interview Questions</h2>
        
    <div class="meta">
	   <div class="date">









  



<time datetime="2022-04-12T11:42:30+08:00" pubdate data-updated="true">12 Apr 2022</time></div>
	   

<div class="tags">

	<a class='category' href='/blog/categories/archives/'>archives</a>, <a class='category' href='/blog/categories/web-development/'>web development</a>

</div>


    </div>
    
	<div class="entry-content"><h1>1. 简介</h1>

<p>Spring MVC是Spring公司在Servlet API基础上建立的原创Web框架。它提供了模型-视图-控制器架构，可用于开发灵活的Web应用。</p>

<p>在本教程中，我们将重点讨论与之相关的问题，因为它经常是Spring开发者求职面试的一个话题。</p>

<p>关于Spring框架的更多问题，你可以查看我们<a href="https://www.baeldung.com/tag/interview/">面试问题系列</a>中另一篇与<a href="https://www.baeldung.com/spring-interview-questions">Spring有关的文章</a>。</p>

<h1>2.基础 Spring MVC 题</h1>

<h2>Q1. 为什么我们要使用Spring MVC？</h2>

<p>Spring MVC实现了清晰的关注点分离，使我们能够轻松开发和单元测试我们的应用程序。</p>

<p>像如下概念：</p>

<ul>
<li>Dispatcher Servlet</li>
<li>Controllers</li>
<li>View Resolvers</li>
<li>Views, Models</li>
<li>ModelAndView</li>
<li>Model and Session Attributes</li>
</ul>


<p>是完全相互独立的，它们只负责一件事。</p>

<p>因此，MVC给了我们相当大的灵活性。它是基于接口的（有提供的实现类），我们可以通过使用自定义接口来配置框架的每一部分。</p>

<p>另一件重要的事情是，我们并没有被束缚在一个特定的视图技术上（例如JSP），而是可以选择我们最喜欢的技术。</p>

<p>另外，我们不只在Web应用开发中使用Spring MVC，在创建RESTful Web服务时也是如此。</p>

<!--more-->


<h2>Q2. <code>@Autowired</code>注解的作用是什么？</h2>

<p><code>@Autowired</code>注解可以与字段或方法一起使用，用于按类型注入Bean。这个注解允许Spring解析并将协作Bean注入你的Bean中。</p>

<p>更多细节，请参考关于<a href="https://www.baeldung.com/spring-autowire"><code>@Autowired</code> in Spring</a>的教程。</p>

<h2>Q3. 解释一下模型属性</h2>

<p><code>@ModelAttribute</code>注解是Spring MVC中最重要的注解之一。它将一个方法参数或方法返回值绑定到一个命名的模型属性上，然后将其暴露给Web视图。</p>

<p>如果我们在方法层面使用它，它表明该方法的目的是添加一个或多个模型属性。</p>

<p>另一方面，当作为方法参数使用时，它表示该参数应该从模型中获取。当不存在时，我们应该首先将其实例化，然后将其添加到模型中。一旦出现在模型中，我们应该从所有具有匹配名称的请求参数中填充参数字段。</p>

<p>关于这个注解的更多信息可以在我们与<a href="https://www.baeldung.com/spring-mvc-and-the-modelattribute-annotation"><code>@ModelAttribute</code>注解有关的文章</a>中找到。</p>

<h2>Q4. 解释一下@Controller和@RestController之间的区别？</h2>

<p><code>@Controller</code>和<code>@RestController</code>注释的主要区别在于，<code>@RestController</code>注释会自动包含<code>@ResponseBody</code>。这意味着我们不需要用<code>@ResponseBody</code>来注释我们的处理方法。如果我们想直接在HTTP响应体中写入响应类型，在<code>@Controller</code>类中需要这样做。</p>

<h2>Q5. 描述一下PathVariable</h2>

<p>我们可以使用<code>@PathVariable</code>注解作为处理方法参数，来提取URI模板变量的值。</p>

<p>例如，如果我们想从<code>www.mysite.com/user/123</code>，通过id获取一个用户，我们应该把控制器中的方法映射为<code>/user/{id}</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/user/{id}")
</span><span class='line'>public String handleRequest(@PathVariable("id") String userId, Model map) {}</span></code></pre></td></tr></table></div></figure>


<p>@PathVariable只有一个名为value的元素。它是可选的，我们用它来定义URI模板变量的名称。如果我们省略value元素，那么URI模板变量的名称必须与方法参数名称相匹配。</p>

<p>也允许有多个@PathVariable注解，可以通过一个接一个地声明它们:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/user/{userId}/name/{userName}")
</span><span class='line'>public String handleRequest(@PathVariable String userId,
</span><span class='line'>  @PathVariable String userName, Model map) {}</span></code></pre></td></tr></table></div></figure>


<p>或将它们全部放在一个<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>中:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/user/{userId}/name/{userName}")
</span><span class='line'>public String handleRequest(@PathVariable Map&lt;String, String&gt; varsMap, Model map) {}</span></code></pre></td></tr></table></div></figure>


<h2>Q6. 使用Spring MVC进行验证</h2>

<p>Spring MVC默认支持JSR-303规范。我们需要在我们的Spring MVC应用中添加JSR-303及其实现的依赖性。例如，Hibernate Validator就是我们可以使用的JSR-303的实现之一。</p>

<p>JSR-303是用于bean验证的Java API规范，是Jakarta EE和JavaSE的一部分，它使用<code>@NotNull</code>、<code>@Min</code>和<code>@Max</code>等注解，确保bean的属性满足特定的标准。关于验证的更多信息，请参见<a href="https://www.baeldung.com/javax-validation">Java Bean验证基础知识</a>一文。</p>

<p>Spring提供了<code>@Validator</code>注解和BindingResult类。当我们有无效的数据时，Validator实现将在控制器的请求处理方法中触发错误。然后我们可以使用BindingResult类来获取这些错误。</p>

<p>除了使用现有的实现，我们还可以制作自己的实现。要做到这一点，我们首先创建一个符合JSR-303规范的注解。然后，我们实现Validator类。另一种方法是实现Spring的Validator接口，并通过控制器类中的<code>@InitBinder</code>注解将其设置为验证器。</p>

<p>要查看如何实现和使用你自己的验证器，请看关于<a href="https://www.baeldung.com/spring-mvc-custom-validator">Spring MVC中自定义验证</a>的教程。</p>

<h2>Q7. 什么是<code>@RequestBody</code>和<code>@ResponseBody</code>注解？</h2>

<p><code>@RequestBody</code>注解，作为处理方法参数使用，将HTTP请求主体与传输或域对象绑定。Spring使用Http消息转换器自动将传入的HTTP请求反序列化为Java对象。</p>

<p>当我们在Spring MVC控制器中的处理方法上使用<code>@ResponseBody</code>注解时，它表明我们将把该方法的返回类型直接写入HTTP响应体中。我们不会把它放在Model中，Spring也不会把它解释为视图名称。</p>

<p>请查看关于<a href="https://www.baeldung.com/spring-request-response-body"><code>@RequestBody</code>和<code>@ResponseBody</code></a>的文章，了解关于这些注解的更多细节。</p>

<h2>Q8. 解释一下Model、ModelMap和ModelAndView？</h2>

<p>Model接口定义了一个模型属性的持有人。ModelMap也有类似的目的，它能够传递一个值的集合。然后，它把这些值当作是在一个Map内。我们应该注意，在模型（ModelMap）中我们只能存储数据。我们把数据放进去并返回一个视图名称。</p>

<p>另一方面，在ModelAndView中，我们返回对象本身。我们把所有需要的信息，比如数据和视图名称，都设置在我们要返回的对象中。</p>

<p>你可以在关于<a href="https://www.baeldung.com/spring-mvc-model-model-map-model-view">Model、ModelMap和ModelView</a>的文章中找到更多细节。</p>

<h2>Q9. 解释SessionAttributes和SessionAttribute</h2>

<p><code>@SessionAttributes</code>注解是用来在用户会话中存储模型属性的。我们在控制器类中使用它，如我们关于Spring MVC中的会话属性的文章中所示:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/sessionattributes")
</span><span class='line'>@SessionAttributes("todos")
</span><span class='line'>public class TodoControllerWithSessionAttributes {
</span><span class='line'>
</span><span class='line'>    @GetMapping("/form")
</span><span class='line'>    public String showForm(Model model,
</span><span class='line'>      @ModelAttribute("todos") TodoList todos) {
</span><span class='line'>        // method body
</span><span class='line'>        return "sessionattributesform";
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // other methods
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在前面的例子中，如果<code>@ModelAttribute</code>和<code>@SessionAttributes</code>有相同的名称属性，模型属性 &ldquo;todos "将被添加到会话中。</p>

<p>如果我们想从一个全局管理的会话中获取现有的属性，我们将使用<code>@SessionAttribute</code>注解作为方法参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@GetMapping
</span><span class='line'>public String getTodos(@SessionAttribute("todos") TodoList todos) {
</span><span class='line'>    // method body
</span><span class='line'>    return "todoView";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>Q10. <code>@EnableWebMVC</code>的目的是什么？</h2>

<p><code>@EnableWebMvc</code>注解的目的是通过Java配置启用Spring MVC。它等同于XML配置中的<code>&lt;mvc: annotation-driven&gt;</code>。这个注解从WebMvcConfigurationSupport导入Spring MVC配置。它能够支持<code>@Controller</code>注解的类，这些类使用<code>@RequestMapping</code>将传入的请求映射到处理方法。</p>

<p>你可以在我们的<a href="https://www.baeldung.com/spring-enable-annotations">Spring <code>@Enable</code>注解指南</a>中了解更多关于这个和类似注解的信息。</p>

<h2>Q11. 什么是Spring中的ViewResolver？</h2>

<p>ViewResolver通过将视图名称映射到实际视图，使应用程序能够在浏览器中渲染模型，这样无需将实现与特定的视图技术联系起来。</p>

<p>关于ViewResolver的更多细节，请看我们的<a href="https://www.baeldung.com/spring-mvc-view-resolver-tutorial">Spring MVC中的ViewResolver指南</a>。</p>

<h2>Q12. 什么是BindingResult？</h2>

<p>BindingResult是<code>org.springframework.validation</code>包中的一个接口，表示绑定结果。我们可以用它来检测和报告提交表单中的错误。它很容易被调用&ndash;我们只需要确保把它作为一个参数放在我们要验证的表单对象之后。可选的Model参数应该在BindingResult之后，这在<a href="https://www.baeldung.com/spring-mvc-custom-validator">自定义验证器教程</a>中可以看到:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@PostMapping("/user")
</span><span class='line'>public String submitForm(@Valid NewUserForm newUserForm, 
</span><span class='line'>  BindingResult result, Model model) {
</span><span class='line'>    if (result.hasErrors()) {
</span><span class='line'>        return "userHome";
</span><span class='line'>    }
</span><span class='line'>    model.addAttribute("message", "Valid form");
</span><span class='line'>    return "userHome";
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当Spring看到<code>@Valid</code>注解时，它首先会尝试为被验证的对象找到验证器。然后，它将拾起验证注解并调用验证器。最后，它将把发现的错误放在BindingResult中，并把后者添加到视图模型中。</p>

<h2>Q13. 什么是表单后备对象？</h2>

<p>表单后备对象或命令对象只是一个POJO，它从我们要提交的表单中收集数据。</p>

<p>我们应该记住，它不包含任何逻辑，只包含数据。</p>

<p>要了解如何在Spring MVC中使用表单支持对象，请看我们关于<a href="https://www.baeldung.com/spring-mvc-form-tutorial">Spring MVC中表单</a>的文章。</p>

<h2>Q14.<code>@Qualifier</code>注解的作用是什么？</h2>

<p>它与<code>@Autowired</code>注解同时使用，以避免一个bean类型的多个实例出现时的混淆。</p>

<p>让我们看一个例子。我们在XML配置中声明了两个类似的Bean:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;bean id="person1" class="com.baeldung.Person" &gt;
</span><span class='line'>    &lt;property name="name" value="Joe" /&gt;
</span><span class='line'>&lt;/bean&gt;
</span><span class='line'>&lt;bean id="person2" class="com.baeldung.Person" &gt;
</span><span class='line'>    &lt;property name="name" value="Doe" /&gt;
</span><span class='line'>&lt;/bean&gt;</span></code></pre></td></tr></table></div></figure>


<p>当我们试图连接Bean时，我们会得到一个<code>org.springframework.beans.factory.NoSuchBeanDefinitionException</code>。为了解决这个问题，我们需要使用<code>@Qualifier</code>来告诉Spring关于哪个Bean应该被连接:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Autowired
</span><span class='line'>@Qualifier("person1")
</span><span class='line'>private Person person;</span></code></pre></td></tr></table></div></figure>


<h2>Q15. <code>@Required</code>注解的作用是什么？</h2>

<p><code>@Required</code>注解用于setter方法，它表示在配置时必须填充具有该注解的bean属性。否则，Spring容器将抛出一个BeanInitializationException异常。</p>

<p>另外，<code>@Required</code>与<code>@Autowired</code>不同&ndash;因为它只限于 setter ，而<code>@Autowired</code>则不是。<code>@Autowired</code>也可以用来与构造函数和字段进行连接，而<code>@Required</code>只检查该属性是否被设置。</p>

<p>让我们看一个例子:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class Person {
</span><span class='line'>    private String name;
</span><span class='line'> 
</span><span class='line'>    @Required
</span><span class='line'>    public void setName(String name) {
</span><span class='line'>        this.name = name;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在，Person Bean的名字需要像这样在XML配置中设置:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;bean id="person" class="com.baeldung.Person"&gt;
</span><span class='line'>    &lt;property name="name" value="Joe" /&gt;
</span><span class='line'>&lt;/bean&gt;</span></code></pre></td></tr></table></div></figure>


<p>请注意，<code>@Required</code>默认情况下不能与基于Java的<code>@Configuration</code>类一起工作。如果你需要确保所有的属性都被设置，你可以在<code>@Bean</code>注解的方法中创建Bean时这样做。</p>

<p>译者点评：<code>@Required</code> 是如何实现的？</p>

<h2>Q16. 描述一下前台控制器模式</h2>

<p>在前端控制器模式中，所有的请求将首先进入前端控制器，而不是Servlet。它将确保响应已经准备好，并将它们送回给浏览器。这样，我们就有一个地方可以控制来自外部世界的一切。</p>

<p>前端控制器将识别应该首先处理请求的Servlet。然后，当它从servlet那里得到数据后，它将决定渲染哪个视图，最后，它将把渲染好的视图作为一个响应发送回去：</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2018/12/front_end_controller.png" alt="Front end controller" /></p>

<p>要查看实现细节，请查看我们的<a href="https://www.baeldung.com/java-front-controller-pattern">Java中的前端控制器模式指南</a>。</p>

<h2>Q17. 什么是 Model1和Model2的架构？</h2>

<p> Model1和Model2代表了在设计Java Web应用时经常使用的两种设计模式。</p>

<p>在Model1中，一个请求被送到一个servlet或JSP那里进行处理。Servlet或JSP处理请求，处理业务逻辑，检索和验证数据，并生成响应:</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2018/12/Model_1-1.png" alt="Model 1" /></p>

<p>由于这种架构很容易实现，我们通常在小型和简单的应用程序中使用它。</p>

<p>另一方面，它对于大规模的网络应用并不方便。这些功能通常在JSP中重复使用，其中业务和表现逻辑是耦合的。</p>

<p>Model2是基于模型-视图-控制器设计模式的，它将视图与操作内容的逻辑分开。</p>

<p>此外，我们可以区分MVC模式中的三个模块：模型、视图和控制器。模型代表一个应用程序的动态数据结构。它负责数据和业务逻辑的操作。视图负责显示数据，而控制器作为前两者之间的接口。</p>

<p>在Model2中，一个请求被传递给控制器，控制器处理所需的逻辑，以便获得应该显示的正确内容。然后，控制器将内容放回请求中，通常是作为一个JavaBean或POJO。它还决定哪个视图应该渲染内容，最后将请求传递给它。然后，视图就会渲染数据:</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2018/12/Model_2.png" alt="Model 2" /></p>
</div>


        
</article>

	<div class="share">
	<div>
	
	
	
    
    
        

    
    
	</div>
</div>


</div>
	<footer id="footer" class="inner">Copyright &copy; 2014 - 2022

    Sheldon

<br>
<p>Powered by <a href="http://octopress.org">Octopress</p>
</footer>
	



<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-52345084-1');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




</body>
</html>
