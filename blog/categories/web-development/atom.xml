<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/web-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2022-11-07T10:40:19+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MyBatis 的工作流程(一)]]></title>
    <link href="http://DamianSheldon.github.io/blog/mybatis-workflow.html"/>
    <updated>2022-10-11T16:06:03+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/mybatis-workflow</id>
    <content type="html"><![CDATA[<p>MyBatis 的工作流程主要是以下几步：</p>

<ul>
<li>加载配置并初始化</li>
<li>接收调用请求</li>
<li>处理操作请求</li>
<li>返回处理结果</li>
</ul>


<p>本文我们先具体来看看它与 Spring Boot 集成时的初始化。</p>

<p>MyBatis 官方团队有开发一个 Spring Boot Starter，我们通过它的代码来看下配置加载和初始化。配置的入口是 MybatisAutoConfiguration，它会按需创建 sqlSessionFactory 和 sqlSessionTemplate 这两个 bean 对象，同时它还包含一个内部配置类 MapperScannerRegistrarNotFoundConfiguration:</p>

<pre><code>@org.springframework.context.annotation.Configuration
@Import(AutoConfiguredMapperScannerRegistrar.class)
@ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class })
public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {

  @Override
  public void afterPropertiesSet() {
    logger.debug(
        "Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.");
  }

}
</code></pre>

<p>MapperScannerRegistrarNotFoundConfiguration 导入了 AutoConfiguredMapperScannerRegistrar，它会向 IoC 容器注册 MapperScannerConfigurer。</p>

<!--more-->


<pre><code>/**
 * This will just scan the same base package as Spring Boot does. If you want more power, you can explicitly use
 * {@link org.mybatis.spring.annotation.MapperScan} but this will get typed mappers working correctly, out-of-the-box,
 * similar to using Spring Data JPA repositories.
 */
public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar {

  private BeanFactory beanFactory;

  @Override
  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

    if (!AutoConfigurationPackages.has(this.beanFactory)) {
      logger.debug("Could not determine auto-configuration package, automatic mapper scanning disabled.");
      return;
    }

    logger.debug("Searching for mappers annotated with @Mapper");

    List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory);
    if (logger.isDebugEnabled()) {
      packages.forEach(pkg -&gt; logger.debug("Using auto-configuration base package '{}'", pkg));
    }

    BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
    builder.addPropertyValue("processPropertyPlaceHolders", true);
    builder.addPropertyValue("annotationClass", Mapper.class);
    builder.addPropertyValue("basePackage", StringUtils.collectionToCommaDelimitedString(packages));
    BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
    Set&lt;String&gt; propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    if (propertyNames.contains("lazyInitialization")) {
      // Need to mybatis-spring 2.0.2+
      builder.addPropertyValue("lazyInitialization", "${mybatis.lazy-initialization:false}");
    }
    if (propertyNames.contains("defaultScope")) {
      // Need to mybatis-spring 2.0.6+
      builder.addPropertyValue("defaultScope", "${mybatis.mapper-default-scope:}");
    }
    registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
  }

  @Override
  public void setBeanFactory(BeanFactory beanFactory) {
    this.beanFactory = beanFactory;
  }

}
</code></pre>

<p>MapperScannerConfigurer 是一个 BeanDefinitionRegistryPostProcessor，IoC 会调用它的 postProcessBeanDefinitionRegistry 方法来处理 bean 定义:</p>

<pre><code>/**
 * {@inheritDoc}
 *
 * @since 1.0.2
 */
@Override
public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
  if (this.processPropertyPlaceHolders) {
    processPropertyPlaceHolders();
  }

  ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
  scanner.setAddToConfig(this.addToConfig);
  scanner.setAnnotationClass(this.annotationClass);
  scanner.setMarkerInterface(this.markerInterface);
  scanner.setSqlSessionFactory(this.sqlSessionFactory);
  scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
  scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
  scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
  scanner.setResourceLoader(this.applicationContext);
  scanner.setBeanNameGenerator(this.nameGenerator);
  scanner.setMapperFactoryBeanClass(this.mapperFactoryBeanClass);
  if (StringUtils.hasText(lazyInitialization)) {
    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
  }
  if (StringUtils.hasText(defaultScope)) {
    scanner.setDefaultScope(defaultScope);
  }
  scanner.registerFilters();
  scanner.scan(
      StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
}
</code></pre>

<p>从方法中我们可以知道，它使用 ClassPathMapperScanner 来扫描注册 Mapper，ClassPathMapperScanner 覆盖了父类 ClassPathBeanDefinitionScanner 的 doScan 方法：</p>

<pre><code>/**
 * Calls the parent search that will search and register all the candidates. Then the registered objects are post
 * processed to set them as MapperFactoryBeans
 */
@Override
public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) {
  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);

  if (beanDefinitions.isEmpty()) {
    LOGGER.warn(() -&gt; "No MyBatis mapper was found in '" + Arrays.toString(basePackages)
        + "' package. Please check your configuration.");
  } else {
    processBeanDefinitions(beanDefinitions);
  }

  return beanDefinitions;
}
</code></pre>

<p>它在 processBeanDefinitions 方法中对 bean 定义进行了进一步的处理，把 bean 的 bean class 换成了 MapperFactoryBean，由它来生成创建对应的 Mapper。另外就是设置按类型自动连线 <code>definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</code>，我在跟代码的过程中一开始很奇怪 ClassPathMapperScanner 注册 MapperFactoryBean 的 bean 定义时 sqlSessionTemplate 为 null，那么是在什么时候设置的 sqlSessionTemplate 呢？经过一番代码追踪，发现是 beanDefinition 设置了 AutowireMode，AbstractAutowireCapableBeanFactory 会帮助自动关联。</p>

<pre><code>private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) {
  AbstractBeanDefinition definition;
  BeanDefinitionRegistry registry = getRegistry();
  for (BeanDefinitionHolder holder : beanDefinitions) {
    definition = (AbstractBeanDefinition) holder.getBeanDefinition();
    boolean scopedProxy = false;
    if (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) {
      definition = (AbstractBeanDefinition) Optional
          .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())
          .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; new IllegalStateException(
              "The target bean definition of scoped proxy bean not found. Root bean definition[" + holder + "]"));
      scopedProxy = true;
    }
    String beanClassName = definition.getBeanClassName();
    LOGGER.debug(() -&gt; "Creating MapperFactoryBean with name '" + holder.getBeanName() + "' and '" + beanClassName
        + "' mapperInterface");

    // the mapper interface is the original class of the bean
    // but, the actual class of the bean is MapperFactoryBean
    definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59
    definition.setBeanClass(this.mapperFactoryBeanClass);

    definition.getPropertyValues().add("addToConfig", this.addToConfig);

    // Attribute for MockitoPostProcessor
    // https://github.com/mybatis/spring-boot-starter/issues/475
    definition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, beanClassName);

    boolean explicitFactoryUsed = false;
    if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {
      definition.getPropertyValues().add("sqlSessionFactory",
          new RuntimeBeanReference(this.sqlSessionFactoryBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionFactory != null) {
      definition.getPropertyValues().add("sqlSessionFactory", this.sqlSessionFactory);
      explicitFactoryUsed = true;
    }

    if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {
      if (explicitFactoryUsed) {
        LOGGER.warn(
            () -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.");
      }
      definition.getPropertyValues().add("sqlSessionTemplate",
          new RuntimeBeanReference(this.sqlSessionTemplateBeanName));
      explicitFactoryUsed = true;
    } else if (this.sqlSessionTemplate != null) {
      if (explicitFactoryUsed) {
        LOGGER.warn(
            () -&gt; "Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.");
      }
      definition.getPropertyValues().add("sqlSessionTemplate", this.sqlSessionTemplate);
      explicitFactoryUsed = true;
    }

    if (!explicitFactoryUsed) {
      LOGGER.debug(() -&gt; "Enabling autowire by type for MapperFactoryBean with name '" + holder.getBeanName() + "'.");
      definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
    }

    definition.setLazyInit(lazyInitialization);

    if (scopedProxy) {
      continue;
    }

    if (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != null) {
      definition.setScope(defaultScope);
    }

    if (!definition.isSingleton()) {
      BeanDefinitionHolder proxyHolder = ScopedProxyUtils.createScopedProxy(holder, registry, true);
      if (registry.containsBeanDefinition(proxyHolder.getBeanName())) {
        registry.removeBeanDefinition(proxyHolder.getBeanName());
      }
      registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());
    }

  }
}
</code></pre>

<p>MapperFactoryBean 的 getObject 方法如下，它使用上文所述，容器中的 sqlSession bean 来创建 mapper，通常也就是 MybatisAutoConfiguration 定义的 sqlSession bean。</p>

<pre><code>public T getObject() throws Exception {
  return getSqlSession().getMapper(this.mapperInterface);
}
</code></pre>

<p>MybatisAutoConfiguration 是定义 sqlSession bean 的代码如下：</p>

<pre><code>@Bean
@ConditionalOnMissingBean
public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
  ExecutorType executorType = this.properties.getExecutorType();
  if (executorType != null) {
    return new SqlSessionTemplate(sqlSessionFactory, executorType);
  } else {
    return new SqlSessionTemplate(sqlSessionFactory);
  }
}
</code></pre>

<p>它依赖的 SqlSessionFactory MybatisAutoConfiguration 也有定义:</p>

<pre><code>@Bean
@ConditionalOnMissingBean
public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
  SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
  factory.setDataSource(dataSource);
  factory.setVfs(SpringBootVFS.class);
  if (StringUtils.hasText(this.properties.getConfigLocation())) {
    factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
  }
  applyConfiguration(factory);
  if (this.properties.getConfigurationProperties() != null) {
    factory.setConfigurationProperties(this.properties.getConfigurationProperties());
  }
  if (!ObjectUtils.isEmpty(this.interceptors)) {
    factory.setPlugins(this.interceptors);
  }
  if (this.databaseIdProvider != null) {
    factory.setDatabaseIdProvider(this.databaseIdProvider);
  }
  if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
    factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
  }
  if (this.properties.getTypeAliasesSuperType() != null) {
    factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
  }
  if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
    factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
  }
  if (!ObjectUtils.isEmpty(this.typeHandlers)) {
    factory.setTypeHandlers(this.typeHandlers);
  }
  if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
    factory.setMapperLocations(this.properties.resolveMapperLocations());
  }
  Set&lt;String&gt; factoryPropertyNames = Stream
      .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
      .collect(Collectors.toSet());
  Class&lt;? extends LanguageDriver&gt; defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
  if (factoryPropertyNames.contains("scriptingLanguageDrivers") &amp;&amp; !ObjectUtils.isEmpty(this.languageDrivers)) {
    // Need to mybatis-spring 2.0.2+
    factory.setScriptingLanguageDrivers(this.languageDrivers);
    if (defaultLanguageDriver == null &amp;&amp; this.languageDrivers.length == 1) {
      defaultLanguageDriver = this.languageDrivers[0].getClass();
    }
  }
  if (factoryPropertyNames.contains("defaultScriptingLanguageDriver")) {
    // Need to mybatis-spring 2.0.2+
    factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
  }

  return factory.getObject();
}

private void applyConfiguration(SqlSessionFactoryBean factory) {
  Configuration configuration = this.properties.getConfiguration();
  if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) {
    configuration = new Configuration();
  }
  if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) {
    for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
      customizer.customize(configuration);
    }
  }
  factory.setConfiguration(configuration);
}
</code></pre>

<p>SqlSessionTemplate 是一个代理对象，它的功能依赖 SqlSessionFactory，它的 getMapper 方法如下：</p>

<pre><code>@Override
public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
  return getConfiguration().getMapper(type, this);
}
</code></pre>

<p>实现依赖 getConfiguration, 它的内容如下：</p>

<pre><code>@Override
public Configuration getConfiguration() {
  return this.sqlSessionFactory.getConfiguration();
}
</code></pre>

<p>Configuration 就是使用的 sqlSessionFactory 的配置对象。</p>

<p>现在我们聚焦到 SqlSessionFactory 的 Configuration 对象是怎么来的。 SqlSessionFactory 是由 SqlSessionFactoryBean，MybatisAutoConfiguration 有为它设置一个 Configuration :</p>

<pre><code>private void applyConfiguration(SqlSessionFactoryBean factory) {
  Configuration configuration = this.properties.getConfiguration();
  if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) {
    configuration = new Configuration();
  }
  if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) {
    for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
      customizer.customize(configuration);
    }
  }
  factory.setConfiguration(configuration);
}
</code></pre>

<p>那么最终的 Configuration 就是这个外部设置的对象吗？我们继续看它的 getObject 方法:</p>

<pre><code>@Override
public SqlSessionFactory getObject() throws Exception {
  if (this.sqlSessionFactory == null) {
    afterPropertiesSet();
  }

  return this.sqlSessionFactory;
}
</code></pre>

<p>再看下它的 afterPropertiesSet 方法：</p>

<pre><code>public void afterPropertiesSet() throws Exception {
  notNull(dataSource, "Property 'dataSource' is required");
  notNull(sqlSessionFactoryBuilder, "Property 'sqlSessionFactoryBuilder' is required");
  state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),
      "Property 'configuration' and 'configLocation' can not specified with together");

  this.sqlSessionFactory = buildSqlSessionFactory();
}
</code></pre>

<p>是在 buildSqlSessionFactory 方法中创建的 sqlSessionFactory:</p>

<pre><code>
/**
 * Build a {@code SqlSessionFactory} instance.
 *
 * The default implementation uses the standard MyBatis {@code XMLConfigBuilder} API to build a
 * {@code SqlSessionFactory} instance based on a Reader. Since 1.3.0, it can be specified a {@link Configuration}
 * instance directly(without config file).
 *
 * @return SqlSessionFactory
 * @throws Exception
 *           if configuration is failed
 */
protected SqlSessionFactory buildSqlSessionFactory() throws Exception {

  final Configuration targetConfiguration;

  XMLConfigBuilder xmlConfigBuilder = null;
  if (this.configuration != null) {
    targetConfiguration = this.configuration;
    if (targetConfiguration.getVariables() == null) {
      targetConfiguration.setVariables(this.configurationProperties);
    } else if (this.configurationProperties != null) {
      targetConfiguration.getVariables().putAll(this.configurationProperties);
    }
  } else if (this.configLocation != null) {
    xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);
    targetConfiguration = xmlConfigBuilder.getConfiguration();
  } else {
    LOGGER.debug(
        () -&gt; "Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration");
    targetConfiguration = new Configuration();
    Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);
  }

  Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);
  Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);
  Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);

  if (hasLength(this.typeAliasesPackage)) {
    scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()
        .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())
        .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);
  }

  if (!isEmpty(this.typeAliases)) {
    Stream.of(this.typeAliases).forEach(typeAlias -&gt; {
      targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);
      LOGGER.debug(() -&gt; "Registered type alias: '" + typeAlias + "'");
    });
  }

  if (!isEmpty(this.plugins)) {
    Stream.of(this.plugins).forEach(plugin -&gt; {
      targetConfiguration.addInterceptor(plugin);
      LOGGER.debug(() -&gt; "Registered plugin: '" + plugin + "'");
    });
  }

  if (hasLength(this.typeHandlersPackage)) {
    scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())
        .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))
        .forEach(targetConfiguration.getTypeHandlerRegistry()::register);
  }

  if (!isEmpty(this.typeHandlers)) {
    Stream.of(this.typeHandlers).forEach(typeHandler -&gt; {
      targetConfiguration.getTypeHandlerRegistry().register(typeHandler);
      LOGGER.debug(() -&gt; "Registered type handler: '" + typeHandler + "'");
    });
  }

  targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);

  if (!isEmpty(this.scriptingLanguageDrivers)) {
    Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; {
      targetConfiguration.getLanguageRegistry().register(languageDriver);
      LOGGER.debug(() -&gt; "Registered scripting language driver: '" + languageDriver + "'");
    });
  }
  Optional.ofNullable(this.defaultScriptingLanguageDriver)
      .ifPresent(targetConfiguration::setDefaultScriptingLanguage);

  if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls
    try {
      targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));
    } catch (SQLException e) {
      throw new NestedIOException("Failed getting a databaseId", e);
    }
  }

  Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);

  if (xmlConfigBuilder != null) {
    try {
      xmlConfigBuilder.parse();
      LOGGER.debug(() -&gt; "Parsed configuration file: '" + this.configLocation + "'");
    } catch (Exception ex) {
      throw new NestedIOException("Failed to parse config resource: " + this.configLocation, ex);
    } finally {
      ErrorContext.instance().reset();
    }
  }

  targetConfiguration.setEnvironment(new Environment(this.environment,
      this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,
      this.dataSource));

  if (this.mapperLocations != null) {
    if (this.mapperLocations.length == 0) {
      LOGGER.warn(() -&gt; "Property 'mapperLocations' was specified but matching resources are not found.");
    } else {
      for (Resource mapperLocation : this.mapperLocations) {
        if (mapperLocation == null) {
          continue;
        }
        try {
          XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),
              targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());
          xmlMapperBuilder.parse();
        } catch (Exception e) {
          throw new NestedIOException("Failed to parse mapping resource: '" + mapperLocation + "'", e);
        } finally {
          ErrorContext.instance().reset();
        }
        LOGGER.debug(() -&gt; "Parsed mapper file: '" + mapperLocation + "'");
      }
    }
  } else {
    LOGGER.debug(() -&gt; "Property 'mapperLocations' was not specified.");
  }

  return this.sqlSessionFactoryBuilder.build(targetConfiguration);
}
</code></pre>

<p>从这段代码可知，由于 MybatisAutoConfiguration 有设置一个 Configuration ，所以 SqlSessionFactoryBean 使用的就是设置的这个 Configuration。</p>

<p>sqlSessionFactoryBuilder 默认是 SqlSessionFactoryBuilder，它的赋值代码为：</p>

<pre><code>private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
</code></pre>

<p>它的 build 方法实现为:</p>

<pre><code>public SqlSessionFactory build(Configuration config) {
  return new DefaultSqlSessionFactory(config);
}
</code></pre>

<p>因此创建的是 DefaultSqlSessionFactory 对象。</p>

<p>现在 SqlSessionFactory, SqlSession, Configuration 的实现来源都清楚了，我们继续来看创建 mapper 的代码，看 mapper 的实现是什么？</p>

<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}
</code></pre>

<p>mapperRegistry 的实现是 MapperRegistry，它的 getMapper 方法如下：</p>

<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
  final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException("Type " + type + " is not known to the MapperRegistry.");
  }
  try {
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException("Error getting mapper instance. Cause: " + e, e);
  }
}
</code></pre>

<p>它是从 knownMappers 取出类型对应的 MapperProxyFactory，那么它是何时如何注册的呢？</p>

<p>前面我们说过， Mapper 对应向 IoC 注册的的 bean 定义是 MapperFactoryBean 对象，MapperFactory 继承自 SqlSessionDaoSupport，而 SqlSessionDaoSupport 继承自 DaoSupport，DaoSupport 实现 InitializingBean 接口，所以在实例化 mapper 时会实例化出 MapperFactory，并先调用它的 afterPropertiesSet 方法：</p>

<pre><code>@Override
public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
    // Let abstract subclasses check their configuration.
    checkDaoConfig();

    // Let concrete implementations initialize themselves.
    try {
        initDao();
    }
    catch (Exception ex) {
        throw new BeanInitializationException("Initialization of DAO failed", ex);
    }
}
</code></pre>

<p>MapperFactory 覆盖了 checkDaoConfig 方法:</p>

<pre><code>protected void checkDaoConfig() {
  super.checkDaoConfig();

  notNull(this.mapperInterface, "Property 'mapperInterface' is required");

  Configuration configuration = getSqlSession().getConfiguration();
  if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) {
    try {
      configuration.addMapper(this.mapperInterface);
    } catch (Exception e) {
      logger.error("Error while adding the mapper '" + this.mapperInterface + "' to configuration.", e);
      throw new IllegalArgumentException(e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
}
</code></pre>

<p>也就是在这个方法中向 Configuration 添加了 mapper 对应的 MapperProxyFactory 类型:</p>

<pre><code>public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
  mapperRegistry.addMapper(type);
}

public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
  if (type.isInterface()) {
    if (hasMapper(type)) {
      throw new BindingException("Type " + type + " is already known to the MapperRegistry.");
    }
    boolean loadCompleted = false;
    try {
      knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));
      // It's important that the type is added before the parser is run
      // otherwise the binding may automatically be attempted by the
      // mapper parser. If the type is already known, it won't try.
      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
      parser.parse();
      loadCompleted = true;
    } finally {
      if (!loadCompleted) {
        knownMappers.remove(type);
      }
    }
  }
}
</code></pre>

<p>从上述代码可以看出 mapper 对应的 MapperProxyFactory 类型是用定义的 mapper 接口类型参数化的 MapperProxyFactory，它的 <code>newInstance(SqlSession sqlSession)</code> 方法如下：</p>

<pre><code>public T newInstance(SqlSession sqlSession) {
  final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
</code></pre>

<p>最后为 mapper 接口创建向 mapperProxy 实例转发调用的代理对象。</p>

<pre><code>protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
</code></pre>

<p>也就是说，mapper 接口类型对象等效于一个 MapperProxy 对象。至此，MyBatis 的初始化过程就梳理清楚了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring MVC 中的异常处理]]></title>
    <link href="http://DamianSheldon.github.io/blog/exception-handling-in-spring-mvc.html"/>
    <updated>2022-09-30T10:06:54+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/exception-handling-in-spring-mvc</id>
    <content type="html"><![CDATA[<p>使用 Spring 来开发 web 应用时很有必要建立一个统一的异常处理体系。想要建立这个体系，我们先要搞清楚 Spring MVC 中的异常处理机制。 Spring MVC 是基于 Servlet，所以它遵循 Servlet 规范。</p>

<p>Servlet 规范中有详细的错误处理说明，简单来说就是 Servlet 在处理请求时可能会抛出异常或者调用 <code>sendError</code> ，这时 Servlet-Container 就要产生相应的错误界面，错误界面是允许自定义的。Spring MVC 的核心之一是 DispatchServlet，它是一个前端控制器，所有的请求处理都由它来驱动，从名字可以看出，它也是一个 Servlet，所以它的错误处理机制自然要遵循 Servlet 规范。从完整性的角度来看，还一种错误处理方法，Servlet 可以自己设置 HTTP 的 status code 和 body，也就是不和 Servlet-Container 联动来处理错误，而是完全自主地处理。</p>

<p>我们先来看 DispatcherServlet 的异常处理机制，Spring 团队将异常处理功能集中到 HandlerExceptionResolver 接口的实现类中，DispatcherServlet 在初始化过程会把 IoC 容器中所有的 HandlerExceptionResolver 的实现类排好序后组装起来用于异常处理。</p>

<p>现在我们使用 Spring 来开发 web 应用时应该都会选择 Spring Boot 来配置 Spring，和异常相关的自动配置类为 ErrorMvcAutoConfiguration 和 WebMvcAutoConfiguration， 它们默认配置两个 HandlerExceptionResolver: DefaultErrorAttributes 和 HandleExceptionResolverComposite。</p>

<p>HandleExceptionResolverComposite 默认包含以下三个 HandlerExceptionResolver:</p>

<blockquote><ul>
<li>ExceptionHandlerExceptionResolver matches uncaught exceptions against suitable @ExceptionHandler methods on both the handler (controller) and on any controller-advices.</li>
<li>ResponseStatusExceptionResolver looks for uncaught exceptions annotated by @ResponseStatus (as described in Section 1)</li>
<li>DefaultHandlerExceptionResolver converts standard Spring exceptions and converts them to HTTP Status Codes (I have not mentioned this above as it is internal to Spring MVC).</li>
</ul>
</blockquote>

<p>Spring 官方博客帮我们总结了 Spring Boot 默认配置的异常处理流程：</p>

<blockquote><ol>
<li>In the event of any unhanded error, Spring Boot forwards internally to /error.</li>
<li>Boot sets up a BasicErrorController to handle any request to /error. The controller adds error information to the internal Model and returns error as the logical view name.</li>
<li>If any view-resolver(s) are configured, they will try to use a corresponding error-view.</li>
<li>Otherwise, a default error page is provided using a dedicated View object (making it independent of any view-resolution system you may be using).</li>
<li>Spring Boot sets up a BeanNameViewResolver so that /error can be mapped to a View of the same name.</li>
<li>If you look in Boot’s ErrorMvcAutoConfiguration class you will see that the defaultErrorView is returned as a bean called error. This is the View bean found by the BeanNameViewResolver.</li>
</ol>
</blockquote>

<p>对于 Servlet-Container 层面的错误处理，Spring 官方博客的介绍如下：</p>

<blockquote><p>Container-Wide Exception Handling</p>

<p>Exceptions thrown outside the Spring Framework, such as from a servlet Filter, are also reported by Spring Boot’s fallback error page.
To do this Spring Boot has to register a default error page for the container. In Servlet 2, there is an <code>&lt;error-page&gt;</code> directive that you can add to your web.xml to do this. Sadly Servlet 3 does not offer a Java API equivalent. Instead Spring Boot does the following:</p>

<ul>
<li>For a Jar application, with an embedded container, it registers a default error page using Container specific API.</li>
<li>For a Spring Boot application deployed as a traditional WAR file, a Servlet Filter is used to catch exceptions raised further down the line and handle it.</li>
</ul>
</blockquote>

<p>我们可以按照上述线索在 Spring Boot 的自动配置代码中找到相关的代码。</p>

<p>当开发 REST API 项目时，我希望业务抛出的异常能契合 Spring Boot 默认配置的异常处理机制，让整个异常体系尽量统一，接口返回给终端统一格式的错误信息，这样终端也能统一处理接口错误。那么我们应该如何做？</p>

<p>我们这里需要的是一个全局的异常处理机制，Spring MVC 提供给我们两种配置全局异常处理的方法：</p>

<ul>
<li>配置 HandlerExceptionResolver</li>
<li>使用 <code>@ControllerAdvice</code> 注解的类</li>
</ul>


<p>相比之下，个人觉得使用 <code>@ControllerAdvice</code> 注解的类会方便一些，能达到感知框架的存在。我们可以定义一个异常处理基类，发布成一个库，然后在需要用到的项目中引入这个库，在项目中继承该基类定义一个 <code>@ControllerAdvice</code> 注解的异常处理类。</p>

<p>选好全局异常处理机制后，那么我们应该如何来设计项目的业务异常类呢?</p>

<p>Spring 官方博客给出了如下建议:</p>

<blockquote><p>As usual, Spring likes to offer you choice, so what should you do? Here are some rules of thumb. However if you have a preference for XML configuration or Annotations, that’s fine too.</p>

<ul>
<li>For exceptions you write, consider adding @ResponseStatus to them.</li>
<li>For all other exceptions implement an @ExceptionHandler method on a @ControllerAdvice class or use an instance of SimpleMappingExceptionResolver. You may well have SimpleMappingExceptionResolver configured for your application already, in which case it may be easier to add new exception classes to it than implement a @ControllerAdvice.</li>
<li>For Controller specific exception handling add @ExceptionHandler methods to your controller.</li>
<li>Warning: Be careful mixing too many of these options in the same application. If the same exception can be handed in more than one way, you may not get the behavior you wanted. @ExceptionHandler methods on the Controller are always selected before those on any @ControllerAdvice instance. It is undefined what order controller-advices are processed.</li>
</ul>
</blockquote>

<!--more-->


<p>这里我们重点来看第一条建议，他建议我们自己写的异常类可以考虑加上 <code>@ResponseStatus</code> 注解，这样 service 就可以往上层传递 HTTP 的 status 信息，然后可以根据异常的类型填充 body 信息。这样做当然可以，只是这样一来异常类数量容易膨胀，定义异常类也是很乏味。我觉得可以定义一个能表达 HTTP status, headers 和 body 信息的类，然后抛出它的实例，他的建议作为补充。</p>

<p>设计好异常类层级后，接口出错时应该返回些什么信息给终端？</p>

<p>《Web API 的设计与开发》作者建议的单个和多个错误信息如下：</p>

<pre><code>// 单个
{
  "error": {
      "code": 2013,
      "message": "Bad authentication token",
      "info": "http://docs.example.com/api/v1/authentication"
  }
}
// 多个
{
  "errors": [
      {
          "code": 2013,
          "message": "Bad authentication token",
          "info": "http://docs.example.com/api/v1/authentication"
      }
  ]
}
</code></pre>

<p>同样，我还是希望业务异常产生的错误信息能够兼容 Spring Boot 默认产生的错误信息，这样终端可以统一处理错误信息。Spring Boot 默认产生的错误信息包含如下字段：</p>

<pre><code>timestamp - The time that the errors were extracted
status - The status code
error - The error reason
exception - The class name of the root exception (if configured)
message - The exception message (if configured)
errors - Any ObjectErrors from a BindingResult exception (if configured)
trace - The exception stack trace (if configured)
path - The URL path when the exception was raised
</code></pre>

<p>综上所述，我们可以定义 REST API 的错误信息为 RestErrorInfo:</p>

<pre><code>public class RestErrorInfo {
    private Integer code;

    private String message;

    private String info;

    // 省略的 Constructor, Getter and Setter
}
</code></pre>

<p>异常类 ServiceException 为：</p>

<pre><code>package com.github.damiansheldon.exception;

import org.springframework.core.NestedRuntimeException;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;

public class ServiceException extends NestedRuntimeException {

    private HttpStatus status;

    private HttpHeaders headers;

    private RestErrorInfo errorInfo;

    private ServiceException(Builder builder) {
        super(builder.errorInfo.getMessage(), builder.cause);
        this.errorInfo = builder.errorInfo;
    }

    public HttpStatus getStatus() {
        return status;
    }

    public HttpHeaders getHeaders() {
        return headers;
    }

    public RestErrorInfo getErrorInfo() {
        return errorInfo;
    }

    public static class Builder {
        private HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
        private HttpHeaders headers;
        private RestErrorInfo errorInfo;
        private Throwable cause;

        public Builder(RestErrorInfo errorInfo) {
            this.errorInfo = errorInfo;
        }

        public Builder status(HttpStatus status) {
            this.status = status;
            return this;
        }

        public Builder headers(HttpHeaders headers) {
            this.headers = headers;
            return this;
        }

        public Builder cause(Throwable cause) {
            this.cause = cause;
            return this;
        }

        public ServiceException build() {
            return new ServiceException(this);
        }

    }

}
</code></pre>

<p>异常处理类为：</p>

<pre><code>package com.github.damiansheldon.exception;

import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.Nullable;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.util.WebUtils;

public class ServiceExceptionHandler {

    @ExceptionHandler({ServiceException.class})
    public final ResponseEntity&lt;Object&gt; handleServiceException(ServiceException ex, WebRequest request) {
        return handleExceptionInternal(ex, ex.getErrorInfo(), ex.getHeaders(), ex.getStatus(), request);
    }

    protected ResponseEntity&lt;Object&gt; handleExceptionInternal(
            Exception ex, @Nullable Object body, HttpHeaders headers, HttpStatus status, WebRequest request) {

        if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {
            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST);
        }
        return new ResponseEntity&lt;&gt;(body, headers, status);
    }
}
</code></pre>

<p>完整代码在<a href="https://github.com/DamianSheldon/Treasure">这里</a>。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc">Exception Handling in Spring MVC</a></li>
<li><a href="https://javaee.github.io/servlet-spec/downloads/servlet-3.1/Final/servlet-3_1-final.pdf">Java™ Servlet Specification</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 开发问题汇总(五)]]></title>
    <link href="http://DamianSheldon.github.io/blog/web-development-notes-part-five.html"/>
    <updated>2022-07-01T09:32:39+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/web-development-notes-part-five</id>
    <content type="html"><![CDATA[<h3>1.</h3>

<pre><code>$ jmap -heap 29104
Attaching to process ID 29104, please wait...
ERROR: attach: task_for_pid(29104) failed: '(os/kern) failure' (5)
Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process. Could be caused by an incorrect pid or lack of privileges.
sun.jvm.hotspot.debugger.DebuggerException: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process. Could be caused by an incorrect pid or lack of privileges.
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$BsdDebuggerLocalWorkerThread.execute(BsdDebuggerLocal.java:169)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.attach(BsdDebuggerLocal.java:287)
    at sun.jvm.hotspot.HotSpotAgent.attachDebugger(HotSpotAgent.java:671)
    at sun.jvm.hotspot.HotSpotAgent.setupDebuggerDarwin(HotSpotAgent.java:659)
    at sun.jvm.hotspot.HotSpotAgent.setupDebugger(HotSpotAgent.java:341)
    at sun.jvm.hotspot.HotSpotAgent.go(HotSpotAgent.java:304)
    at sun.jvm.hotspot.HotSpotAgent.attach(HotSpotAgent.java:140)
    at sun.jvm.hotspot.tools.Tool.start(Tool.java:185)
    at sun.jvm.hotspot.tools.Tool.execute(Tool.java:118)
    at sun.jvm.hotspot.tools.HeapSummary.main(HeapSummary.java:49)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at sun.tools.jmap.JMap.runTool(JMap.java:201)
    at sun.tools.jmap.JMap.main(JMap.java:130)
Caused by: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process. Could be caused by an incorrect pid or lack of privileges.
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.attach0(Native Method)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal.access$100(BsdDebuggerLocal.java:65)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$1AttachTask.doit(BsdDebuggerLocal.java:278)
    at sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal$BsdDebuggerLocalWorkerThread.run(BsdDebuggerLocal.java:144)
</code></pre>

<p>A: macOS 上的 java 虚拟机基础工具不能附加到 java 进程上，操作系统环境为:</p>

<pre><code>$ sw_vers
ProductName:    Mac OS X
ProductVersion: 10.15.7
BuildVersion:   19H1922
</code></pre>

<p>java 版本:</p>

<pre><code>$ java -version
java version "1.8.0_121"
Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
</code></pre>

<p>google 了一番之后，问题可能是 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8160376">macOS 上的 java 8 部分小版本有问题</a>，于是我打算用虚拟机里面的 RockyLinux 来试下，结果是确定可以。</p>

<!--more-->


<p>这中间还一个小插曲，也很有意思，这里记一下。虚拟机里面的 RockyLinux 之前并没有安装 java 开发环境，于是我就下载安装 eclipse，2022-06 版本的 eclipse 默认要求 <code>java 11+</code> 的运行环境，它默认选择安装的是 java 17，这也确定是一个好选择，一是 ZGC 是从 java 15 开始 Production Ready；二是 java 17 是一个长期支持版本。</p>

<blockquote><p>ZGC was initially introduced as an experimental feature in JDK 11, and was declared Production Ready in JDK 15.</p></blockquote>

<p>RockyLinux 自带的是 java 8，于是我们安装 jdk 8 和 jdk 17，然后使用自带的 alternatives 来切换 java 版本，但是它好像只管理 jre bin 下的命令，并有把 jdk 里面的命令都管理起来。我是使用 jinfo 提示报错发现的:</p>

<pre><code>Type "GenericGrowableArray", referenced in VMStructs::localHotSpotVMStructs in the remote VM, was not present in the remote VMStructs::localHotSpotVMTypes table (should have been caught in the debug build of that VM). Can not continue.
</code></pre>

<p>可以使用 <code>alternatives --display java</code> 去确定一下，从这里也可以看出工具的版本最好对应，所以我们也可以将它们纳入 alternatives 系统来管理。以 jhsdb 为例:</p>

<pre><code>sudo alternatives --add-slave java /usr/lib/jvm/java-17-openjdk-17.0.3.0.7-2.el8_6.x86_64/bin/java /usr/bin/jhsdb jhsdb /usr/lib/jvm/java-17-openjdk-17.0.3.0.7-2.el8_6.x86_64/bin/jhsdb
</code></pre>

<p>虚拟机里面做开发还是有点卡，最后还是决定在 mac 上安装多个版本的 java，macOS 上并没有自带 centOS 上 alternatives 类似的命令，需要安装第三方软件来管理，之前在 Spring 的源码里看到它是用 SDkMan 来管理多个版本的 java，所以也决定用 SDKMan 来管理。但是 SDKMan 和 alternatives 的实现方式有很大差别，它默认是将软件安装在用户目录下的隐藏目录下，这对 eclipse 之类 IDE 来配置相关的类库会稍微有点不方便，需要开启 Finder 的隐藏文件显示，快捷命令是 <code>cmd+shift+.</code>，<code>defaults write com.apple.Finder AppleShowAllFiles true</code> 命令暂时没生效。</p>

<p>Reference:</p>

<ul>
<li><a href="https://blog.csdn.net/Dongguabai/article/details/88736589">Mac 使用 jinfo 出现：Can&rsquo;t attach to the process. Could be caused by an incorrect pid or lack of privileg</a></li>
<li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8160376">JDK-8160376 : DebuggerException: Can&rsquo;t attach symbolicator to the process</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 面试题]]></title>
    <link href="http://DamianSheldon.github.io/blog/redis-interview-questions.html"/>
    <updated>2022-04-27T14:36:10+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/redis-interview-questions</id>
    <content type="html"><![CDATA[<h2>1.什么是 Redis?</h2>

<blockquote><p>Redis is an open source (BSD licensed), in-memory data structure store used as a database, cache, message broker, and streaming engine.</p></blockquote>

<p>Redis是一个开源的内存数据结构存储，被用作数据库、缓存、消息代理和流媒体引擎。</p>

<h2>2.Redis的内存占用量是多少？</h2>

<p>我们看几个例子（都是使用64位实例得到的。</p>

<ul>
<li>一个空的实例使用~3MB的内存。</li>
<li>100万个小键->字符串值对使用~85MB的内存。</li>
<li>100万个键->哈希值，代表一个有5个字段的对象，使用~160 MB的内存。</li>
</ul>


<h2>3.为什么Redis将其整个数据集保存在内存中？</h2>

<p>在过去，Redis的开发者尝试了虚拟内存和其他系统来允许大于RAM的数据集，但最终我们很高兴能做好一件事：数据从内存中提供，磁盘用于存储。所以现在还没有计划为Redis创建一个磁盘上的后端。Redis是当前设计的结果。</p>

<h2>4.你能将Redis与基于磁盘的数据库一起使用吗？</h2>

<p>可以，一个常见的设计模式是在Redis中保存频繁写的小数据（以及你需要Redis数据结构以有效方式为你的问题建模的数据），而大块的数据保存到 SQL或最终一致的磁盘数据库。同样，有时Redis被用来在内存中获取存储在磁盘数据库中的相同数据子集的另一个副本。这看起来类似于缓存，但实际上是一个更高级的模型，因为通常Redis数据集与磁盘数据库数据集一起更新，而不是在缓存错过时刷新。</p>

<h2>5.如何减少Redis的整体内存用量？</h2>

<p>如果可以的话，使用Redis的32位实例。同时善用小的哈希值、列表、排序集和整数集，因为Redis能够在少数元素的特殊情况下以更紧凑的方式表示这些数据类型。</p>

<h2>6.如果Redis的内存用完了会怎样？</h2>

<p>Redis有内置的保护措施，允许用户设置内存使用的最大限制，使用配置文件中的maxmemory选项，对Redis可以使用的内存进行限制。如果达到这个限制，Redis将开始对写命令回复错误（但会继续接受只读命令）。</p>

<p>你也可以配置Redis在达到最大内存限制时驱逐键值。</p>

<!--more-->


<h2>7.Redis的磁盘快照是原子的吗？</h2>

<p>是的，Redis的后台保存过程总是在服务器没有执行命令时创建，所以每个在RAM中报告为原子的命令从磁盘快照的角度看也是原子的。</p>

<h2>8.Redis如何使用多个CPU或核心？</h2>

<p>CPU成为你使用Redis的瓶颈并不是很常见，因为通常Redis的问题不是内存就是网络带宽。例如，当使用 piplelining 时，在一个普通的Linux系统上运行的Redis实例每秒可以提供100万个请求，所以如果你的应用程序主要使用O(N)或O(log(N))命令，它几乎不会使用太多的CPU。</p>

<p>然而，为了最大限度地提高CPU的使用率，你可以在同一个机器里启动多个Redis的实例，并把它们当作不同的服务器。在某些时候，一个机器可能无论如何也不够用，所以如果你想使用多个CPU，你可以提前开始考虑一些方法来分片。</p>

<h2>9.一个Redis实例能容纳的最大键数是多少？Hash、List、Set和Sorted Set中元素的最大数量是多少？</h2>

<p>Redis最多可以处理<code>2^32</code>个键，经实践测试，每个实例至少可以处理2.5亿个键。</p>

<p>每个哈希、列表、集合和排序集，都可以容纳<code>2^32</code>个元素。</p>

<p>换句话说，你的极限可能是你系统中的可用内存。</p>

<h2>10.为什么我的复制节点与主实例的键数量不同？</h2>

<p>如果你使用有效期有限的键（Redis过期），这是正常行为。下面是问题的原因：</p>

<ul>
<li>主节点在与复制节点的第一次同步中生成一个RDB文件。</li>
<li>RDB文件将不包括在主服务器中已经过期但仍在内存中的密钥。</li>
<li>这些键仍然在Redis主节点的内存中，即使在逻辑上已经过期。它们将被认为是不存在的，它们的内存将在以后被回收，要么是增量的，要么是访问时明确的。虽然这些键在逻辑上不是数据集的一部分，但它们在INFO输出和DBSIZE命令中被计算在内。</li>
<li>当复制节点读取由主文件生成的RDB文件时，这组键将不会被加载。</li>
</ul>


<p>正因为如此，对于有很多过期键的用户来说，在复制节点中看到较少的键是很常见的。然而，从逻辑上讲，主节点和复制节点将有相同的内容。</p>

<h2>11.Redis 哨兵和集群的区别是什么？</h2>

<blockquote><p>Redis Sentinel provides high availability for Redis when not using Redis Cluster.
Redis scales horizontally with a deployment topology called Redis Cluster.</p></blockquote>

<h2>12.Memcache 与 Redis 的区别都有哪些？</h2>

<ul>
<li>Command-Line</li>
<li>Disk I/O Dumping</li>
<li>Data Structures</li>
<li>Replication</li>
<li>Transactions</li>
<li>Publish and Subscribe Messaging</li>
<li>Geospatial Support</li>
<li>Architecture</li>
<li>LUA Scripting</li>
<li><p>Memory Usage</p></li>
<li><p><a href="https://www.baeldung.com/memcached-vs-redis">Memcached vs Redis</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)Spring Boot 面试题]]></title>
    <link href="http://DamianSheldon.github.io/blog/spring-boot-interview-questions.html"/>
    <updated>2022-04-19T10:03:03+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/spring-boot-interview-questions</id>
    <content type="html"><![CDATA[<h1>1. 概述</h1>

<p>自推出以来，Spring Boot一直是Spring生态系统中的一个重要角色。这个项目凭借其自动配置能力使我们的生活变得更加轻松。</p>

<p>在本教程中，我们将介绍一些在求职面试中可能出现的与Spring Boot有关的最常见问题。</p>

<h1>2. 题目</h1>

<h2>Q1. 什么是Spring Boot，其主要特点是什么？</h2>

<p>Spring Boot本质上是一个建立在Spring框架之上的快速应用开发框架。凭借其自动配置和嵌入式应用服务器支持，再加上其享有的大量文档和社区支持，Spring Boot是迄今为止Java生态系统中最受欢迎的技术之一。</p>

<p>这里有几个突出的特点。</p>

<ul>
<li><strong>启动器</strong> &ndash; 一组依赖性描述符，可以一次性包括相关的依赖性</li>
<li><strong>自动配置</strong> &ndash; 一种基于classpath上的依赖关系自动配置应用程序的方法</li>
<li><strong>执行器</strong> &ndash; 获得生产就绪的功能，如监控</li>
<li><strong>安全性</strong></li>
<li><strong>日志</strong></li>
</ul>


<p>译者点评：</p>

<p>官方文档总结的特点：</p>

<blockquote><ul>
<li>  Create stand-alone Spring applications </li>
<li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) </li>
<li>Provide opinionated &lsquo;starter&rsquo; dependencies to simplify your build configuration </li>
<li>Automatically configure Spring and 3rd party libraries whenever possible </li>
<li>Provide production-ready features such as metrics, health checks, and externalized configuration </li>
<li><p>Absolutely no code generation and no requirement for XML configuration </p></li>
<li><p>创建独立的Spring应用程序</p></li>
<li><p>直接嵌入Tomcat、Jetty或Undertow（不需要部署WAR文件）</p></li>
<li><p>提供有主见的 &ldquo;启动器 "依赖，以简化你的构建配置</p></li>
<li><p>尽可能地自动配置Spring和第三方库</p></li>
<li><p>提供生产就绪的功能，如度量、健康检查和外部化配置</p></li>
<li><p>完全没有代码生成，也不需要XML配置</p></li>
</ul>
</blockquote>

<h2>Q2. Spring和Spring Boot之间的区别是什么？</h2>

<p>Spring框架提供了多种功能，使Web应用的开发更加容易。这些功能包括依赖性注入、数据绑定、面向切面编程、数据访问等等。</p>

<p>多年来，Spring越来越复杂，这种应用所需的配置量可能令人生畏。这就是Spring Boot的用武之地&ndash;它使配置一个Spring应用程序变得轻而易举。</p>

<p>从本质上讲，Spring是没有主见的，而Spring Boot对平台和库有主见，让我们快速上手。</p>

<p>下面是Spring Boot带来的两个最重要的好处。</p>

<ul>
<li>根据它在classpath上找到的库自动配置应用程序</li>
<li>提供生产中的应用程序常见的非功能特性，如安全或健康检查</li>
</ul>


<p>请查看我们的其他教程，了解<a href="https://www.baeldung.com/spring-vs-spring-boot">普通Spring和Spring Boot的详细比较</a>。</p>

<!--more-->


<h2>Q3. 我们如何用Maven设置Spring Boot应用程序？</h2>

<p>我们可以像对待其他库一样，将Spring Boot纳入Maven项目中。不过，最好的方法是从spring-boot-starter-parent项目中继承，并声明对Spring Boot starters的依赖关系。这样做可以让我们的项目重用Spring Boot的默认设置。</p>

<p>继承spring-boot-starter-parent项目很简单，我们只需要在pom.xml中指定一个父元素:</p>

<pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.4.0.RELEASE&lt;/version&gt;
&lt;/parent&gt;
</code></pre>

<p>我们可以在Maven中心找到最新版本的spring-boot-starter-parent。</p>

<p>使用启动器父项目很方便，但并不总是可行的。例如，如果我们公司要求所有项目都继承自标准POM，那么我们仍然可以通过使用<a href="https://www.baeldung.com/spring-boot-dependency-management-custom-parent">自定义父项目</a>来受益于Spring Boot的依赖性管理。</p>

<h2>Q4. 什么是Spring Initializr？</h2>

<p>Spring Initializr是一种创建Spring Boot项目的便捷方式。</p>

<p>我们可以去<a href="https://start.spring.io/">Spring Initializr</a>网站，选择一个依赖管理工具（Maven或Gradle）、一种语言（Java、Kotlin或Groovy）、一种打包方案（Jar或War）、版本和依赖性，然后下载项目。</p>

<p>这为我们创建了一个骨架项目，节省了设置时间，这样我们就可以集中精力添加业务逻辑。</p>

<p>即使我们使用IDE的（如STS或带有STS插件的Eclipse）新项目向导来创建Spring Boot项目，它也会在底下使用Spring Initializr。</p>

<h2>Q5. 外面有哪些Spring Boot启动器？</h2>

<p>每个启动器都扮演着一站式服务的角色，提供我们需要的所有 Spring 技术。其他所需的依赖项也会被拉进来，并以一致的方式进行管理。</p>

<p>所有启动器都在org.springframework.boot组下，其名称以spring-boot-starter-开头。这种命名模式使我们很容易找到启动器，特别是在使用支持按名称搜索依赖关系的IDE时。</p>

<p>在写这篇文章的时候，有超过50个启动器供我们使用。这里，我们将列出最常见的：</p>

<ul>
<li><strong>spring-boot-starter</strong>：核心启动器，包括自动配置支持、日志和YAML</li>
<li><strong>spring-boot-starter-aop</strong>: 使用Spring AOP和AspectJ进行面向方面的编程</li>
<li><strong>spring-boot-starter-data-jpa</strong>：用于在Hibernate中使用Spring Data JPA。</li>
<li><strong>spring-boot-starter-security</strong>: 用于使用Spring Security。</li>
<li><strong>spring-boot-starter-test</strong>: 用于测试Spring Boot应用程序</li>
<li><strong>spring-boot-starter-web</strong>: 用于使用Spring MVC构建Web（包括RESTful）应用程序。</li>
</ul>


<p>有关启动程序的完整列表，请参见该<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters">资源库</a>。</p>

<p>要找到关于Spring Boot启动程序的更多信息，请看<a href="https://www.baeldung.com/spring-boot-starters">Spring Boot启动程序介绍</a>。</p>

<h2>Q6. 如何禁用一个特定的自动配置？</h2>

<p>如果我们想禁用一个特定的自动配置，我们可以使用@EnableAutoConfiguration注解的exclude属性来设置它。</p>

<p>例如，这个代码片断禁用了DataSourceAutoConfiguration:</p>

<pre><code>// other annotations
@EnableAutoConfiguration(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
</code></pre>

<p>如果我们用@SpringBootApplication注解启用了自动配置&ndash;该注解将@EnableAutoConfiguration作为元注解&ndash;我们可以用同名的属性禁用自动配置:</p>

<pre><code>// other annotations
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
public class MyConfiguration { }
</code></pre>

<p>我们也可以用spring.autoconfigure.exclude环境属性禁用自动配置。在application.properties文件中的配置与之前做的设置是做相同的事情:</p>

<pre><code>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
</code></pre>

<h2>Q7. 如何注册一个自定义的自动配置？</h2>

<p>要注册一个自动配置类，我们必须在META-INF/spring.factories文件的EnableAutoConfiguration键下列出其完全限定名称:</p>

<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.baeldung.autoconfigure.CustomAutoConfiguration
</code></pre>

<p>如果我们用Maven构建项目，该文件应放在resources/META-INF目录下，在打包阶段最终会出现在上述位置。</p>

<h2>Q8. 如何告诉自动配置在Bean存在时退缩？</h2>

<p>为了指示自动配置类在Bean已经存在时退缩，我们可以使用 @ConditionalOnMissingBean 注解。</p>

<p>这个注解最值得注意的属性是:</p>

<ul>
<li>value &ndash; 要检查的Bean的类型</li>
<li>name &ndash; 要检查的bean的名字</li>
</ul>


<p>当放在一个用@Bean装饰的方法上时，目标类型默认为该方法的返回类型:</p>

<pre><code>@Configuration
public class CustomConfiguration {
    @Bean
    @ConditionalOnMissingBean
    public CustomService service() { ... }
}
</code></pre>

<h2>Q9. 如何将Spring Boot Web应用部署为Jar和War文件？</h2>

<p>传统上，我们将Web应用打包成WAR文件，然后将其部署到外部服务器上。这样做可以让我们在同一台服务器上安排多个应用程序。在CPU和内存稀缺的时候，这是一个节省资源的好方法。</p>

<p>但事情已经发生了变化。现在计算机硬件相当便宜，人们的注意力已经转向服务器配置。在部署过程中，配置服务器的一个小错误可能会导致灾难性的后果。</p>

<p>Spring通过提供一个插件，即spring-boot-maven-plugin，将网络应用打包成可执行的JAR，来解决这个问题。</p>

<p>要包含这个插件，只需在pom.xml中添加一个插件元素:</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
</code></pre>

<p>有了这个插件，我们在执行打包阶段后会得到一个扁平的JAR。这个JAR包含所有必要的依赖，包括一个嵌入式服务器。因此，我们不再需要担心配置外部服务器的问题。</p>

<p>然后我们可以像运行普通的可执行JAR一样运行该应用程序。</p>

<p>注意，pom.xml文件中的打包元素必须设置为jar来构建JAR文件:</p>

<pre><code>&lt;packaging&gt;jar&lt;/packaging&gt;
</code></pre>

<p>如果我们不包括这个元素，它也默认为jar。</p>

<p>要构建一个WAR文件，我们把包装元素改为war:</p>

<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;
</code></pre>

<p>并将容器的依赖关系从打包的文件中删除:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>在执行Maven打包阶段后，我们会有一个可部署的WAR文件。</p>

<h2>Q10. 如何在命令行应用程序中使用Spring Boot？</h2>

<p>就像其他Java程序一样，Spring Boot命令行应用程序必须有一个main方法。</p>

<p>这个方法作为一个入口点，它调用<code>SpringApplication#run</code>方法来启动应用程序:</p>

<pre><code>@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class);
        // other statements
    }
}
</code></pre>

<p>然后SpringApplication类启动Spring容器并自动配置Bean。</p>

<p>注意我们必须向run方法传递一个配置类，作为主要的配置源。按照惯例，这个参数就是入口类本身。</p>

<p>在调用运行方法后，我们可以像普通程序一样执行其他语句。</p>

<h2>Q11. 外部配置的可能来源是什么？</h2>

<p>Spring Boot提供了对外部配置的支持，使我们能够在不同的环境中运行同一个应用程序。我们可以使用属性文件、YAML文件、环境变量、系统属性和命令行选项参数来指定配置属性。</p>

<p>然后，我们可以使用@Value注解、通过<a href="https://www.baeldung.com/configuration-properties-in-spring-boot">@ConfigurationProperties注解</a>的绑定对象或环境抽象来访问这些属性。</p>

<h2>Q12. Spring Boot支持宽松的绑定是什么意思？</h2>

<p>Spring Boot中的宽松绑定适用于<a href="https://www.baeldung.com/configuration-properties-in-spring-boot">配置属性的类型安全绑定</a>。</p>

<p>通过宽松的绑定，属性的键不需要与属性名完全匹配。这样的环境属性可以用camelCase、kebab-case、snake_case，或者用大写字母，用下划线隔开单词。</p>

<p>例如，如果一个带有 @ConfigurationProperties 注解的 bean 类中的一个属性被命名为 myProp，它可以被绑定到这些环境属性中的任何一个：myProp、my-prop、my_prop 或 MY_PROP。</p>

<h2>Q13. Spring Boot DevTools的用途是什么？</h2>

<p>Spring Boot开发者工具，或称DevTools，是一套使开发过程更容易的工具。</p>

<p>为了包括这些开发时的功能，我们只需要在pom.xml文件中添加一个依赖项:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>如果应用程序在生产中运行，spring-boot-devtools模块会自动禁用。重新打包的归档文件也默认排除了这个模块。所以，它不会给我们的最终产品带来任何开销。</p>

<p>默认情况下，DevTools应用适合于开发环境的属性。这些属性禁用了模板缓存，启用了网络组的调试日志，诸如此类。因此，我们有了这种合理的开发时配置，而无需设置任何属性。</p>

<p>只要classpath上的文件发生变化，使用DevTools的应用程序就会重新启动。这在开发中是一个非常有帮助的功能，因为它可以快速反馈修改情况。</p>

<p>默认情况下，静态资源，包括视图模板，不会引发重启。相反，资源变化会触发浏览器刷新。请注意，只有在浏览器中安装了LiveReload扩展，以便与DevTools包含的嵌入式LiveReload服务器进行交互时，这才会发生。</p>

<p>关于这一主题的进一步信息，请参见<a href="https://www.baeldung.com/spring-boot-devtools">Spring Boot DevTools概述</a>。</p>

<h2>Q14. 如何编写集成测试？</h2>

<p>在为Spring应用程序运行集成测试时，我们必须有一个ApplicationContext。</p>

<p>为了让我们的生活更轻松，Spring Boot为测试提供了一个特殊的注解&ndash;@SpringBootTest。该注解从其classes属性所指示的配置类中创建一个ApplicationContext。</p>

<p>如果classes属性没有设置，Spring Boot会搜索主要的配置类。搜索从包含测试的包开始，直到找到一个用@SpringBootApplication或@SpringBootConfiguration注解的类。</p>

<p>有关详细说明，请查看我们的<a href="https://www.baeldung.com/spring-boot-testing">Spring Boot测试教程</a>。</p>

<h2>Q15. Spring Boot Actuator的用途是什么？</h2>

<p>从本质上讲，Actuator通过启用生产就绪的功能，使Spring Boot应用程序活起来。这些功能使我们能够在应用程序在生产中运行时监控和管理它们。</p>

<p>将Spring Boot Actuator集成到一个项目中非常简单。我们所要做的就是在pom.xml文件中包括spring-boot-starter-actuator启动器:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>Spring Boot Actuator可以使用HTTP或JMX端点来暴露操作信息。但大多数应用程序都会选择HTTP，其中端点的身份和/actuator前缀构成了一个URL路径。</p>

<p>下面是Actuator提供的一些最常见的内置端点。</p>

<ul>
<li><strong>env</strong> 暴露环境属性</li>
<li><strong>health</strong> 显示应用程序的健康信息</li>
<li><strong>httptrace</strong> 显示HTTP跟踪信息</li>
<li><strong>info</strong> 显示任意的应用程序信息</li>
<li><strong>metrics</strong> 显示度量信息</li>
<li><strong>loggers</strong> 显示并修改应用程序中的记录器配置</li>
<li><strong>mappings</strong> 显示所有@RequestMapping路径的列表</li>
</ul>


<p>请参考我们的<a href="https://www.baeldung.com/spring-boot-actuators">Spring Boot Actuator教程</a>，了解详细情况。</p>

<h2>Q16. 配置Spring Boot项目时，属性和YAML哪个更好？</h2>

<p>与属性文件相比，YAML有很多优点。</p>

<ul>
<li>更加清晰，可读性更好</li>
<li>非常适合分层的配置数据，也可以用更好、更易读的格式来表示</li>
<li>支持地图、列表和标量类型</li>
<li>可以在同一个文件中包含多个<a href="https://www.baeldung.com/spring-profiles">配置文件</a>（从Spring Boot 2.4.0开始，属性文件也可以这样做了）</li>
</ul>


<p>但是，由于它的缩进规则，编写它可能有点困难，而且容易出错。</p>

<p>有关细节和工作样本，请参考我们的<a href="https://www.baeldung.com/spring-yaml-vs-properties">Spring YAML与属性</a>教程。</p>

<h2>Q17. Spring Boot提供了哪些基本注解？</h2>

<p>Spring Boot提供的主要注释位于org.springframework.boot.autoconfigure及其子包中。</p>

<p>以下是一些基本的注释：</p>

<ul>
<li><strong>@EnableAutoConfiguration</strong> &ndash; 使Spring Boot在其classpath上寻找自动配置 Bean 并自动应用它们。</li>
<li><strong>@SpringBootApplication</strong> &ndash; 表示Boot Application的主类。该注解将@Configuration、@EnableAutoConfiguration和@ComponentScan注解与它们的默认属性结合起来。</li>
</ul>


<p><a href="https://www.baeldung.com/spring-boot-annotations">Spring Boot注解</a>提供了对这一主题的更多见解。</p>

<h2>Q18. 如何改变Spring Boot中的默认端口？</h2>

<p>我们可以通过以下方式改变嵌入Spring Boot中的服务器的默认端口。</p>

<ul>
<li>使用属性文件 &ndash; 我们可以在application.properties（或application.yml）文件中使用属性server.port来定义。</li>
<li>通过编程 &ndash; 在我们的主@SpringBootApplication类中，我们可以在SpringApplication实例上设置server.port。</li>
<li>使用命令行 &ndash; 当以jar文件的形式运行应用程序时，我们可以将server.port设置为java命令参数:</li>
</ul>


<pre><code>java -jar -Dserver.port=8081 myspringproject.jar
</code></pre>

<h2>Q19. Spring Boot支持哪些嵌入式服务器，以及如何改变默认值？</h2>

<p>截至目前，Spring MVC支持Tomcat、Jetty和Undertow。Tomcat是Spring Boot的Web Starter支持的默认应用服务器。</p>

<p>Spring WebFlux支持Reactor Netty、Tomcat、Jetty和Undertow，其中Reactor Netty为默认。</p>

<p>在Spring MVC中，如果要改变默认，比方说改变为Jetty，我们需要排除Tomcat，在依赖关系中包括Jetty:</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p>同样，要把WebFlux的默认值改为UnderTow，我们需要排除Reactor Netty，并把UnderTow纳入依赖关系。</p>

<p><a href="https://www.baeldung.com/spring-boot-servlet-containers">比较Spring Boot中的嵌入式Servlet容器</a>有更多关于我们可以在Spring MVC中使用的不同嵌入式服务器的细节。</p>

<h2>Q20. 为什么我们需要Spring Profiles？</h2>

<p>在为企业开发应用程序时，我们通常要处理多种环境，如开发、QA和生产。这些环境的配置属性是不同的。</p>

<p>例如，我们可能在开发中使用嵌入式H2数据库，但开发中可能有专有的Oracle或DB2。即使DBMS在不同的环境中是相同的，URLs也肯定是不同的。</p>

<p>为了使这个问题简单明了，Spring提供了配置文件，以帮助分离每个环境的配置。因此，可以将这些属性保存在不同的文件中，如application-dev.properties和application-prod.properties，而不是通过编程来维护这些属性。默认的application.properties使用spring.profiles.active指向当前活动的配置文件，这样就可以获得正确的配置。</p>

<p><a href="https://www.baeldung.com/spring-profiles">Spring Profiles</a>给出了关于这个主题的全面观点。</p>

<h1>3. 总结</h1>

<p>本文介绍了技术面试中可能出现的关于Spring Boot的一些最关键问题。</p>

<p>我们希望这些问题能够帮助你找到理想的工作。</p>

<h1>4. 原文</h1>

<ul>
<li><a href="https://www.baeldung.com/spring-boot-interview-questions">Spring Boot Interview Questions</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
