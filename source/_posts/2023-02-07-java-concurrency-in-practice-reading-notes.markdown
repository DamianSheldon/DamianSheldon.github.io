---
layout: post
title: "Java Concurrency in Practice Reading Notes"
date: 2023-02-07 16:42:01 +0800
comments: true
categories: [Archives, Web Development]
keywords: Concurrency, java, Synchronized, Volatile, Lock, Atomic
description: Java Concurrency in Practice Reading Notes
published: false
---

Java 并发编程实战 (Java Concurrency in Practice) 是一本介绍 Java 并发编程知识的优秀书籍，我阅读几遍后觉得里面的知识如满天繁星，虽然作者在书中穿插了很多总结，但我觉得他没有想完全体系化地来总结 Java 并发编程，而是假设读者有一定的并发编程基础了，本文我试图体系化的来总结一下 Java 并发编程，将这些知识安放到对应的地方，成体系的知识更容易记忆，也更容易应用。  

既然说到并发，那我们首先就要问什么是并发？这需要回顾计算机的发展历史。  

计算机的发明是源于人们对计算的需求，早期的计算就是很狭隘的数学计算，现在已经泛化。

在早期的计算机中不包含操作系统，它们从头到尾只执行一个程序，并且这个程序能访问计算机中的所有资源。在这种裸机环境中，不仅很难编写和运行程序，而且每次只能运行一个程序，这对于昂贵并且稀有的计算机资源来说也是一种浪费。  

那么如何避免这种浪费呢？我们自然而然会想到如果能同时运行多个程序那不就可以避免浪费。计算机先驱自然也想到了这个想法，于是诞生了操作系统。  

操作系统的出现使得计算机每次能运行多个程序，并且不同的程序都在单独的进程中运行：操作系统为各个独立执行的进程分配各种资源，包括内存，文件句柄以及安全证书等。如果需要的话，在不同的进程之间可以通过一些粗粒度的通信机制来交换数据，包括：套接字、信号处理器、共享内存、信号量以及文件等。  

促使进程出现的因素（资源利用率、公平性以及便利性等）同样也促使着线程的出现。线程允许在同一个进程中同时存在多个程序控制流。线程提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。  

并发这个词的字面意思是同时发生，只是这个同时发生是在用户的角度来看，在操作系统这一侧则可能是通过时间片或者调度到不同的处理器核来实现的。这种调度对应就是线程模型，所以并发本质上就是通过使用线程模型来封装我们的计算任务来让它同时发生。  

那么这么做会遇到些什么问题呢？
<!--more-->
线程会共享进程范围内的资源，例如内存和文件句柄，但每个线程都有各自的程序计数器（Program Counter）、栈以及局部变量等。由于同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。

对共享数据的访问应该来说是所有并发问题的源头，更糟糕地是现代计算机为了满足人们对于快速完成计算任务的需求演变得更加复杂。例如指令重排序，又或者由于时钟频率越来越难以提高，因此许多处理器制造厂商都开始转而生产多核处理器，因为能够提高的只有硬件并行性。而各个处理器为了提高性能，也会采用流水线的超标量执行单元，动态指令调度，猜测执行以及完备的多级缓存。  

我们先来看怎么解决线程竞争？答案是使用同步机制。同步机制可以分为两类：一类是锁；另一类是 CAS(Compare-and-Swap) ；锁属于阻塞的同步机制，拥有锁的线程可以独占地访问变量。锁的缺点是挂起和恢复线程存在很大开销，对于细粒度操作来说不划算。于是产生另一种想法，在硬件层提供原子更新变量的支持，用来支持细粒度操作。

现在可以协调线程的竞争了，但是对共享变量的访问还没解决？  

假设一个线程为变量aVariable赋值：  

```
aVariable = 3；
```

“在什么条件下，读取aVariable的线程将看到这个值为 3 ？”这听起来似乎是一个愚蠢的问题，但是指令重排序，处理器缓存都可能导致一个线程无法看到变量的最新值。为了解决这个问题，Java 设计者们设计了 Java 内存模型(JMM)，JMM 规定了 JVM 必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见。

JMM 为程序中所有的操作定义了一个偏序关系，称之为 Happens-Before。要想保证执行操作 B 的线程看到操作 A 的结果（无论 A 和 B 是否在同一个线程中执行），那么在 A 和 B 之间必须满足 Happens-Before 关系。

Happens-Before的规则包括：

* 程序顺序规则。如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行。
* 监视器锁规则。在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。
* volatile变量规则。对volatile变量的写入操作必须在对该变量的读操作之前执行。
* 线程启动规则。在线程上对Thread.Start的调用必须在该线程中执行任何操作之前执行。
* 线程结束规则。线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者在调用Thread.isAlive时返回false。
* 中断规则。当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行（通过抛出InterruptedException，或者调用isInterrupted和interrupted）。
* 终结器规则。对象的构造函数必须在启动该对象的终结器之前执行完成。
* 传递性。如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。

现在我们知道线程之间是不是能看到共享变量的最新值了，这些构成了我们并发编程的基础知识。  

下面我们继续基于这些基础知识来实际编程。前面我们说过并发编程的问题根源是共享可变状态的访问。如果我们的计算任务能不共享可变状态，或者共享不可变状态，那这样的任务在并发执行时同样也不会有问题。  

那不共享可变状态有哪些做法呢？不共享意味着独享，像局部变量就只有线程自己能访问，所以它们是线程安全的。  

```

public int loadTheArk(Collection<Animal> candidates) { SortedSet<Animal> animals;
int numPairs = 0;
Animal candidate = null;
// animals confined to method, don’t let them escape!
animals = new TreeSet<Animal>(new SpeciesGenderComparator()); animals.addAll(candidates);
for (Animal a : animals) {
if (candidate == null || !candidate.isPotentialMate(a)) candidate = a;
else {
ark.load(new AnimalPair(candidate, a)); ++numPairs;
candidate = null;
} }
    return numPairs;
}
```

另外就是利用 ThreadLocal 为每个线程复制一份变量，这样也能独享。

```
private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<Connection>() {
public Connection initialValue() {
return DriverManager.getConnection(DB_URL);
} };
public static Connection getConnection() { return connectionHolder.get();
}
```

但是并不是所有的计算任务都可以不共享可变状态，有的计算任务需要共享状态，这其中有一类是可以共享不可变状态的任务。  

状态可以简单可复杂，简单的就是基本类型，复杂则需要我们自定义类的对象。基本类型加上 final 标识后就是不可变的了，所以这里我们重点需要讨论的是对象。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。  

当满足以下条件时，对象才是不可变的：  

* 对象创建以后其状态就不能修改。  
* 对象的所有域都是final类型。  
* 对象是正确创建的（在对象的创建期间，this引用没有逸出）。

所以我们定义不可变类时可以遵守上述规则。  

有些任务必须共享可变状态，对这类任务，我们编程时应该做呢？这时候会要求我们类是线程安全的，那如何设计线程安全的类呢？  

我们设计新类时通常是已有的类不能满足需求，这时我们有可能有几种选择，一种是扩展现有的类；另一种则完全定义一个新的类。不管是哪种情况，通常我们是需要为类增加新的字段，让这些字段来表达新的状态，以满足某种新的需求。  

由于设计的类的实例对象会被多个线程共享访问，那么我们必须在多个线程访问之前，之中和之后，对象是处于有效的状态，不然由于对象字段上的数据是错误的，那么程序实现的功能是会有错误。对象在多个线程访问之前要处于有效状态就要求对象是正确的创建。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，多个线程访问时则要求对象保持不变性。后验条件（Postcondition）是来描述对象操作的结果，所以多个线程访问之后后验条件应该也没被破坏。  

正确的创建重点是关注在对象创建期间，this 引用没有逸出。而不变性条件和后验条件都需求同步机制，只是可以根据情况选择轻量级的 CAS 或锁，某些情况也可以使用 volatile，这里的重点是站在操作系统这侧去看多个线程同时去访问对象时，它是否可以总是保持它的不变性和后验性。

我们也可以这个角度来审视作者的总结，在设计线程安全类的过程中，需要包含以下三个基本要素：  

* 找出构成对象状态的所有变量。  
* 找出约束状态变量的不变性条件。  
* 建立对象状态的并发访问管理策略。

设计线程安全的类是为了后续来使用，使用则要求能从应用的对象图能访问到它，这称为发布。安全的发布依赖于 Happens-Before 规则。安全发布的常用模式有：  

* 在静态初始化函数中初始化一个对象引用。  
* 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。  
* 将对象的引用保存到某个正确构造对象的final类型域中。  
* 将对象的引用保存到一个由锁保护的域中。

好了，现在我们理解了多线程之间的竞争，但除了竞争，它们之间还应该要协作。因为任务之间可能会有依赖，又或者一个任务很大，需要将它分解成多个小任务来计算，最后根据小任务的结果得出最终结果。  

一个典型的例子是依赖状态的操作，例如，不能从一个空的队列中删除元素，或者获取一个尚未结束的任务的计算结果，在这些操作可以执行之前，必须等到队列进入“非空”状态，或者任务进入“已完成”状态。这种情况下从队列中获取元素的线程就需要等待，像这种一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真，它有一个正式的名字 -- 条件队列。每个 Java 对象都可以作为一个锁，每个对象同样可以作为一个条件队列，并且 Object 中的 wait、notify 和 notifyAll 方法就构成了内置条件队列的API。  

内置条件队列存在一些缺陷。每个内置锁都只能有一个相关联的条件队列，多个线程可能在同一个条件队列上等待不同的条件谓词，并且在最常见的加锁模式下公开条件队列对象。这些因素都使得无法满足在使用notifyAll 时所有等待线程为同一类型的需求。如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多控制权，就可以使用显式的 Lock 和 Condition 而不是内置锁和条件队列，这是一种更灵活的选择。  

现在我们可以看清楚一件事，操作系统通过调度线程来实现并发，而锁和原子变量是我们约束它们调度的有效工具。它们都是基于底层的硬件支持，锁是基于测试并设置（Test-and-Set），获取并递增（Fetch-and-Increment）以及交换（Swap）等指令；原子变量则是基于比较并交换（Compare-and-Swap）或者关联加载/条件存储（Load-Linked/Store-Conditional）。  

锁和原子变量都很基础，标准类库为我们提供很多工具类，能减少很多常见需求的编码，它们都经过很严格的测试，我们应该尽可能的去使用它们。下面我们来看看这些工具类。  


除了工具类，类库还提供了一个任务执行框架。  


活跃性问题
性能问题




