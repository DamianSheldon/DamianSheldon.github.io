<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS Development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-06-27T22:19:17+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Properties]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties/"/>
    <updated>2014-06-24T15:28:20+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties</id>
    <content type="html"><![CDATA[<h3>Properties</h3>

<p>“Properties associate values with a particular class, structure, or enumeration. ” &mdash; Apple</p>

<h4>Type Properties</h4>

<p>属于类型本身的properties称为Type Property.</p>

<p>1)Value Type Properties (keyword: static)<br/>
structrue, enumeration可以定义Stroed 和Computed type properties.</p>

<p>Stored type properties for value types can be variables or constants.<br/>
NOTE:Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<p>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</p>

<p>2)Reference Type Properties (keyword: class)<br/>
class只可以定义Computed type properties.</p>

<h4>Instance Properties</h4>

<p>1)Stroed Properties
In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</p>

<p>P.S:A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p>2)Computed Properties
computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>

<h3>Properties Observer</h3>

<p>Property observers observe and respond to changes in a property’s value.</p>

<p>You have the option to define either or both of these observers on a property:</p>

<p>willSet is called just before the value is stored.<br/>
didSet is called immediately after the new value is stored.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Initialization]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-initialization/"/>
    <updated>2014-06-24T11:33:28+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-initialization</id>
    <content type="html"><![CDATA[<h3>Initialization</h3>

<p>“Initialization is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that is required before the new instance is ready to for use.” &mdash; Apple Inc.</p>

<p>从苹果的介绍我们可以得出初始化的两个要点:<br/>
1，为实例的每一个存储属性设置初始值;  <br/>
2，进行其他必要的准备工作.</p>

<p>这里我们主要总结下为实例的存储属性设置初始值。Class, Structure, enumeration的初始化略有不同，主要是因为Class可以继承，而这背后的原因是Class是Reference Type,而Structure, enumeration是Value Type。</p>

<h3>Value Type Initialization</h3>

<p>1)为存储属性设置默认值；</p>

<pre><code>Swift会为设置了所有存储属性默认值而没有提供初始化方法的structure提供Default Initializer。
structure在所有存储属性都设置了默认值的情况下自动接受Memberwise Initializer。
</code></pre>

<p>2)初始化方法。</p>

<pre><code>NOTE: Swift会自动将初始化方法的本地参数名生成外部参数名。
</code></pre>

<h3>Reference Type Initialization</h3>

<p>1)为类引入的存储属性设置初始值;<br/>
2)初始化方法。</p>

<pre><code>Designated initializers must always delegate up.
Convenience initializers must always delegate across.

Swift中子类默认是不继承父类的初始化方法,然而当满足一定条件时例外。
Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:

Rule 1
If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers.

Rule 2
If your subclass provides an implementation of all of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers.

These rules apply even if your subclass adds further convenience initializers.

NOTE:子类可以是用Convenience Initializer实现父类的Designated Initializer.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Concurrency Programming--GCD]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/21/ios-concurrency-programming-gcd/"/>
    <updated>2014-05-21T11:40:27+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/21/ios-concurrency-programming-gcd</id>
    <content type="html"><![CDATA[<h2>GCD是什么？</h2>

<p>GCD是Grand Central Dispatch的缩写，它是用来执行自定义的任务的C接口机制。它可以串行或并行地执行任务，并大大简化了相应的线程代码。它的优点有：<br/>
* 直接简单的编程接口；<br/>
* 自动、整体的线程池管理；<br/>
* 高效的内存管理；<br/>
* 负载时不干扰内核；<br/>
* 异步分发任务到分派队列不会造成死锁；<br/>
* 优雅地处理竞争；<br/>
* 串行分派队列为锁和其他同步操作提供了更高效选择；</p>

<h2>如何使用GCD？</h2>

<p>GCD抽象出来了几组高效的的API,我们使用这些API来完成我们的工作。</p>

<h3>1）单个任务；</h3>

<p>我们通常是通过调用以下API来执行任务：
<code>objective-c
dispatch_async
dispatch_async_f
dispatch_sync
dispatch_sync_f
dispatch_after
dispatch_after_f
dispatch_apply
dispatch_apply_f
dispatch_once
</code></p>

<p>调用这些API之前，我们还要准备好dispatch queue.通常可以通过以下的API创建和管理Queues:
<code>objective-c
dispatch_get_global_queue
dispatch_get_main_queue
dispatch_queue_create
dispatch_get_current_queue
dispatch_queue_get_label
dispatch_set_target_queue
dispatch_main
</code></p>

<p>dispatch queues主要有三大类：main queue, Concurrent queue, Serial queue;</p>

<p>i)main queue:通过dispatch_get_main_queue(void)可以取到main queue;</p>

<p>ii)Concurrent queue:通过dispatch_queue_t dispatch_get_global_queue(long priority,unsigned long flags)可以取得全局的并发队列。总共有四个优先级的全局队列：
 DISPATCH_QUEUE_PRIORITY_HIGH      <br/>
 DISPATCH_QUEUE_PRIORITY_DEFAULT
 DISPATCH_QUEUE_PRIORITY_LOW      <br/>
 DISPATCH_QUEUE_PRIORITY_BACKGROUND</p>

<p>iii）Serial queue:可以使用dispatch_queue_create创建串行或并行队列。</p>

<p>代码示例：
``` objective-c
// i) main queue
dispatch_queue_t mainQueue = dispatch_get_main_queue(void);</p>

<p>// ii)Concurrent Queue
dispatch_queue defaultGlobalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>// iii)Serial queue
dispatch_queue_t myCustomSerialQueue = dispatch_queue_create(&ldquo;com.example.MyCustomSerialQueue&rdquo;, NULL);</p>

<p>// async
dispatch_async(myCustomSerialQueue, ^{</p>

<pre><code>printf("Do some work here.\n");
</code></pre>

<p>});</p>

<p>// sync
dispatch_sync(myCustomSerialQueue, ^{</p>

<pre><code>printf("Do some more work here.\n");
</code></pre>

<p>});
printf(&ldquo;Both blocks have completed.\n&rdquo;);</p>

<p>// apply
for (i = 0; i &lt; count; i++) {
   printf(&ldquo;%u\n&rdquo;,i);
}</p>

<p>// equlivent implement</p>

<p>dispatch_apply(count, defaultGlobalConcurrentQueue, ^(size_t i) {
   printf(&ldquo;%u\n&rdquo;,i);
});
```</p>

<h3>2）组任务；</h3>

<p>可以使用以下API进行组操作：
<code>objective-c
dispatch_group_async
dispatch_group_async_f
dispatch_group_create
dispatch_group_enter
dispatch_group_leave
dispatch_group_notify
dispatch_group_notify_f
dispatch_group_wait
</code>
代码示例：
``` objective-c
// Example 1
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>dispatch_group_t group = dispatch_group_create();</p>

<p>// Add a task to the group
dispatch_group_async(group, queue, ^{
   // Some asynchronous work
});</p>

<p>// Do some other work while the tasks execute.</p>

<p>// When you cannot make any more forward progress,
// wait on the group to block the current thread.
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</p>

<p>// Release the group when it is no longer needed.
dispatch_release(group);</p>

<p>// Example 2
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
[self doWorkOnArray:array];</p>

<p>```</p>

<h3>3）使用Dispatch Semaphores调控有效的资源使用；</h3>

<p>Dispatch Semaphores相关的API如下：
<code>objective-c
dispatch_semaphore_create
dispatch_semaphore_signal
dispatch_semaphore_wait
</code>
代码示例：
```objective-c
// Create the semaphore, specifying the initial pool size
dispatch_semaphore_t fd_sema = dispatch_semaphore_create(getdtablesize() / 2);</p>

<p>// Wait for a free file descriptor
dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);
fd = open(&ldquo;/etc/services&rdquo;, O_RDONLY);</p>

<p>// Release the file descriptor when done
close(fd);
dispatch_semaphore_signal(fd_sema);
```</p>

<h2>Reference</h2>

<p>o Concurrency Programming Guide<br/>
o iOS多线程编程Part 3/3 &ndash; GCD;<a href="http://www.hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/">http://www.hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的绘图系统]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/19/iosde-hui-tu-xi-tong/"/>
    <updated>2014-05-19T16:47:22+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/19/iosde-hui-tu-xi-tong</id>
    <content type="html"><![CDATA[<h2>iOS的绘图框架</h2>

<p>1)UIKit是Objective-C形式的API，提供基本的2D图形绘制，图片处理，和一些实现用户界面元素动画的方法；</p>

<p>2)Core Graphics是C形式的API，支持向量图形，位图和PDF内容；</p>

<p>3)Core Animation是另一个Objective-C形式的API,它能为用户界面增加流畅的移动和动态的反馈效果；</p>

<p>4)OpenGL ES 是移动端版本的OpenGL,它能实现高性能的2D和3D图形绘制。</p>

<h2>Drawing Destinations(iOS-Only)</h2>

<p>1)View Graphics Context<br/>
2)Layer<br/>
3)Bitmap<br/>
4)PDF<br/>
5)Printer</p>

<h2>Drawing to a View Graphics Context in iOS</h2>

<p>1)Implement drawRect:method;<br/>
2)Mark the view you want update by invocate setNeedDisplay;<br/>
3)Obtain Graphic context by Call UIGraphicsGetCurrentContext method;<br/>
4)Use UIKit provides functions, UIBezierPath or Core Graphics to meet your need.</p>

<p>``` objective-c
// 1) UIKit method
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
[path addLineToPoint:CGPointMake(0.4, 18.05)];
[path addLineToPoint:CGPointMake(18.8, -0.47)];
[path addLineToPoint:CGPointMake(37.21, 18.05)];
[path addLineToPoint:CGPointMake(34.31, 20.83)];
[path addLineToPoint:CGPointMake(20.88, 7.22)];
[path addLineToPoint:CGPointMake(20.88, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 7.22)];
[path closePath];
path.lineWidth = 1;
[[UIColor redColor] setStroke];
[path stroke];</p>

<p>// 2) Core Graphics method
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
CGContextAddLineToPoint(ctx, 0.4, 18.05);
CGContextAddLineToPoint(ctx, 18.8, -0.47);
CGContextAddLineToPoint(ctx, 37.21, 18.05);
CGContextAddLineToPoint(ctx, 34.31, 20.83);
CGContextAddLineToPoint(ctx, 20.88, 7.22);
CGContextAddLineToPoint(ctx, 20.88, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 7.22);
CGContextClosePath(ctx);
CGContextSetLineWidth(ctx, 1);
CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextStrokePath(ctx);
```</p>

<h2>Drawing to a Layer(CGLayer)</h2>

<p>A layer context (CGLayerRef) is an offscreen drawing destination associated with another graphics context. It is designed for optimal performance when drawing the layer to the graphics context that created it. A layer context can be a much better choice for offscreen drawing than a bitmap graphics context.</p>

<p>1)“Create a CGLayer Object Initialized with an Existing Graphics Context”<br/>
2)“Get a Graphics Context for the Layer”<br/>
3)“Draw to the CGLayer Graphics Context”<br/>
4)“Draw the Layer to the Destination Graphics Context”</p>

<h2>Drawing to a BitMap</h2>

<p>A bitmap graphics context accepts a pointer to a memory buffer that contains storage space for the bitmap. When you paint into the bitmap graphics context, the buffer is updated. After you release the graphics context, you have a fully updated bitmap in the pixel format you specify.</p>

<p>1)Creating a Bitmap Graphics Context;<br/>
UIGraphicsBeginImageContextWithOptions() or CGBitmapContextCeate()<br/>
2)Draw code.</p>

<p>``` objective-c
// 1) Mix call UIKit and Core Graphics</p>

<p>UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
&hellip;
CGContextStrokePath(ctx);
UIGraphicsEndImageContext();</p>

<p>// 2) Core Graphics
CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);
CGContextScaleCTM(ctx, 0.5, 0.5);
UIGraphicsPushContext(ctx);
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
&hellip;
[path stroke];
UIGraphicsPopContext(ctx);
CGContextRelease(ctx);
```</p>

<h2>Concurrency Drawing</h2>

<p>``` objective-c
UIImageView <em>view; // assume we have this
NSOperationQueue </em>renderQueue; // assume we have this
CGSize size = view.bounds.size;
[renderQueue addOperationWithBlock:^(){</p>

<pre><code>    UIImage *image = [renderer renderInImageOfSize:size];
    [[NSOperationQueue mainQueue] addOperationWithBlock:^(){
        view.image = image;
    }];
</code></pre>

<p>}];</p>

<ul>
<li><p>(UIImage *)renderInImageOfSize:(CGSize)size;
{
  UIGraphicsBeginImageContextWithOptions(size, NO, 0);</p>

<p>  // do drawing here</p>

<p>  UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();
  return result;
}
```</p></li>
</ul>


<h2>Reference</h2>

<p>o Quartz 2D Programming Guide<br/>
o 绘制像素到屏幕上 <a href="http://objccn.io/issue-3-1/">http://objccn.io/issue-3-1/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS UIWebView与JavaScript交互]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/14/ios-uiwebviewyu-javascriptjiao-hu/"/>
    <updated>2014-05-14T11:05:53+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/14/ios-uiwebviewyu-javascriptjiao-hu</id>
    <content type="html"><![CDATA[<h2>1.UIWebView调用JavaScript</h2>

<h3>1.1调用html中已有的JavaScript function</h3>

<p>假设html中的JavaScript有名为JSFunction(arg)的函数，可用如下方法调用：
``` objective-c
NSString *js = [NSString stringWithFormat:@&ldquo;JSFunction(&lsquo;OC&mdash;-Call&mdash;>JS&rsquo;)&rdquo;];</p>

<p>NSString *result = [self.webView stringByEvaluatingJavaScriptFromString:js];
```</p>

<h3>1.2注入JavaScript function,然后调用</h3>

<p>我们还可以先向html中注入JavaScript function,然后调用。
通常可以在UIWebViewDelegate中注入。示例如下：
``` objective-c
&ndash;(void)webViewDidFinishLoad:(UIWebView *)webView {</p>

<pre><code>[self.webView stringByEvaluatingJavaScriptFromString:@"function injectJSFunction (parameter) { return parameter + 1;}"];
</code></pre>

<p>}</p>

<p>// Call injectJSFunction from somewhere else</p>

<pre><code>NSString *result = [self.webView stringByEvaluatingJavaScriptFromString:@"injectJSFunction(1)"];
</code></pre>

<p>```</p>

<h2>2.JavaScript调用Objective-C Method</h2>

<p>JavaScript调用Objective-C方法的原理是利用UIWebView的重定向请求，传一些命令到我们的UIWebView,在UIWebView的delegate的方法中接收这些命令，并根据命令执行相应的Objc方法。示例如下：
``` javascript
function sendCommand(cmd,param){</p>

<pre><code>var url="objc:"+cmd+":"+param;  
document.location = url;  
</code></pre>

<p>}<br/>
function clickLink(){</p>

<pre><code>sendCommand("alert","hello objective-c method");  
</code></pre>

<p>}<br/>
<code>
</code> objective-c</p>

<h1>pragma mark &mdash;</h1>

<h1>pragma mark UIWebViewDelegate</h1>

<ul>
<li><p>(BOOL)webView:(UIWebView <em>)webView shouldStartLoadWithRequest:(NSURLRequest </em>)request navigationType:(UIWebViewNavigationType)navigationType {</p>

<p>  NSString <em>requestString = [[request URL] absoluteString];<br/>
  NSArray </em>components = [requestString componentsSeparatedByString:@&ldquo;:&rdquo;];<br/>
  if ([components count] > 1 &amp;&amp; [(NSString <em>)[components objectAtIndex:0] isEqualToString:@&ldquo;objc&rdquo;]) {<br/>
      if([(NSString </em>)[components objectAtIndex:1] isEqualToString:@&ldquo;alert&rdquo;]) <br/>
      {<br/>
          UIAlertView *alert = [[UIAlertView alloc] <br/>
                                initWithTitle:@&ldquo;Alert from Cocoa Touch&rdquo; message:[components objectAtIndex:2]<br/>
                                delegate:self cancelButtonTitle:nil<br/>
                                otherButtonTitles:@&ldquo;OK&rdquo;, nil];<br/>
          [alert show];<br/>
      }<br/>
      return NO;<br/>
  }<br/>
  return YES;<br/>
}
```</p>

<h2>3.相互传值</h2>

<h2>3.1UIWebView传值给JavaScript</h2>

<p>1）最简单的方法是将参数作为URL的一部分，然后在delegate方法里截取出来。这种方法只能传简单的参数，如果是一个很复杂的对象，那么URL的编解码会很复杂。
2）PhoneGap的解决方法是把要传递的参数放到队列里，然后通知Native去取。</p></li>
</ul>


<h2>3.2JavaScript传值给UIWebView</h2>

<p>UIWebView调用JavaScript接口方法的返回值就是JavaScript传给UIWebView的值。示例如下：
<code>objective-c
NSString *result = [self.webView stringByEvaluatingJavaScriptFromString:@"injectJSFunction(1)"];
</code></p>
]]></content>
  </entry>
  
</feed>
