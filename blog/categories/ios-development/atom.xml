<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS Development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2015-01-21T16:22:44+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Technical Interview Part 1]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-technical-interview-part-1.html/"/>
    <updated>2015-01-05T15:44:07+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-technical-interview-part-1</id>
    <content type="html"><![CDATA[<h3>Explain method swizzling. When you would use it?</h3>

<h3>Take three objects: a grandparent, parent and child. The grandparent retains the parent, the parent retains the child and the child retains the parent. The grandparent releases the parent. Explain what happens.</h3>

<p>Answer:循环保留导致内存泄漏。</p>

<h3>What happens when you invoke a method on a nil pointer?</h3>

<p>Answer:返回0</p>

<p>Reference:<a href="http://nshipster.com/nil/">http://nshipster.com/nil/</a></p>

<h3>Give two separate and independent reasons why retainCount should never be used in shipping code.</h3>

<blockquote><p>There should be no reason to explicitly ask an object what its retain count is (see retainCount). The result is often misleading, as you may be unaware of what framework objects have retained an object in which you are interested. In debugging memory management issues, you should be concerned only with ensuring that your code adheres to the ownership rules.</p></blockquote>

<ol>
<li>结果不正确，因为你不知道框架中哪些对象已经引用了你感兴趣的对象;</li>
<li>产品代码中不应该包含无用代码。</li>
</ol>


<h3>Explain your process for tracing and fixing a memory leak.</h3>

<ol>
<li>Set the NSZombieEnabled argument in your executable options, which sometimes helps narrow down the cause</li>
<li>Run with Apple Instruments such as Leaks to look for memory issues</li>
</ol>


<p>Reference:<a href="http://www.raywenderlich.com/2696">http://www.raywenderlich.com/2696</a></p>

<h3>Explain how an autorelease pool works at the runtime level.</h3>

<h3>When dealing with property declarations, what is the difference between atomic and non-atomic?</h3>

<p>atomic是指存在竞争赋值时，我们会得到某次完整的赋值，而nonatomic则可能是几次赋值共同组合。</p>

<p>```
@property CGRect domain;</p>

<p><b>thread 1:</b> puppy.domain = CGRectMake (1.0, 2.0, 3.0, 4.0);
<b>thread 2:</b> puppy.domain = CGRectMake (10.0, 20.0, 30.0, 40.0);</p>

<p>atomic意味着在竞争赋值的情况下得到的结果是CGRectMake (1.0, 2.0, 3.0, 4.0)或者CGRectMake (10.0, 20.0, 30.0, 40.0)。</p>

<p>noatomic情况得到的结果可能是CGRectMake (1.0, 2.0, 30.0, 40.0)这种两次组合的乱码。</p>

<p>```
再进一步，atomic是不是意味着代码是线程安全的呢？不是。atomic修饰符可以保证property的读写操作是串行的，但如果对象的指针不是atomic修饰的，代码仍然不是线程安全的。</p>

<h3>In C, how would you reverse a string as quickly as possible?</h3>

<h3>Which is faster: to iterate through an NSArray or an NSSet?</h3>

<p>NSArray</p>

<p>Reference:<a href="http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html">http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html</a></p>

<h3>Explain how code signing works.</h3>

<h3>What is posing in Objective-C?</h3>

<h3>List six instruments that are part of the standard.</h3>

<ol>
<li>Allocations</li>
<li>Core Animation</li>
<li>Leaks</li>
<li></li>
</ol>


<h3>What are the differences between copy and retain?</h3>

<p>copy是新创建一个对象副本；retain则是对象引用计数加一。</p>

<h3>What is the difference between frames and bounds?</h3>

<blockquote><p>The frame property contains the frame rectangle, which specifies the size and location of the view in its superview’s coordinate system.
The bounds property contains the bounds rectangle, which specifies the size of the view (and its content origin) in the view’s own local coordinate system.</p></blockquote>

<h3>What happens when the following code executes? Ball *ball = [[[[Ball alloc] init] autorelease] autorelease];</h3>

<p>The object gets released twice when the autorelease pool is destroyed.</p>

<p>Reference:<a href="http://stackoverflow.com/questions/11291801/autoreleasing-twice-an-object">http://stackoverflow.com/questions/11291801/autoreleasing-twice-an-object</a></p>

<h3>List the five iOS app states.</h3>

<table>
<thead>
<tr>
<th></th>
<th> State </th>
<th> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Not Running </td>
<td> The app has not been launched or was running but was terminated by the system.</td>
</tr>
<tr>
<td></td>
<td> Inactive </td>
<td> The app is running in the foreground but is currently not receiving events. (It may be executing other code though.) An app usually stays in this state only briefly as it transitions to a different state.</td>
</tr>
<tr>
<td></td>
<td> Active </td>
<td> The app is running in the foreground and is receiving events. This is the normal mode for foreground apps.</td>
</tr>
<tr>
<td></td>
<td> Background </td>
<td> The app is in the background and executing code. Most apps enter this state briefly on their way to being suspended. However, an app that requests extra execution time may remain in this state for a period of time. In addition, an app being launched directly into the background enters this state instead of the inactive state. For information about how to execute code while in the background</td>
</tr>
<tr>
<td></td>
<td> Suspended </td>
<td> The app is in the background but is not executing code. The system moves apps to this state automatically and does not notify them before doing so. While suspended, an app remains in memory but does not execute any code.</td>
</tr>
</tbody>
</table>


<p>When a low-memory condition occurs, the system may purge suspended apps without notice to make more space for the foreground app.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App如何与Server安全交互]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-does-app-security-communicate-with-server.html/"/>
    <updated>2014-12-15T11:53:11+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-does-app-security-communicate-with-server</id>
    <content type="html"><![CDATA[<p>大多数App都需和Server通信来提供服务，这中间就牵涉到网络通信安全。网络通信安全是一个很大的话题，本文不打算全面覆盖，而是来理理HTTPS。</p>

<p>移动设备可能会处于不安全的网络环境中，比如连接了某个公共热点，攻击者不需要访问设备，只需访问设备所在的网络，就能获取到用户信息，所以，当应用中用户的信息需要保护时，开发者需要保证通信的安全性。</p>

<p>最简单直接的解决办法是采用HTTPS,在web服务器上安装一个自签名证书，启用HTTPS,然后对NSURLConnection进行配置以接受该自签名证书。</p>

<p>HTTPS是如何做到通信安全的呢？答案是TLS/SSL协议。TLS(Transport Layer Security)/SSL(Secure Socket  Layer)协议是专门为解决网络通信安全设计的。它的基石是非对称加密。</p>

<p>TLS/SSL链路中的数据是加密的，客户端给服务器发送的数据是用服务器的公钥加密的，由于非对称加密的数学特性，只有拥有私钥的服务器才能正确解密数据。服务器给客户端发送的数据则是用自己的私钥加密的，客户端用公钥解密。</p>

<p>那么我们如何判断服务器发给我们的公钥是值得信任的呢？通常商业网站的数字证书都是由中级证书或根证书来签名，而根证书是一开始就内置在设备中，不是通过网络交换的，这样当某个服务器声明说我是某某，我们可以通过证书链来判断真伪。</p>

<p>根证书其实是一个自签名证书，我们的应用也可以用自签名证书来确保网络通信安全，还可以省掉很大一笔证书费用，只要私钥足够安全，它甚至比商业证书更安全。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App State Preservation and Restoration]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-state-preservation-and-restoration.html/"/>
    <updated>2014-12-08T11:55:48+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-state-preservation-and-restoration</id>
    <content type="html"><![CDATA[<ol>
<li>什么是State Preservation and Restoration？</li>
<li>为什么要用State Preservation and Restoration？</li>
<li>如何使用State Preservation and Restoration？</li>
</ol>


<h3>什么是State Preservation and Restoration？</h3>

<p>State Preservation and Restoration组成UIKit的state preservation system，它提供简单而灵活的架构来保存和恢复应用的视图控制器和视图。</p>

<h3>为什么要用State Preservation and Restoration？</h3>

<blockquote><p>Even if your app supports background execution, it cannot run forever. At some point, the system might need to terminate your app to free up memory for the current foreground app. However, the user should never have to care if an app is already running or was terminated. From the user’s perspective, quitting an app should just seem like a temporary interruption. When the user returns to an app, that app should always return the user to the last point of use, so that the user can continue with whatever task was in progress. This behavior provides a better experience for the user and with the state restoration support built in to UIKit is relatively easy to achieve.</p></blockquote>

<p>即使你的应用支持后台运行，它也不可能一直运行。某个时刻，系统也许需要终止你的应用为当前应用释放内存。然而，用户应该永远不用关心应用是已经运行或终止。从用户的角度来看，退出应用应该就像暂时的中断。当用户回到应用，它应该回到上次使用的状态，以便用户能继续任何正在进行的任务。这种行为为用户提供了更好的体验，UIKit内置了这种状态恢复支持很容易就能实现。</p>

<!-- more -->


<h3>如何使用State Preservation and Restoration？</h3>

<p>State Restoreation成功的前提条件如下： <br/>
1. <strong>状态保留必须成功。</strong>也就是说应用终止前必须进入后台运行状态。 <br/>
2. <strong>应用不可以强制退出。</strong> <br/>
3. <strong>从最近一次状态保留开始，应用必须没有启动失败过。</strong></p>

<p>Checklist for Implementing State Preservation and Restoration</p>

<ol>
<li>(Required) Implement the <code>application:shouldSaveApplicationState:</code> and <code>application:shouldRestoreApplicationState:</code>methods in your app delegate;</li>
<li>(Required) Assign restoration identifiers to each view controller you want to preserve by assigning a non empty string to their <code>restorationIdentifier</code> property;If you want to save the state of specific views too, assign non empty strings to their <code>restorationIdentifier</code> properties;</li>
<li>(Required) Show your app’s window from the <code>application:willFinishLaunchingWithOptions:</code> method of your app delegate. The state restoration machinery needs the window so that it can restore scroll positions and other relevant bits of your app’s interface.</li>
<li>Assign restoration classes to the appropriate view controllers. (If you do not do this, your app delegate is asked to provide the corresponding view controller at restore time.)</li>
<li>(Recommended) Encode and decode the state of your views and view controllers using the <code>encodeRestorableStateWithCoder:</code> and <code>decodeRestorableStateWithCoder:</code> methods of those objects;</li>
<li>Encode and decode any version information or additional state information for your app using the <code>application:willEncodeRestorableStateWithCoder:</code> and <code>application:didDecodeRestorableStateWithCoder:</code> methods of your app delegate;</li>
<li>Objects that act as data sources for table views and collection views should implement the <strong>UIDataSourceModelAssociation</strong> protocol. Although not required, this protocol helps preserve the selected and visible items in those types of views.</li>
</ol>


<h3>注意事项</h3>

<div style="text-align: center" markdown="1">

    <img name="state_vc_caveats_2x" src="http://DamianSheldon.github.io/images/state_vc_caveats_2x.png" width="594" height="862">

</div>


<p>上图有颜色的视图控制器的状态是不会被保存和恢复的。</p>

<h3>Reference</h3>

<p>App Programming Guide for iOS</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何创建自定义的Xcode 6 工程模板]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-to-creating-custom-xcode-6-project-templates.html/"/>
    <updated>2014-12-05T14:34:04+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-to-creating-custom-xcode-6-project-templates</id>
    <content type="html"><![CDATA[<p>使用Xcode 6新建工程时，Apple准备了好些模板，这些模板写个Demo还是没有问题的，但是用来组织项目文件还是太弱了，所以情况经常是不得不每次去新建各种目录，这种重复性的劳动一来乏味，二来浪费时间。那么我们能不像创建自己的模板呢？这样新建的工程就能按自己的想法包含各种目录和文件。好消息是可以，坏消息是Apple没有提供相应的文档。虽然没有文档，还是试着来创建一个模板，每次都重复实在太烦（就是这么任性）。</p>

<p>既然没有文档，我们就把Apple的模板复制一份，在它的基础上修改成我们需要的样子。<strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/</strong>有iOS所有工程模板。用户自定义的模板建议放到<strong>~/Library/Developer/Xcode/Templates/</strong>，目录如果不存在就创建。模板至少要包含两部分：一是扩展名为<strong>.xctemplate</strong>的文件夹；二是名称为<strong>TemplateInfo.plist</strong>的属性列表文件。好了，我们来创建一个自定义模板：</p>

<p>```
// Step 1:
$ mkdir ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>// Step 2:
$ cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/Single\ View\ Application.xctemplate/* ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>```</p>

<!-- more -->


<p>现在我们有了一个和Single View Application一样的模板，但这和我们目标还相差很远。接下来我们要做就是修改<strong>TemplateInfo.plist</strong>，让模板为我们做更多准备工作。</p>

<table>
<thead>
<tr>
<th></th>
<th> Keys </th>
<th> Advice </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Ancestors   </td>
<td> No          | Import settings from another Project Template.</td>
</tr>
<tr>
<td></td>
<td> Concrete    </td>
<td> Recommended | Visible or hide Template form New Project Window.</td>
</tr>
<tr>
<td></td>
<td> Definitions </td>
<td> No          | Work with workplace. Can write to file example source code.</td>
</tr>
<tr>
<td></td>
<td> Description </td>
<td> Recommended | New Project Window &ndash; Project Template Description.</td>
</tr>
<tr>
<td></td>
<td> Identifier  </td>
<td> Yes         | Project Template Unique Identifier.</td>
</tr>
<tr>
<td></td>
<td> Kind        </td>
<td> Yes         | XCode Template Kind. Project or File.</td>
</tr>
<tr>
<td></td>
<td> Nodes       </td>
<td> Recommended | Create or Copy Files to Project. Copy works</td>
</tr>
<tr>
<td></td>
<td> Options     </td>
<td> Recommended | New Project Wizard >> Choose Options for Project. Add Text Fields, Combo Boxes.</td>
</tr>
<tr>
<td></td>
<td> Platforms   </td>
<td> Recommended | Set Platform.</td>
</tr>
<tr>
<td></td>
<td> Project     </td>
<td> Yes         | Set Project Build Settings.</td>
</tr>
<tr>
<td></td>
<td> Targets     </td>
<td> Recommended | Set Build Settings, Build Phases for Targets. Link Libraries.</td>
</tr>
</tbody>
</table>


<p>上面列出了TemplateInfo.plist大部分键，详细介绍在<a href="https://snipt.net/yonishin/about-xcode-4-project-template/">这里</a>。</p>

<p>我自己新建的模板主要用到Definitions和Nodes，它们俩组合起来可以控制模板会新建哪些文件。例如我想让模板包含Models目录：</p>

<p>```
// Step 1:
$ cd ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>// Step 2:
$ mkdir -p Models</p>

<p>// Step 3: 编辑TemplateInfo.plist 如下图所示。</p>

<p>```</p>

<div style="text-align: center" markdown="1">

    <img name="PropertyList" src="http://DamianSheldon.github.io/images/PropertyList.png" width="623" height="836">

</div>


<p>完整的模板放在<a href="https://github.com/DamianSheldon/Xcode-6-Project-Templates">这里</a>。</p>

<h2>Reference</h2>

<p><a href="http://meandmark.com/blog/2011/12/creating-custom-xcode-4-project-templates/">Creating Custom Xcode 4 Project Templates</a><br/>
<a href="https://snipt.net/yonishin/about-xcode-4-project-template/">About XCode 4 Project Template (How To Create Custom Project Template)</a><br/>
<a href="https://github.com/reidmain/Xcode-6-Project-Templates">Xcode-6-Project-Templates</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App Cache]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-cache.html/"/>
    <updated>2014-11-25T16:36:04+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-cache</id>
    <content type="html"><![CDATA[<p>在互联网时代的今天，iOS App几乎都要联网，缓存可以解决网络连接不良甚至无网络所造成的性能问题，而且还可以节约用户的流量。我们可以采用两种缓存策略：预缓存和按需缓存。预缓存就是应用启动以后开个后台线程去把需要用到的数据先取下来。按需缓存就是应用请求网络数据后在本地保存一份，只要本地数据没有过期就使用本地数据。</p>

<h3>预缓存</h3>

<p>实现预缓存可能需要一个后台线程访问数据并以有意义的格式保存，以便本地缓存无需连接服务器即可被编辑。Core Data(或者任何结构化存储)是实现这种缓存的一种方式。</p>

<h3>按需缓存</h3>

<p>按需缓存工作原理类似于浏览器缓存，它允许我们查看以前访问过的内容，主要有四种实现方法：</p>

<ol>
<li>URL缓存；</li>
<li>数据模型缓存；</li>
<li>Core Data;</li>
<li>SQLite。</li>
</ol>


<p>上述的序号是推荐使用的顺序。</p>

<h4>URL缓存</h4>

<p>如果服务器设计得体，遵循HTTP 1.1的缓存规范时，URL缓存效果最好，通常网络库会提供支持。</p>

<!-- more -->


<h4>数据模型缓存</h4>

<p>数据模型缓存是把模型对象用NSKeyedArchiver归档，模型类需要实现NSCoding协议。</p>

<p>使用数据模型缓存时，有个小技巧，可以为它创建内存缓存。这样有两点好处：一是可以延长闪存的使用寿命；二是可以略微提高性能。</p>

<h4>Core Data</h4>

<p>使用Core Data进行按需缓存，需要权衡Core Data的复杂度是否值得。</p>

<h4>SQLite</h4>

<p>使用SQLite时，要注意当前的二进制包是否是线程安全的。</p>

<h2>Reference</h2>

<p>iOS 6 Programming Push the Limits</p>
]]></content>
  </entry>
  
</feed>
