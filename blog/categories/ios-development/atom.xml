<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2019-07-17T08:55:06+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS App Distribution]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-distribution.html"/>
    <updated>2018-12-04T14:33:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-distribution</id>
    <content type="html"><![CDATA[<p>iOS App 有不少分发方法，她们散落在 Apple 的文档中，并未归总到一处，所以本文对她们进行了总结，方便查阅。</p>

<p>首先我们简单梳理下这些分发方法，然后重点说明下 ipa 文件的安装方法。 Apple 制作的这张表格将分发方法归纳得很全：</p>

<table>
<thead>
<tr>
<th> Method </th>
<th style="text-align:left;"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> App Store </td>
<td style="text-align:left;"> Distributes your app through the App Store, signed with an Apple Developer Program distribution provisioning profile. </td>
</tr>
<tr>
<td> Ad Hoc </td>
<td style="text-align:left;"> Distributes your app to testers with registered devices, signed with an ad hoc provisioning profile.<br>The devices need to be registered in your developer account and are limited to 100 devices per product family per year. If you don’t want to use a portion of these development devices for testing, distribute your app using TestFlight instead.<br>If you are a member of the Apple Developer Enterprise Program, choose this option to test your app. Only members of the Apple Developer Program have access to App Store Connect and TestFlight. </td>
</tr>
<tr>
<td> Development </td>
<td style="text-align:left;"> Distributes your app to testers with registered devices, signed with a development provisioning profile. </td>
</tr>
<tr>
<td> Enterprise </td>
<td style="text-align:left;"> Distributes your app to users in your organization, signed with an Apple Developer Enterprise Program distribution provisioning profile. </td>
</tr>
</tbody>
</table>


<p>虽然分发方法有很多，但可以分为两类：一类是通过 App Store 分发；另一类则是在 App Store 外分发。通过 App Store 分发时的流程很统一，都是上传应用到 iTunes Connection，等待审核发布，所以没有什么好说的。但是在 App Store 外发布时选择就多样了，我们既可以走像 App Store 分发那样流程的 TestFlight，也可以导出 ipa 文件然后安装。</p>

<p>下面我们介绍在 iPhone 上安装 ipa 的方法：</p>

<h2>Install using iTunes</h2>

<blockquote><p>iTunes 12.7 for Mac was released on Tuesday with a major change in the app. Apple has redesign iTunes so that it focuses on sales of music, movies, TV shows, audiobooks, and podcasts. It no longer has an App Store for buying apps for your iPhone or iPad. Therefore, you can no long install your iOS App (.ipa file) through iTunes any longer.</p></blockquote>

<ol>
<li>Download the .ipa file after the build completes.</li>
<li>Open iTunes, go to App library.</li>
<li>Drag and drop the downloaded .ipa file into the App library.</li>
<li>Connect your device to iTunes and go to your device apps.</li>
<li>Click Install button of the app and click Sync button. </li>
</ol>


<!--more-->


<h2>Install using Apple Configurator 2</h2>

<ol>
<li>Install Apple Configurator 2 on your Mac from the App Store.</li>
<li>Connect your device to your Mac.</li>
<li>Open Apple Configurator 2, select your device. If you device doesn’t appear here, please make sure that your device is successfully connected to your Mac.</li>
</ol>


<h2>Install using Xcode</h2>

<ol>
<li>Connect your device to your Mac.</li>
<li>Open Xcode, go to Window > Devices .</li>
<li>Then, the Devices screen will appear. Choose the device you want to install the app on.</li>
<li>Drag and drop your .ipa file into the Installed Apps.</li>
</ol>


<h2>Install using OTA Deployment</h2>

<p>OTA (Over-The-Air) Deployment enables you to install your built apps (ad-hoc build) via HTTPS.</p>

<ol>
<li>Download the .ipa file after the build completes.</li>
<li>Upload the .ipa file to the site you want.</li>
<li>Create a .plist file for this built application. The .plist file should look like this:</li>
</ol>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
</span><span class='line'>&lt;!DOCTYPE plist PUBLIC &ldquo;-//Apple//DTD PLIST 1.0//EN&rdquo; &ldquo;&lt;a href="http://www.apple.com/DTDs/PropertyList-1.0.dtd">http://www.apple.com/DTDs/PropertyList-1.0.dtd&lt;/a>&rdquo;>
</span><span class='line'>&lt;plist version="1.0">
</span><span class='line'>&lt;dict>
</span><span class='line'>    &lt;key>items&lt;/key>
</span><span class='line'>    &lt;array>
</span><span class='line'>        &lt;dict>
</span><span class='line'>            &lt;key>assets&lt;/key>
</span><span class='line'>            &lt;array>
</span><span class='line'>                &lt;dict>
</span><span class='line'>                    &lt;key>kind&lt;/key>
</span><span class='line'>                    &lt;string>software-package&lt;/string>
</span><span class='line'>                    &lt;key>url&lt;/key>
</span><span class='line'>                    &lt;string>&lt;a href="https://www.anysite.com/application/your_app.ipa">https://www.anysite.com/application/your_app.ipa&lt;/a>&lt;/string>
</span><span class='line'>                &lt;/dict>
</span><span class='line'>            &lt;/array>
</span><span class='line'>            &lt;key>metadata&lt;/key>
</span><span class='line'>            &lt;dict>
</span><span class='line'>                &lt;key>bundle-identifier&lt;/key>
</span><span class='line'>                &lt;string>com.example.helloworld&lt;/string>
</span><span class='line'>                &lt;key>bundle-version&lt;/key>
</span><span class='line'>                &lt;string>1.0.0&lt;/string>
</span><span class='line'>                &lt;key>kind&lt;/key>
</span><span class='line'>                &lt;string>software&lt;/string>
</span><span class='line'>                &lt;key>title&lt;/key>
</span><span class='line'>                &lt;string>HELLO&lt;/string>
</span><span class='line'>            &lt;/dict>
</span><span class='line'>        &lt;/dict>
</span><span class='line'>    &lt;/array>
</span><span class='line'>&lt;/dict>
</span><span class='line'>&lt;/plist>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
<li>Upload the <code>.plist</code> file to the site you want. Make sure this file must be accessed via HTTPS protocol. </li>
<li>Create a webpage embedded the link to the uploaded <code>.plist</code> file using special <code>itms-services://</code> protocol. See blow example: 
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/li>
</span><span class='line'>&lt;/ol>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;a href="itms-services://?action=download-manifest&url=https://example.com/manifest.plist">Install App&lt;/a></span></code></pre></td></tr></table></div></figure></p>

<p>使用 OTA 方式部署安装，需要自己架设 Web 服务器，目前市面上也有免费提供此安装服务的产品，如 <a href="https://fir.im/">Fir.im</a>，<a href="https://www.pgyer.com/">蒲公英</a>。</p>

<p>如果我们希望自己架设 Web 服务器来提供 OTA 分发，则相应地需要做些配置工作：</p>

<h2>HTTPS</h2>

<p>保证 ipa 文件是通过 HTTPS 访问，所以网站必须是由 iOS 信任的证书签名的。如果是没有信任锚的自签名证书，并且不能被 iOS 设备验证，那么安装会失败。</p>

<h2>Set server MIME types</h2>

<p>你也许需要配置你的 web 服务器以便清单文件和应用文件能正确传输。</p>

<p>For the server, add the MIME types to the web service’s MIME types settings:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>application/octet-stream ipa 
</span><span class='line'>text/xml plist</span></code></pre></td></tr></table></div></figure> 
For Microsoft’s Internet Information Server (IIS), use IIS Manager to add the MIME type in the Properties page of the server:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>.ipa application/octet-stream 
</span><span class='line'>.plist text/xml</span></code></pre></td></tr></table></div></figure> </p>

<p>同时，如果设备是连接到一个封闭的内部网络，我们必须保证如下访问：</p>

<h2>Network configuration requirements</h2>

<ul>
<li><a href="https://ax.init.itunes.apple.com:">https://ax.init.itunes.apple.com:</a> The device obtains the current file-size limit for downloading apps over the cellular network. If this website isn’t reachable, installation may fail. </li>
<li><a href="https://ppq.apple.com:">https://ppq.apple.com:</a> The device contacts this website to check the status of the distribution certificate used to sign the provisioning profile. </li>
</ul>


<h1>Reference</h1>

<ul>
<li><p><a href="https://help.apple.com/xcode/mac/current/#/dev31de635e5">Distribution methods</a></p></li>
<li><p><a href="https://web.archive.org/web/20171114184350/https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582-CH1-SW1">App Distribution Guide</a></p></li>
<li><p><a href="https://docs.monaca.io/en/products_guide/monaca_ide/deploy/non_market_deploy/#install-using-ota-deployment">Non-market App Distribution</a></p></li>
<li><p><a href="https://help.apple.com/deployment/ios/#/apda0e3426d7">Distribute in-house apps from a web server</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Blocks 的实现]]></title>
    <link href="http://DamianSheldon.github.io/blog/the-implementation-of-blocks.html"/>
    <updated>2018-09-01T15:42:34+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/the-implementation-of-blocks</id>
    <content type="html"><![CDATA[<p>Block 的实现是面试中高频出现的问题，背后的原因我想是希望借此考察面试者对 Block 的掌握程度，在日后的工作中能够用好它；同时能从侧面反映面试者有没有深入钻研技术，以及独立思考能力如何，可谓一举多得。</p>

<p>下面我们就来看看 ObjC 中的 Blocks 是如何实现。Clang 的 <code>-rewrite-objc</code> 选项可以将含有 Block 语法的源代码转换为 C++，说是 C++，其实也仅使用了 struct 结构，其本质是 C 语言。</p>

<p>下面我们先转换一个简单的文件试试:</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, char ** argv)
{
    @autoreleasepool {
        void (^blk)(void) = ^{
            printf("Block\n");
        };

        blk();
    }    

    return 0;
}

// 使用命令:
$ clang -fobjc-arc -ObjC -rewrite-objc -mios-version-min=6.0.0 -fobjc-runtime=ios-6.0.0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk -arch arm64 block-essense.m  -o block-essense-in-c.c

//限于篇幅，省略不相关的部分，结果如下:
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

            printf("Block\n");
        }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, char ** argv)
{
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));

        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    }

    return 0;
}
</code></pre>

<!--more-->


<p>可以看到持有 block 的变量实际上就是指针，而 block 本身则是结构体，在我们的例子中对应的是 <code>__main_block_impl_0</code>,功能代码则是通过函数来实现的，block 结构体内有成员变量指向该函数，这样我们对 block 的实现渐渐清晰起来了。</p>

<p>Block 有一个重要的特性&ndash;自动捕获变量。这又是怎么实现的呢？我们同样可以使用上述的方法来得到答案。我们构造一个捕获变量的例子，然后来查看它的结果：</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, char ** argv)
{
    @autoreleasepool {

        BOOL flag = YES;
        int i = 28;
        float pi = 3.1415;
        char c = 'x';

        void (^blk)(void) = ^{
            printf("Block\n");
            printf("flag:%d\n", flag);
            printf("i:%d\n", i);
            printf("pi:%d\n", pi);
            printf("c:%d\n", c);
        };

        blk();
    }

    return 0;
}

// 转换之后相关部分
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  BOOL flag;
  int i;
  float pi;
  char c;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, BOOL _flag, int _i, float _pi, char _c, int flags=0) : flag(_flag), i(_i), pi(_pi), c(_c) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  BOOL flag = __cself-&gt;flag; // bound by copy
  int i = __cself-&gt;i; // bound by copy
  float pi = __cself-&gt;pi; // bound by copy
  char c = __cself-&gt;c; // bound by copy

            printf("Block\n");
            printf("flag:%d\n", flag);
            printf("i:%d\n", i);
            printf("pi:%d\n", pi);
            printf("c:%d\n", c);
        }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, char ** argv)
{
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        BOOL flag = ((bool)1);
        int i = 28;
        float pi = 3.1415;
        char c = 'x';

        void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, flag, i, pi, c));

        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    }

    return 0;
}
</code></pre>

<p>可以看到自动捕获的标量数据是直接声明为 block 结构体的成员变量。</p>

<p>除了读取捕获自动变量的值，block 还支持使用 <code>__block</code> 修饰符来修改自动捕获的变量。我们同样来看个例子：</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, char ** argv)
{
    @autoreleasepool {

        __block BOOL flag = YES;
        __block int i = 28;
        __block float pi = 3.1415;
        __block char c = 'x';

        void (^blk)(void) = ^{
            printf("Block\n");

            flag = NO;
            i = 88;
            pi = 3.1415926;
            c = 'a';

            printf("flag:%d\n", flag);
            printf("i:%d\n", i);
            printf("pi:%f\n", pi);
            printf("c:%d\n", c);
        };

        blk();
    }

    return 0;
}

// 转换之后相关部分的结果:
struct __Block_byref_flag_0 {
  void *__isa;
__Block_byref_flag_0 *__forwarding;
 int __flags;
 int __size;
 BOOL flag;
};
struct __Block_byref_i_1 {
  void *__isa;
__Block_byref_i_1 *__forwarding;
 int __flags;
 int __size;
 int i;
};
struct __Block_byref_pi_2 {
  void *__isa;
__Block_byref_pi_2 *__forwarding;
 int __flags;
 int __size;
 float pi;
};
struct __Block_byref_c_3 {
  void *__isa;
__Block_byref_c_3 *__forwarding;
 int __flags;
 int __size;
 char c;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_flag_0 *flag; // by ref
  __Block_byref_i_1 *i; // by ref
  __Block_byref_pi_2 *pi; // by ref
  __Block_byref_c_3 *c; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_flag_0 *_flag, __Block_byref_i_1 *_i, __Block_byref_pi_2 *_pi, __Block_byref_c_3 *_c, int flags=0) : flag(_flag-&gt;__forwarding), i(_i-&gt;__forwarding), pi(_pi-&gt;__forwarding), c(_c-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_flag_0 *flag = __cself-&gt;flag; // bound by ref
  __Block_byref_i_1 *i = __cself-&gt;i; // bound by ref
  __Block_byref_pi_2 *pi = __cself-&gt;pi; // bound by ref
  __Block_byref_c_3 *c = __cself-&gt;c; // bound by ref

            printf("Block\n");

            (flag-&gt;__forwarding-&gt;flag) = ((bool)0);
            (i-&gt;__forwarding-&gt;i) = 88;
            (pi-&gt;__forwarding-&gt;pi) = 3.1415926;
            (c-&gt;__forwarding-&gt;c) = 'a';

            printf("flag:%d\n", (flag-&gt;__forwarding-&gt;flag));
            printf("i:%d\n", (i-&gt;__forwarding-&gt;i));
            printf("pi:%f\n", (pi-&gt;__forwarding-&gt;pi));
            printf("c:%d\n", (c-&gt;__forwarding-&gt;c));
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;flag, (void*)src-&gt;flag, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;pi, (void*)src-&gt;pi, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;c, (void*)src-&gt;c, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;flag, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;pi, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;c, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, char ** argv)
{
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        __attribute__((__blocks__(byref))) __Block_byref_flag_0 flag = {(void*)0,(__Block_byref_flag_0 *)&amp;flag, 0, sizeof(__Block_byref_flag_0), ((bool)1)};
        __attribute__((__blocks__(byref))) __Block_byref_i_1 i = {(void*)0,(__Block_byref_i_1 *)&amp;i, 0, sizeof(__Block_byref_i_1), 28};
        __attribute__((__blocks__(byref))) __Block_byref_pi_2 pi = {(void*)0,(__Block_byref_pi_2 *)&amp;pi, 0, sizeof(__Block_byref_pi_2), 3.1415};
        __attribute__((__blocks__(byref))) __Block_byref_c_3 c = {(void*)0,(__Block_byref_c_3 *)&amp;c, 0, sizeof(__Block_byref_c_3), 'x'};

        void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_flag_0 *)&amp;flag, (__Block_byref_i_1 *)&amp;i, (__Block_byref_pi_2 *)&amp;pi, (__Block_byref_c_3 *)&amp;c, 570425344));

        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    }

    return 0;
}
</code></pre>

<p>可以看到使用 <code>__block</code> 修饰的变量实际上转换成了结构体变量，同样在 block 结构体中有成员变量指向它们。</p>

<p>上面我们看过了使用 block 时的几种情况，我们可以尝试来总结使用 block 的情况，然后查看各种情况转换之后的代码来进一步探索 block 的实现，进而得到比较完善的答案。</p>

<p>首先 block 可以按是否捕获变量分为两大类，其次捕获变量时根据是否支持修改又可以分为两类，最后捕获变量又可以分为程序的数据区域、栈上和堆上三种情况。综上，我们可以得到得到如下的 block 分类列表:</p>

<ul>
<li>不捕获变量(1)</li>
<li><p>捕获变量</p>

<ul>
<li><p>不修改捕获的变量</p>

<ul>
<li>存在程序数据区的变量(2)</li>
<li>存在栈上的变量(3)</li>
<li>存在堆上的变量(4)</li>
</ul>
</li>
<li><p>修改捕获的变量(<code>__block</code> 修饰的变量)</p>

<ul>
<li>存在程序数据区的变量(5)</li>
<li>存在栈上的变量(6)</li>
<li>存在堆上的变量(7)</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>这样算下来应该是存在七种情况，我们可以分别构造各种情况的例子，然后得到 block 的实现全貌。</p>

<p>全局变量和 static 变量是程序数据区变量，block 中访问全局变量和在其他地方没有什么不同，所以 block 的实现中不需要对它进行特别考虑。Static 变量在捕获时会在 block 结构体中有对应的成员变量，可以用该成员变量来读写。由于它在程序的生命周期中一直存在，所以当 block 捕获并修改它时，不需要生成对应的结构体变量，这和其他 <code>__block</code> 修饰的变量不同。</p>

<p>情况三和四比较类似，它们都会在 block 结构体中增加相应的成员变量，不同之处是捕获堆上的变量， block 的描述结构体变量中会增加 copy 和 dipose 函数，用来管理对应的内存。</p>

<p>情况六和七也类似，它们都是将变量转换为结构体，然后在 block 结构体增加成员变量指向它们。捕获堆上的变量时，block 内的成员变量指向变量，而这个变量是指向堆上分配的一块内存的，也就是一个对象，对象就是一块内存区域嘛，用代码示例如下：</p>

<pre><code class="objc">blk_t blk;

{
  __block id __strong array = [[NSMutableArray alloc] init];

  blk = [^(id obj){

      [array addObject:obj];
      NSLog(@"array count = %ld", [array count]);

  } copy];
}

// __block 修饰指向 array 的变量
struct __Block_byref_array_0 {
  void *__isa;
__Block_byref_array_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 __strong id array;
};

// 表示 block 的结构体
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_array_0 *array; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_array_0 *_array, int flags=0) : array(_array-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre>

<p>看到这里，我们有了 block 捕获变量出了作用域后还能存在原因的线索，当表示 block 的结构体从栈上拷贝到堆上，如果是只读变量，它的值赋值给 block 结构体的成员变量了；如果是 <code>__block</code> 修饰的变量，表示该变量的结构体也会一并拷贝到堆上，并由 block 持有和管理。</p>

<p>至此，我们应该对 block 的实现比较清晰了。</p>

<h2>Reference</h2>

<ul>
<li>Objective-C 高级编程</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程的 Core Data]]></title>
    <link href="http://DamianSheldon.github.io/blog/concurrency-with-core-data.html"/>
    <updated>2018-02-23T16:00:35+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/concurrency-with-core-data</id>
    <content type="html"><![CDATA[<p>平常在项目中没有使用过 Core Data, 因为我觉得它的学习曲线还挺陡峭，整个框架给人的感觉很复杂和笨重，因此一直没有使用它。但是看到喵神这份<a href="https://onevcat.com/2013/04/ios-interview/">上级向的十个 iOS 开发面试题</a>中和这份<a href="http://studentdeng.github.io/blog/2014/02/11/baidu-interview/">百度面试</a>题中都有涉及到 Core Data 的内容，我想还是有必要好好研究一下它，毕竟它是 Apple 官方的持久化方案，我们可以取其精华，弃其糟粕，另一方面未来我们也可能因为各种原因接手或参与使用 Core Data 的项目。</p>

<p>这篇文章主要想探讨上面提到的面试题中的两个关于 Core Data 的问题:</p>

<ol>
<li>你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？</li>
<li>Core Data：中多线程中处理大量数据同步时的操作。</li>
</ol>


<p>在回答这两个问题之前，我们先看 Apple 是怎么告诉我们使用多线程的 Core Data 的，在最新的(2017-03-27) Core Data Programming Guide 中有一节 Concurrency with Core Data，它没有直接说如何使用多线程，只是说了 managed object context 在多线程中的两种使用模式:</p>

<blockquote><p>In Core Data, the managed object context can be used with two concurrency patterns, defined by NSMainQueueConcurrencyType and NSPrivateQueueConcurrencyType.</p>

<p>NSMainQueueConcurrencyType is specifically for use with your application interface and can only be used on the main queue of an application.</p>

<p>The NSPrivateQueueConcurrencyType configuration creates its own queue upon initialization and can be used only on that queue. Because the queue is private and internal to the NSManagedObjectContext instance, it can only be accessed through the performBlock: and the performBlockAndWait: methods.</p></blockquote>

<!--more-->


<p>对于多线程中对象的传递则有这么一段描述:</p>

<blockquote><p>NSManagedObject instances are not intended to be passed between queues. Doing so can result in corruption of the data and termination of the application. When it is necessary to hand off a managed object reference from one queue to another, it must be done through NSManagedObjectID instances.</p>

<p>You retrieve the managed object ID of a managed object by calling the objectID method on the NSManagedObject instance.</p></blockquote>

<p>从这里我们知道，NSManagedObject 是不能在线程中传递的，必须重新创建。但是对于 NSPersistentStoreCoordinator 和 NSManagedObjectContext 是需要创建还是可以传递就不是很清楚。</p>

<p>于是我又通读了全篇，说实话我看完以后还是没搞明白该如何使用多线程的 Core Data，于是我又找了 Apple 提供的多线程的 Core Data 示例代码 <a href="https://developer.apple.com/library/content/samplecode/ThreadedCoreData/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010723">ThreadedCoreData</a>，它展示了一种使用多线程的 Core Data 的方法，但是并不能解答如何使用多线程的 Core Data。因为可能还有很多其他的方法，我们要溯本求源，找到问题的关键，问题才能迎刃而解。 于是我又到 <a href="https://objccn.io">objc 中国</a>上查找，里面专门有一个 Core Data 的专题，先看了一遍<a href="https://objccn.io/issue-4-5/">导入大数据集</a>，它提供了一些解答问题2的素材，我们稍候将它总结为答案，同时它还提供了新的线索 &ndash; <a href="http://objccn.io/issue-2-2/">在后台使用 Core Data</a>，于是我又看了这篇文章。</p>

<p>这篇文章提到在使用多线程的 Core Data 时，强烈建议先通读 Apple 的官方文档 Concurrency with Core Data，这也是符合学习 iOS 开发新知识的路线的，毕竟所有的知识都源于 Apple，这种方法推荐给大家，而我一开始也是这么做的，这里的问题是 Apple 的文档一直在更新，有的内容在新版本文档中被删除了，那么我们有办法找到旧版本的文档吗？</p>

<p>有的，这里介绍一种方法，虽然 Apple 不提供旧版本的文档，但是有个网址&ndash;<a href="https://archive.org/web/">Internet Archive</a>它会定期备份整个互联网上重要的网址，所以我们可以结合文档的修改历史在这里找到旧版本的文档，我们看到在后台使用 Core Data 翻译于 2014/03/22，我们不妨先试下 2014-03-10 这个版本的 Core Data Programming Guide.</p>

<p>这个版本是这么介绍如何使用多线程的 Core Data 的:</p>

<blockquote><p>The pattern recommended for concurrent programming with Core Data is thread confinement : each thread must have its own entirely private managed object context.</p>

<p>There are two possible ways to adopt the pattern:</p>

<ol>
<li>Create a separate managed object context for each thread and share a single persistent store coordinator.</li>
</ol>


<p>This is the typically-recommended approach.</p>

<ol>
<li>Create a separate managed object context and persistent store coordinator for each thread.</li>
</ol>


<p>This approach provides for greater concurrency at the expense of greater complexity (particularly if you need to communicate changes between different contexts) and increased memory usage.</p></blockquote>

<p>个人认为这个版本的介绍更清晰明了，也更容易得出问题的答案：</p>

<p>NSManagedObjectContext 和 NSManagedObject 是需要在线程中创建的，而 NSPersistentStoreCoordinator 是推荐传递的。策略则是创建两个线程，不妨分别称它们为工作线程和后台线程，工作线程为主，后台线程为辅，它们分别创建自己独立的 managed object context，然后共享同一个 persistent store coordinator,工作线程关注 NSManagedObjectContextDidSaveNotification 通知，当后台线程保存更改时，它便收到通知然后合并更改。代码示例如下：</p>

<pre><code class="objc">// Worker Thread
_mainManagedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
 // observe the APLEarthQuakeSource save operation with its managed object context
 [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(mergeChanges:)
                                                 name:NSManagedObjectContextDidSaveNotification
                                               object:nil];

// merge changes to main context,fetchedRequestController will automatically monitor the changes and update tableview.
- (void)updateMainContext:(NSNotification *)notification {

    assert([NSThread isMainThread]);
    [self.managedObjectContext mergeChangesFromContextDidSaveNotification:notification];
}

// this is called via observing "NSManagedObjectContextDidSaveNotification" from our APLEarthQuakeSource
- (void)mergeChanges:(NSNotification *)notification {
    NSLog(@"merge changes be invoked on thread:%@", [NSThread currentThread]);

    if (notification.object != self.managedObjectContext) {
        [self performSelectorOnMainThread:@selector(updateMainContext:) withObject:notification waitUntilDone:NO];
    }
}

// Background Thread
NSManagedObjectContext *private = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType];

[private performBlock:^{ 
    // Do some work
    NSError *error = nil;

    if (![private save:&amp;error]) {
        // Handle error
    }
}]
</code></pre>

<p>这里还补充说明下 managed object context 的并发类型，我们可以用 NSMainQueueConcurrencyType 和 NSPrivateQueueConcurrencyType 来指定它的类型，按照 Apple API reference 中的说明:</p>

<blockquote><p>You use contexts using the queue-based concurrency types in conjunction with performBlock: and performBlockAndWait:. You group “standard” messages to send to the context within a block to pass to one of these methods. There are two exceptions:</p>

<p>  • Setter methods on queue-based managed object contexts are thread-safe. You can invoke these methods directly on any thread.</p>

<p>  • If your code is executing on the main thread, you can invoke methods on the main queue style contexts directly instead of using the block based API.</p></blockquote>

<p>我们可以知道 context 是结合 performBlock: 和 performBlockAndWait: 来使用并发类型的，也就是说 NSMainQueueConcurrencyType 时这两个方法是在主队列上执行 block, 而 NSPrivateQueueConcurrencyType 则是在私有队列上执行。从这里我们推出工作线程的 context 使用 NSMainQueueConcurrencyType 而后台线程的 context 使用 NSPrivateQueueConcurrencyType 应该是比较好的实践，因为我们使用多线程，必然是想获得多线程的好处，如果还指定 context 为 NSMainQueueConcurrencyType，则工作还是在主线程上，并没有被移交到子线程，实际上仍然是单线程。</p>

<p>接下来我们来看第二个问题：</p>

<ul>
<li>Core Data：中多线程中处理大量数据同步时的操作。</li>
</ul>


<p>要想回答这个问题，我们得知道处理大量数据同步时会遇到什么问题，这样才能有的放矢。上面提到<a href="https://objccn.io/issue-4-5/">导入大数据集</a> 提供了回答此问题的素材，再结合<a href="http://objccn.io/issue-2-2/">在后台使用 Core Data</a>，我觉得可以得到问题的一个答案：</p>

<p>如果大量数据的同步不需要反映到界面上，那么我们可以创建一个线程并为它配置独立的 Core Data 栈，然后批量保存；如果需要反映到界面上，则要合并修改通知再更新界面，防止界面陷入卡顿。</p>

<p>正如喵神所说面试中的技术问题环节不仅是企业对应聘者技能和积累的考察，也是一个开发者自我检验的好机会。而且面试中的技术问题通常是关于某知识点的难点，即使是我们经常使用的知识，如果我们没有仔细深入地思考可能也答不上来，所以我觉得利用面试题来提高自己的技术水平和加深对某知识的掌握是不错的方法。</p>

<h3>Reference</h3>

<ul>
<li>Core Data Programming Guide</li>
<li><a href="https://objccn.io/issue-4-5/">导入大数据集</a></li>
<li><a href="https://objccn.io/issue-2-2/">常见的后台实践</a></li>
<li><a href="https://blog.codecentric.de/en/2014/11/concurrency-coredata/">Concurrency with CoreData</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[圆锥渐变的一种简单实现]]></title>
    <link href="http://DamianSheldon.github.io/blog/a-simple-conical-gradient-on-ios.html"/>
    <updated>2017-09-22T15:59:35+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/a-simple-conical-gradient-on-ios</id>
    <content type="html"><![CDATA[<p>Core Graphics 支持两种渐变：线性(Axial)和径向(Radial)渐变，但是有的时候我们可能会用到圆锥(Conical)渐变，例如在扫描附近的目标时，交互可能用上带这种渐变的雷达效果，它长这样：</p>

<p><img src="../images/Conical-1.png" title="&lsquo;Conical-1&rsquo;" ><br/>
<img src="../images/Conical-2.png" title="&lsquo;Conical-2&rsquo;" ></p>

<p>要实现这样一种渐变你会怎么做呢？我的想法是从渐变的本质着手。渐变是从一种颜色渐渐变化成另外一种颜色，而圆锥渐变是根据角度渐渐变化。我们把界面看成位图，这样可以由点的位置得到它的角度，继而根据角度线性插值可以得到它的颜色，最终就可以得到圆锥渐变。</p>

<p>想法有了，接下来我们用它来实现上图中 Find My iPhone 图标的雷达效果吧。</p>

<p>首先定义一个 CALayer 的子类 ConicalLayer，</p>

<!--more-->


<pre><code>// ConicalLayer.h
@interface ConicalLayer : CALayer

/// An array of CGColorRef objects defining the color of each gradient stop. 
@property(copy) NSArray *colors;

@end

// ConicalLayer.m
- (id)init
{
    if (!(self = [super init])) {
        return nil;
    }

    _needsDisplayOnBoundsChange = YES;

    return self;
}

- (void)drawInContext:(CGContextRef)ctx
{
    // Draw background
    CGRect rect = CGContextGetClipBoundingBox(ctx);
    CGContextSetFillColorWithColor(ctx, self.backgroundColor);
    CGContextFillRect(ctx, rect);

    if (self.colors.count &lt; 1) {
        return;
    }
    else if (self.colors.count &lt; 2) {
        // There is only one color so directly draw with it
        CGColorRef color = (__bridge CGColorRef)(self.colors.firstObject);
        CGContextSetFillColorWithColor(ctx, color);
        CGContextFillRect(ctx, rect);
        return;
    }

    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();

    size_t width = rect.size.width;
    size_t height = rect.size.height;

    size_t bitsPerCompoent = 8;
    size_t bytesPerRow = width * 4;

    size_t bitmapByteCount = bytesPerRow * height;

    uint32_t *bitmapData = calloc( bitmapByteCount / sizeof(uint32_t), sizeof(uint32_t) );

    // Map color to linear array each compoent occupy 1 byte
    uint8_t *colorCompoents = calloc(self.colors.count * 4, sizeof(uint8_t));

    for (int i = 0; i &lt; self.colors.count; ++i) {
        CGColorRef c = (__bridge CGColorRef)(self.colors[i]);

        const CGFloat *compoents = CGColorGetComponents(c);

        uint8_t red = compoents[0] * 255;
        uint8_t green = compoents[1] * 255;
        uint8_t blue = compoents[2] * 255;
        uint8_t alpha = compoents[3] * 255;

        int index = i * 4;
        *(colorCompoents + index) = red;
        *(colorCompoents + index + 1) = green;
        *(colorCompoents + index + 2) = blue;
        *(colorCompoents + index + 3) = alpha;
    }

    // Creating a Bitmap Graphics Context for conical gradient
    CGBitmapInfo bitmapInfo = kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Little;

    CGContextRef bitmapGraphicsCtx = CGBitmapContextCreate(bitmapData, width, height, bitsPerCompoent, bytesPerRow, colorSpace, bitmapInfo);

    // Creating conical gradient from a Bitmap Graphics Context
    CGImageRef conicalGradientImage = CGBitmapContextCreateImage(bitmapGraphicsCtx);

    CGContextRelease(bitmapGraphicsCtx);

    free(colorCompoents);

    free(bitmapData);

    CGColorSpaceRelease(colorSpace);

    // Draws conical gradient image into a graphics context.
    CGContextDrawImage(ctx, rect, conicalGradientImage);

    CGImageRelease(conicalGradientImage);

    // Draws three concentric
    CGContextBeginPath(ctx);

    CGFloat halfWidth = 0.5 * CGRectGetWidth(rect);
    CGFloat maxRadii = 0.8 * halfWidth;
    CGFloat radii = floor(0.33 * maxRadii);

    for (int i = 1; i &lt; 4; ++i) {
        CGFloat r = radii * i;
        CGFloat dx = halfWidth - r;
        CGRect ellipseRect = CGRectInset(rect, dx, dx);

        CGContextAddEllipseInRect(ctx, ellipseRect);
    }

    CGContextSetRGBStrokeColor(ctx, 41/255.0, 234/255.0, 35/255.0, 1.0);
    CGContextStrokePath(ctx);
}

- (BOOL)needsDisplayOnBoundsChange
{
    return _needsDisplayOnBoundsChange;
}

- (void)setNeedsDisplayOnBoundsChange:(BOOL)needsDisplayOnBoundsChange
{
}
</code></pre>

<p>现在我们把架子搭起来了，但是还没有往位图里面填充颜色，在这之前，对这段代码稍作解释，首先是我覆盖了needsDisplayOnBoundsChange 属性的 getter 和 setter 方法，原因是我设置图层关联的背景颜色时会触发这个属性变 NO，导致 <code>drawInContext</code> 不会被调用，我认为这是 Apple 的一个 bug，已经作了反馈，所以这里我使用了这么一个绕过的方法。</p>

<p>其次，我把 RGB 颜色空间的颜色分量取出来放在了一个一维数组里用来备用；最后是 bitmapInfo 要或上 kCGBitmapByteOrder32Little，不然结果会不正确。</p>

<p>接下来就是要填充位图的颜色，代码如下：</p>

<pre><code>    // Create conical gradient bitmap data
    CGFloat centerX = width * 0.5;
    CGFloat centerY = height * 0.5;

    double baseAngle = 2*M_PI / (self.colors.count - 1);

    for (int i = 0; i &lt; height; ++i) {
        for (int j = 0; j &lt; width; ++j) {
            CGFloat x = j - centerX;
            CGFloat y = i - centerY;

            // define atan2 uniquely one uses the principal value in the range (−π, π]. That is, −π &lt; atan2(y, x) ≤ π.
            double angle = atan2(y, x);

            // Convert atan2 result angle to range [0, 2π]
            if (angle &lt; 0) {
                angle += 2 * M_PI;
            }

            // 0-360 map to linear gradient
            double angleRatio = angle / baseAngle;
            int colorIndex = angleRatio; // How many times of base angle?

            angle -= colorIndex * baseAngle;
            angleRatio = angle / baseAngle;

            colorIndex *= 4;

            uint8_t red0 = colorCompoents[colorIndex];
            uint8_t red1 = colorCompoents[colorIndex + 4];

            // Green index
            colorIndex += 1;
            uint8_t green0 = colorCompoents[colorIndex];
            uint8_t green1 = colorCompoents[colorIndex + 4];

            // Blue index
            colorIndex += 1;
            uint8_t blue0 = colorCompoents[colorIndex];
            uint8_t blue1 = colorCompoents[colorIndex + 4];

            // Alpha index
            colorIndex += 1;
            uint8_t alpha0 = colorCompoents[colorIndex];
            uint8_t alpha1 = colorCompoents[colorIndex + 4];

//            uint8_t red = red0 + angleRatio * (red1 - red0);
//            uint8_t green = green0 + angleRatio * (green1 - green0);
//            uint8_t blue = blue0 + angleRatio * (blue1 - blue0);
//            uint8_t alpha = alpha0 + angleRatio * (alpha1 - alpha0);

            uint8_t red = lerp(red0, red1, angleRatio);
            uint8_t green = lerp(green0, green1, angleRatio);
            uint8_t blue = lerp(blue0, blue1, angleRatio);
            uint8_t alpha = lerp(alpha0, alpha1, angleRatio);

            // Multiple alpha
            float a = alpha / 255.0;

            red *= a;
            green *= a;
            blue *= a;

            unsigned long index = i * width + j;

            *(bitmapData + index) = (red &lt;&lt; 24) | (green &lt;&lt; 16) | (blue &lt;&lt; 8) | alpha;
        }
    }
</code></pre>

<p>同样也稍微解释下其中的代码，首先是位图的填充要按照先行后列的顺序，行对就宽，列对应高；其次反正切函数的值域是(−π, π]，所以要把它们映射到[0, 2π]；然后我们根据角度对应的区间，选择起始和终点颜色，再由线性插值得到各自的颜色分量，实践中每个颜色分量还乘上了当前的透明度，最后合成该点的颜色。</p>

<p><a href="https://github.com/DamianSheldon/QuartzDemo">完整示例</a></p>

<h2>Reference:</h2>

<p><a href="https://stackoverflow.com/questions/15344163/conical-gradient-in-qt-without-qconicalgradient">Conical gradient in Qt (without QConicalGradient)</a><br/>
<a href="https://github.com/maxkonovalov/MKGradientView">MKGradientView</a><br/>
<a href="https://en.wikipedia.org/wiki/Color_gradient">Color gradient</a><br/>
<a href="https://en.wikipedia.org/wiki/Linear_interpolation">Linear interpolation</a><br/>
<a href="https://en.wikipedia.org/wiki/Atan2">atan2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 开发问题汇总(十)]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-development-problems-part-10.html"/>
    <updated>2017-09-11T15:42:24+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-development-problems-part-10</id>
    <content type="html"><![CDATA[<h3>1.在iOS 中如何使用私钥加密数据？</h3>

<p>A:当你用私钥加密时它被称为 siging, 之后用公钥解密的过程称为 verify signature.</p>

<blockquote><p>Why are you encrypting with the private key? When you encrypt with the private key, that is considered signing not encrypting, becuase it provides no confidentiality. If you want to &ldquo;encrypt&rdquo; with the private key, look into data signing, and that should allow you to &ldquo;encrypt&rdquo; (read &ldquo;sign&rdquo;) with the private key and &ldquo;decrypt&rdquo; (read &ldquo;verify signature&rdquo;) with the public key.</p></blockquote>

<p>Reference:</p>

<p><a href="https://stackoverflow.com/questions/6705928/encrypting-data-with-a-private-key-on-ios">Encrypting data with a private key on iOS</a></p>

<h3>2.</h3>

<pre><code>[!] Due to the previous naïve CocoaPods resolver, you were using a pre-release version of `JSONModel`, without explicitly asking for a pre-release version, which now leads to a conflict. Please decide to either use that pre-release version by adding the version requirement to your Podfile (e.g. `pod 'JSONModel', '= 1.2.2P'`) or revert to a stable version by running `pod update JSONModel`.
</code></pre>

<p>A:今天打开一个旧的的工程，可能由于版本控制的原因，Pods 下的文件都被删除掉了，于是运行 <code>pod install --verbose</code>, 安装报了上面的错误。工程是一个公共库，之前都是好的，它依赖了一个私有版本的 JSONModel,这本来也没什么问题，居然报出这么一错误，挺奇怪的。按提示先显示指定版本，依旧报错，看来并不是这个原因；又运行 <code>pod update JSONModel</code>,有输出安装私有版本的 JSONModel 的日志，问题解决。不过不清楚为什么会出这种很诡异的问题。</p>

<h3>3.What is the use of entitlements.plist file?</h3>

<p>A:</p>

<blockquote><p>Entitlements confer specific capabilities or security permissions to your iOS or macOS app.</p></blockquote>

<ol>
<li>The entitlements file defines certain capabilities of your app. Usually, the file is automatically generated by Xcode when you enable a capability for your app.</li>
<li>You only need the file if you enable certain capabilities, e.g. Healthkit integration. If you&rsquo;d like to use these features, you have to add it. Otherwise, Apple will reject your app.</li>
<li>You can name the file like you want. You can also rename it as long as the build settings point to the correct file name for it.</li>
</ol>


<p>Reference:</p>

<p><a href="https://stackoverflow.com/questions/26594367/what-is-the-use-of-entitlements-plist-file">What is the use of entitlements.plist file?</a></p>

<h3>4.A valid provisioning profile for this executable was not found</h3>

<p>A:Because Xcode compain about provisioning profile, so I decide to check the installed profiles on device, detail instructs are Window > Devices and Simulators > Select your device > right click > Show Provisioning Profiles&hellip;; Yes, no profile is here. It looks like we should mannual install one.</p>

<p>Where is the provisioning profiles Xcode managed? We can locate it by a simple way:Show project navigator > Select your project > General > Signing > Click info button follow Provisioning Profile > Drag the profile icon in popup menu to terminal. One of my profiles is : <code>/Users/dongmeiliang/Library/MobileDevice/Provisioning\ Profiles/1923e84f-743b-4453-8876-9763596ad09b.mobileprovision</code> , My Xcode version is 10.1 (10B61).</p>

<p>Reference:<a href="https://stackoverflow.com/questions/32729193/refresh-devices-in-team-provisioning-profile-managed-by-xcode-7">Refresh devices in team provisioning profile managed by Xcode 7?</a></p>
]]></content>
  </entry>
  
</feed>
