<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS Development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-11-07T11:29:25+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(翻译)Variable-Sized Items in UICollectionView]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview/"/>
    <updated>2014-11-04T11:27:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview</id>
    <content type="html"><![CDATA[<h3>基本训练</h3>

<p>我们以“Single View Application”为模板新建一个工程。在ViewController.xib上添加一个UICollectionView让它覆盖整个view。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView01" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView01.png" width="1110" height="783"></p>

<p>Collection View和它的祖父类似，有delegate和dataSource两个outlet,我们把它们连接到“File’s Owner”,这里的“File’s Owner”是ViewController类。这样Collection View的内容和交互就受ViewController控制。我们也需要一个outlet来引用Collection View,所以用Assistant editor增加一个。刚在ViewController.h中添加的outlet property可以是weak，因为作为ViewController的视图的子视图，它也会被充分的保留。</p>

<h3>单元格</h3>

<p>我们需要设计一个Cell原型来显示内容。如果你的Collection View是在View controller’s XIB ,你必须在先在代码中注册Cell才能使用。如果你是在Storyboard中新建的CollectionView，并在CollectionView的区域内创建的原型Cell,那么你就不需要注册Cell identifier了。因为我们并没有从Storyboard中开始，所以需要手动来创建。</p>

<p>我们在Interface Builder中创建一个原型Cell，设置它的背影为白色，添加一个UILabel，添加Label到父视图边缘的约束，分别是5 points的距离。因为我们想让Label的文字来决定它的尺寸，所以选中Label,然后从Editor menu中选择“Size to Fit Content”。后面我们会看到它是否会按照我们想像的那样工作。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView02" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView02.png" width="964" height="400"></p>

<p>我们设置Identifier为“TagCell”以便我们能在设计中引用。</p>

<p>这里我们遇到了第一个问题。如果你没有使用Storyboards,并没有办法让Collection View在相同的NIB文件中使用Collection View Cell。有两种可行的方法注册Cell:
```objective-c</p>

<pre><code>– registerClass:forCellWithReuseIdentifier:
– registerNib:forCellWithReuseIdentifier:
</code></pre>

<p>```</p>

<p>方法一为指定的Reuse identifier实例化某个特定的类，如果我们是通过代码来创建Cell的视图层级，我们应该使用这个方法；  <br/>
方法二需要一个NIB,而且NIB文件中只有Cell一个元素。在Storyboard中使用Collection Views避免了这个麻烦，这是它工作量更小的第二个重要原因。</p>

<p>为了解决这个问题，我们创建一个“empty Interface Builder Document”，命名为TagCollectionViewCell。感激零涕我们可以简单地CMD+X Cell设计从一个ViewController NIB中，然后CMD+V它到一个空的文档中。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView03" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView03.png" width="791" height="229"></p>

<p>下一步我们将试着注册Cell在Collection View中使用，并想看到显示一定数量的元素。</p>

<h3>注册设计的单元格</h3>

<p>任何时候我们想要一个标识符为“TagCell”的Cell都需要注册设计好的NIB文件，所以我们在ViewController.m文件的viewDidLoad中加入如下代码。
```objective-c</p>

<pre><code>UINib *cellNib = [UINib nibWithNibName:@"TagCollectionViewCell" bundle:nil];
[self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@"TagCell"];
</code></pre>

<p>```</p>

<p>我们仅需要实现的更多方法属于UICollectionViewDataSource协议，这些方法确保单元格正确显示。</p>

<p>```objective-c</p>

<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 UICollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> return cell;
}
```</p></li>
</ul>


<p>现在启动应用，我们看到100个元素全部是使用我们大概还没获奖的设计原型。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView04" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView04.png" width="396" height="744"></p>

<p>一眼就看出所有的元素都拥有相同的大小，准确的50x50 points。这是因为我们没有修改Interface Builder的默认值。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView05" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView05.png" width="261" height="273"></p>

<p>但是在我们为每个元素指定大小之前，让我们首先来完善一下我们的设计。我们移除白色的背影，新建一个TagCollectionViewCell类，并且将它指定为元素的类。</p>

<h3>漂亮的单元</h3>

<p>与其依赖iOS用单元的背影颜色填充整个矩形，我们想用一个圆角的矩形包围我们的标签。</p>

<p>```objective-c
&ndash; (void)drawRect:(CGRect)rect
{
   // inset by half line width to avoid cropping where line touches frame edges
   CGRect insetRect = CGRectInset(rect, 0.5, 0.5);
   UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:insetRect cornerRadius:rect.size.height/2.0];</p>

<p>   // white background
   [[UIColor whiteColor] setFill];
   [path fill];</p>

<p>   // red outline
   [[UIColor redColor] setStroke];
   [path stroke];
}
```</p>

<p>注意：你需要设置单元的contentMode为redraw,否则修改单元的大小不会触发重绘这个漂亮的背影。</p>

<p>结果看起来像下面这样，有部分黑色的背影发光渗透。注意我们需要轻微缩进一点再绘画轮廓，因为Quartz将裁剪红色圆圈靠近视图边界的部分。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView06" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView06.png" width="394" height="110"></p>

<p>下一步是让单元的大小适合现在标签的内容。</p>

<h3>逐个元素指定大小</h3>

<p>当然我们并不满足用1）一个静态值指定所有的元素大小，所以2）想让大小随我们单元的内容自动调整。还记得我们指定元素标签依靠文本大小来决定自身大小吗？视图的边缘距离标签的边缘是固定的5 points。因此如果有一种方法能得到元素的实际大小，那将十分酷。更酷的是如果我们能告诉collection view用这些值来指定元素的大小。</p>

<p>LLDB的一个快速测试表明元素返回一个-1，-1的固定内容大小值，这个未定义是一样的。我们在TagCollectionViewCell的头文件中为Label加一个outlet,以便我们能找到UILabel返回它们显示当前文本需要的大小。</p>

<p>因为我们知道约束四周的空白，我们把它们和Label的固定内容大小相加就得到了元素的大小。
```objective-c
// cache for margins configured via constraints in XIB
static CGSize _extraMargins = {0,0};</p>

<p>@implementation TagCollectionViewCell</p>

<ul>
<li><p>(CGSize)intrinsicContentSize
{
 CGSize size = [self.label intrinsicContentSize];</p>

<p> if (CGSizeEqualToSize(<em>extraMargins, CGSizeZero))
 {
    // quick and dirty: get extra margins from constraints
    for (NSLayoutConstraint *constraint in self.constraints)
    {
       if (constraint.firstAttribute == NSLayoutAttributeBottom || constraint.firstAttribute == NSLayoutAttributeTop)
       {
          // vertical spacer
          </em>extraMargins.height += [constraint constant];
       }
       else if (constraint.firstAttribute == NSLayoutAttributeLeading || constraint.firstAttribute == NSLayoutAttributeTrailing)
       {
          // horizontal spacer
          _extraMargins.width += [constraint constant];
       }
    }
 }</p>

<p> // add to intrinsic content size of label
 size.width += <em>extraMargins.width;
 size.height += </em>extraMargins.height;</p>

<p> return size;
}</p></li>
</ul>


<p>@end
```</p>

<p>该方法从我们在Interface Builder设置的约束中得到实际的留白宽度。它允许我们在IB中调整大小而不需要在代码中改变常量或宏定义。因为我们不打算修改任何约束，只是在方法第一次被调用时懒散的设置一个静态_extraMargins作为常量。</p>

<p>现在困难的部分是从Collection view中出列一个元素并得到大小。它之所以困难是因为方法会调用数据源的collectionView:cellForItemAtIndexPath:，还会调用collectionView:layout:sizeForItemAtIndexPath:方法。这里禁止我们从后一种方法中出列一个元素，否则会导致无限循环。</p>

<p>有些人从模型对象中得到数据，然后cell有一个类方法来计算需要的大小。然而这没有利用我们想要在Interface Builder中设置的约束。对于这个先有鸡还是先有蛋的问题，我能想到的最简便的方法是使用一个单独的元素作为模板，然后使用它新鲜出炉的intrinsicContentSize方法。</p>

<p>```objective-c
@implementation ViewController
{
   TagCollectionViewCell *_sizingCell;
}</p>

<ul>
<li><p>(void)viewDidLoad
{
 [super viewDidLoad];</p>

<p> UINib *cellNib = [UINib nibWithNibName:@&ldquo;TagCollectionViewCell&rdquo; bundle:nil];
 [self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@&ldquo;TagCell&rdquo;];</p>

<p> // get a cell as template for sizing
 _sizingCell = [[cellNib instantiateWithOwner:nil options:nil] objectAtIndex:0];
}</p></li>
</ul>


<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(void)_configureCell:(TagCollectionViewCell <em>)cell forIndexPath:(NSIndexPath </em>)indexPath
{
 if (indexPath.row%2)
 {
    cell.label.text = @&ldquo;A&rdquo;;
 }
 else if (indexPath.row%3)
 {
    cell.label.text = @&ldquo;longer&rdquo;;
 }
 else
 {
    cell.label.text = @&ldquo;much longer&rdquo;;
 }
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 TagCollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> [self _configureCell:cell forIndexPath:indexPath];</p>

<p> return cell;
}</p></li>
<li><p>(CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
 [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p> return [_sizingCell intrinsicContentSize];
}</p></li>
</ul>


<p>@end
```</p>

<p>为Collection view注册了NIB之后，我创建了个元素实例并赋值给了我的实例变量 <em>sizingCell。为了得到实际元素单元，我们有一个 </em>configureCell:forIndexPath:方法，它作用于出列可复用的实例上。为了计算大小，我们应用这个相同的方法到我们的sizing cell,以便我们得到正确的intrinsicContentSize。</p>

<h3>Once More With Auto Layout</h3>

<p>当我救助我的推友们关于如何得到基于约束的元素的大小，<a href="https://twitter.com/pilky">Martin Pilkington</a>迅速将我指向-systemLayoutSizeFittingSize:。一开始在应用中失败了，得到的全是{0,0}。但是当我写完上述解决办法，沉下心来又试了一次。</p>

<p>这一次它正常工作了。所需要做的是替换下面方法：
```objective-c
&ndash; (CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
   [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p>   return [_sizingCell systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
}
```</p>

<p>这个方法决定一个最接近传入大小的布局大小。两个标准值都可行，UILayoutFittingCompressedSize得到基于布局的最小大小，UILayoutFittingExpandedSize得到最大大小。</p>

<p>有了它我们可以很愉快地利用我们之前在intrinsicContentSize做的工作。我们也可以完全使用布局约束来进一步限制元素各个部分的大小。例如说：你可能想要短标签不要窄于某个宽度；如果某个标签太长了就让它截断。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView07" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView07.png" width="394" height="214"></p>

<p>结果如下，证明确实是我们想要的。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView08" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView08.png" width="396" height="744"></p>

<p>是不是很酷？让我们再强调一次：你不需要在Cell方法中计算大小，本质是重复了auto layout将要执行的计算。你只需要向系统要。</p>

<h3>总结</h3>

<p>在这篇博文中，我向你展示了如何为Collection view创建一个来自NIB的Cell。备选方法是在Storyboard中使用Collection view，它在某些方面更方便。这些Cell没有放在单独的XIB文件中，但是是在Collection view的结构层级中。探索如何得到一个sizing cell就作为练习留给读者了。</p>

<p>我们发现UILabel暴露一个intrinsicContentSize方法十分方便，如果你在Interface Builder指定了auto layout，它会用来计算大小。我们探索了一种方法，它使用一个cell实例作为模板来决定最佳的元素大小。然后我们更进一步运用了一个方法告诉我们基于布局约束和固定内容大小的完美尺寸。</p>

<p>例子的代码放在GitHub的<a href="https://github.com/Cocoanetics/Examples">Cocoanetics Examples</a> 仓库中。</p>

<h3>原文</h3>

<p><a href="http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/">http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/19/auto-layout/"/>
    <updated>2014-10-19T17:43:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/19/auto-layout</id>
    <content type="html"><![CDATA[<h3>前言</h3>

<p>Auto Layout 早在 iOS 6时就引入了，但由于之前 iPhone 的尺寸不多，而且宽度是一样的; 另一方面 Auto Layout增加了学习成本，大部分开发者仍然使用传统坐标布局做屏幕适配。但是随着 iPhone 6, 6 Plus 大屏 iPhone的发布，继续使用坐标布局做适配显得力不从心了，而且从 Apple 的动作来看，Auto Layout是未来的必然趋势，因此，我们很有必要掌握它。</p>

<h3>Auto Layout 是什么</h3>

<p>  Auto Layout is a system that lets you lay out your app’s user interface by creating a mathematical description of the relationships between the elements. —Apple<br/>
  Auto Layout是一个通过创建元素之间关系的数学描述来布局你应用的用户界面的系统。</p>

<p>  You define these relationships in terms of constraints either on individual elements, or between sets of elements.<br/>
  你可以在单个元素，或一系列元素间以约束的形式来定义这些关系。</p>

<h4>Constraint &mdash; 约束</h4>

<p>  约束是 Auto Layout 的基石，它表达着界面元素布局的规则。我们可以把约束想像成人类语言表述的数学形式。例如，设计师可能会说“这个按钮的左边缘应该与容器视图的左边缘有20个点的偏移。”，它可以转化为button.left = (container.left + 20)，进而抽象出更一般的表达，y = m*x + b，这就是约束。这里的 y 和 x 是View的attributes，m 和 b 是浮点值。<br/>
  * attributes 有left, right, top, bottom, leading, trailing, width, height, centerX, centerY 和 baseline； <br/>
  * b 实际上是 Constant value, 是物理大小的偏移；<br/>
  * =，是 Relation, Auto Layout 支持 &lt;=, = , >= 三种关系；<br/>
  * Priority level, 约束还支持优先级，优先级高的先满足。</p>

<h4>Intrinsic Content Size</h4>

<p>  Intrinsic Content Size 是 Auto Layout 中另一个重要概念，身处视图层级末端的视图会为显示特定内容期望得到一个大小，它就叫做Intrinsic Content Size。</p>

<h3>如何使用Auto Layout</h3>

<p>  Auto Layout 的使用方法有两种：一是通过 Interface Builder, 二是 Code。</p>

<h3>Tips</h3>

<p>1,在实际的项目中，由于3.5 到5.5 Inch跨度还是挺大，建议在 ViewController 的 View 上面加一个 UIScrollView， 然后再在 ScrollView 上加一个 View， 其他的视图都布局在它上面，这样布局会容易点。</p>

<p>2,Xcode 自带布局效果预览的功能，可以按下面的步骤最大化预览编辑窗口查看在各个屏幕上的布局效果：<br/>
  * 在工程导航面板中单击 storyboard/XIB 文件，使它在 Xcode 的主窗口中打开；<br/>
  * 双击上述文件使它在新的窗口中打开； <br/>
  * 将新的窗口移动到新的桌面上，最大化它； <br/>
  * 单击下新窗口，确保它是输入焦点，然后按 Option+Command+Enter 在窗口中打开 assistant editor；  <br/>
  * 在 assistant editor 头部选中 Automatic 展开下拉菜单，在下拉菜单中选中 Preview, 可以在 Preview 中一次些查看多个布局效果图，省的来回启动模拟器。</p>

<h3>Demo</h3>

<p><a href="https://github.com/DamianSheldon/AutoLayout">Auto Layout Demo</a></p>

<h3>Reference</h3>

<p>Auto Layout Guide<br/>
WWDC2012 session 202 – Introduction to Auto Layout for iOS and OS X<br/>
WWDC2012 session 228 – Best Practices for Mastering Auto Layout<br/>
WWDC2012 session 232 – Auto Layout by Example<br/>
<a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1  ">http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1  </a>
<a href="http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2">http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2</a>  <br/>
<a href="http://objccn.io/issue-3-5/">http://objccn.io/issue-3-5/</a>  <br/>
<a href="http://studentdeng.github.io/blog/2014/06/13/auto-layout/">http://studentdeng.github.io/blog/2014/06/13/auto-layout/</a>  <br/>
<a href="http://www.onevcat.com/2012/09/autoayout/">http://www.onevcat.com/2012/09/autoayout/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Development--Certificates, Provisioning Profiles]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates/"/>
    <updated>2014-10-09T16:24:09+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates</id>
    <content type="html"><![CDATA[<p>iOS App开发过程的真机调试和开发完成的发布要用合法的 Signing Identity 进行签名，并且要制作相应的Provising Profile。</p>

<p><img name="LaunchApp" src="http://DamianSheldon.github.io/images/LaunchApp.png" width="697" height="573"></p>

<p>开发过程的真机调试需要：</p>

<pre><code>Private Key -- 私钥
iPhone Development Certificate -- 开发证书
Development Provisioning profile
</code></pre>

<p>发布到 App Store 需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
App Store Distribution Provisioning profile
</code></pre>

<p>通过 Ad Hoc 发布需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
Ad Hoc Distribution Provisioning profile
</code></pre>

<h3>Private Key, Certificate, Provisioning Profile 的作用</h3>

<p>Private Key &mdash;私钥， 在iOS App 开发过程中，Xcode用它来签署应用。</p>

<p>Certificate &mdash;证书，它包含公钥，用来认证已签名的程序，通过认证来确定应用的来源是可信任的，并且代码是完整的， 未经修改的。</p>

<p><img name="Certificate" src="http://DamianSheldon.github.io/images/Certificate.png" width="696" height="471"> </p>

<p>Provisioning Profile &mdash;供应配置文件，它包含证书， App ID, 设备信息，它决定Xcode用哪个证书/私钥组合来签署程序, 开发设备也通过它来决定如何认证安装在设备上的程序。</p>

<p><img name="ProvisioningProfile" src="http://DamianSheldon.github.io/images/ProvisioningProfile.png" width="618" height="377"></p>

<h3>Private Key, Certificate, Provisioning Profile 的制作过程</h3>

<p>使用KeyChain申请 Certificate Signing Request (CSR)，这个过程就能生成代码签名的公、私钥对，私钥会保存在KeyChain中，公钥则包含在Certificate中。</p>

<p>Provisioning Profile的制作要复杂些，它要包含App 相应的Certificate， App ID, Development Provision Profile 还会包含 Device 信息。</p>

<h3>Tips</h3>

<p>团队开发时，我们可以通过邮件等方式分发Private Key，这样只需要制作一次 Private Key, Certificate, Provisioning Profile。</p>

<p>Xcode3.2.3预发布版本加入了新功能Team Provisioning Profile,它包含一个Wildcard App ID(*, 匹配所有应用程序)，Team中所有的Development Certificates和所有开发设备信息，增加新设备后，Xcode会自动更新Team Provisioning Profile, 因此， 团队成员可以通过设置Xcode的Provisioning Profile为Team Provisioning Profile，从而可以在所有的开发设备上调试应用程序。</p>

<p><img name="TeamProvisioningProfile" src="http://DamianSheldon.github.io/images/TeamProvisioningProfile.png" width="712" height="406">  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation 笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji/"/>
    <updated>2014-09-03T09:59:58+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji</id>
    <content type="html"><![CDATA[<h2>Core Animation介绍</h2>

<p>Core Animation is a graphics rendering and animation infrastructure available on both iOS and OS X that you use to animate the views and other visual elements of your app.</p>

<h2>什么时候使用Core Animation?</h2>

<p>In places where you want to perform more sophisticated animations, or animations not supported by the UIView class, you can use Core Animation and the view’s underlying layer to create the animation. Because view and layer objects are intricately linked together, changes to a view’s layer affect the view itself.</p>

<h2>如何使用Core Animation?</h2>

<p>  1)Enabling Core Animation Support in Your App;<br/>
  In iOS apps, Core Animation is always enabled and every view is backed by a layer.iOS apps must link against this framework only if they use Core Animation interfaces explicitly.</p>

<p>  2)Selecting a appropriate Layer Object Associated with a View;<br/>
  Reference:Core Animation Programming Guide &mdash; Different Layer Classes Provide Specialized Behaviors</p>

<p>  3)Add animation to layer.<br/>
  CABasicAnimation provides basic, single-keyframe animation capabilities for a layer property.<br/>
  The CAKeyframeAnimation class provides keyframe animation capabilities for a layer object.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App 开发遇到的问题]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti/"/>
    <updated>2014-08-25T17:09:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>  问题描述：Storyboard中的ViewController上添加一个自定义的view,声明为IBOutlet然后用代码改变view的Frame,打印输出Frame的值确实改变了，但是模拟器上的视图的Frame还是没有改变。</p>

<p>  解决办法：Google找到Stackoverflow上有人说是选中了Auto layout的原因，取消之后确实生效了。PS:但是不知道问题的原因是什么。</p>

<p>Reference:<br/>
o <a href="http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work">http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work</a></p>

<p>问题描述：在switch语句中，如果在case中要定义变量的话要加上大括号。</p>

<p>原因：Case statements are only &lsquo;labels&rsquo;. This means the compiler will interpret this as a jump directly to the label.The problem here is one of scope. Your curly brackets define the scope as everything inside the &lsquo;switch&rsquo; statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that case statement and define your variable within it.</p>

<p>Reference:<a href="http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439">http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439</a></p>

<p>问题描述：创建Group style的UITalbeView的顶端有很大一块空白。</p>

<p>解决办法：YouStoryboard.storyboard > YouViewController > Attributes inspector > Uncheck &ndash; Adjust scroll view insets</p>

<p>Reference:<a href="http://stackoverflow.com/questions/18880341/why-is-there-extra-padding-at-the-top-of-my-uitableview-with-style-uitableviewst">http://stackoverflow.com/questions/18880341/why-is-there-extra-padding-at-the-top-of-my-uitableview-with-style-uitableviewst</a></p>

<p>问题描述：SVN更新Cocoapods管理的第三方包的Xcode工程报错。  <br/>
```bash
A  +  C Pods</p>

<blockquote><p>  local edit, incoming delete upon update
```</p></blockquote>

<p>解决办法：svn revert &mdash;depth infinity Pods</p>

<p>Reference:<a href="http://stackoverflow.com/questions/4317973/svn-how-to-resolve-local-edit-incoming-delete-upon-update-message">http://stackoverflow.com/questions/4317973/svn-how-to-resolve-local-edit-incoming-delete-upon-update-message</a></p>

<p>问题描述：*** Terminating app due to uncaught exception &lsquo;NSInternalInconsistencyException&rsquo;, reason: &lsquo;&ndash;[UIViewController _loadViewFromNibNamed:bundle:] loaded the &ldquo;loc&rdquo; nib but the view outlet was not set.&rsquo;</p>

<p>解决办法：从输出的日志来看，是说 view 没有设置，事实也确实如此。我先创建了 UIViewController 类文件，然后再创建一个空的同名 xib 文件，我从 Object Library 中拉了一个 UIViewController，问题就出在这里，我应该拉一个 UIView ，并将 File&rsquo;s Owner 设置成正确的类名，最后将 view outlet 联接起来。所以，如果想用 xib 创建 UIViewController，建议在创建类的时候勾选创建相应的 Xib 文件，让 Xcode 做好这些工作。</p>

<p>Reference:<a href="http://www.cnblogs.com/tivonstone/archive/2012/04/20/2460116.html">http://www.cnblogs.com/tivonstone/archive/2012/04/20/2460116.html</a></p>

<p>问题描述：设置swipe gesture的direction为UISwipeGestureRecognizerDirectionLeft | UISwipeGestureRecognizerDirectionRight但是只识别一个方向。</p>

<p>解决办法：为每个方向单独创建一个UISwipeGestureRecognizer。</p>

<p>Reference:<a href="http://stackoverflow.com/questions/7420078/detect-when-uigesturerecognizer-is-up-down-left-and-right-cocos2d/7760927#7760927">http://stackoverflow.com/questions/7420078/detect-when-uigesturerecognizer-is-up-down-left-and-right-cocos2d/7760927#7760927</a></p>
]]></content>
  </entry>
  
</feed>
