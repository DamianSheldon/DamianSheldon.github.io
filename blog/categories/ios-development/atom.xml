<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS Development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-10-11T15:27:06+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS Development--Certificates, Provisioning Profiles]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates/"/>
    <updated>2014-10-09T16:24:09+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/10/09/ios-development-certificates</id>
    <content type="html"><![CDATA[<p>iOS App开发过程的真机调试和开发完成的发布要用合法的 Signing Identity 进行签名，并且要制作相应的Provising Profile。</p>

<p><img name="LaunchApp" src="http://DamianSheldon.github.io/images/LaunchApp.png" width="697" height="573"></p>

<p>开发过程的真机调试需要：</p>

<pre><code>Private Key -- 私钥
iPhone Development Certificate -- 开发证书
Development Provisioning profile
</code></pre>

<p>发布到 App Store 需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
App Store Distribution Provisioning profile
</code></pre>

<p>通过 Ad Hoc 发布需要：</p>

<pre><code>私钥
iPhone Distribution Certificate
Ad Hoc Distribution Provisioning profile
</code></pre>

<h3>Private Key, Certificate, Provisioning Profile 的作用</h3>

<p>Private Key &mdash;私钥， 在iOS App 开发过程中，Xcode用它来签署应用。</p>

<p>Certificate &mdash;证书，它包含公钥，用来认证已签名的程序，通过认证来确定应用的来源是可信任的，并且代码是完整的， 未经修改的。</p>

<p><img name="Certificate" src="http://DamianSheldon.github.io/images/Certificate.png" width="696" height="471"> </p>

<p>Provisioning Profile &mdash;供应配置文件，它包含证书， App ID, 设备信息，它决定Xcode用哪个证书/私钥组合来签署程序, 开发设备也通过它来决定如何认证安装在设备上的程序。</p>

<p><img name="ProvisioningProfile" src="http://DamianSheldon.github.io/images/ProvisioningProfile.png" width="618" height="377"></p>

<h3>Private Key, Certificate, Provisioning Profile 的制作过程</h3>

<p>使用KeyChain申请 Certificate Signing Request (CSR)，这个过程就能生成代码签名的公、私钥对，私钥会保存在KeyChain中，公钥则包含在Certificate中。</p>

<p>Provisioning Profile的制作要复杂些，它要包含App 相应的Certificate， App ID, Development Provision Profile 还会包含 Device 信息。</p>

<h3>Tips</h3>

<p>团队开发时，我们可以通过邮件等方式分发Private Key，这样只需要制作一次 Private Key, Certificate, Provisioning Profile。</p>

<p>Xcode3.2.3预发布版本加入了新功能Team Provisioning Profile,它包含一个Wildcard App ID(*, 匹配所有应用程序)，Team中所有的Development Certificates和所有开发设备信息，增加新设备后，Xcode会自动更新Team Provisioning Profile, 因此， 团队成员可以通过设置Xcode的Provisioning Profile为Team Provisioning Profile，从而可以在所有的开发设备上调试应用程序。</p>

<p><img name="TeamProvisioningProfile" src="http://DamianSheldon.github.io/images/TeamProvisioningProfile.png" width="712" height="406">  </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Core Animation 笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji/"/>
    <updated>2014-09-03T09:59:58+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/09/03/core-animation-bi-ji</id>
    <content type="html"><![CDATA[<h2>Core Animation介绍</h2>

<p>Core Animation is a graphics rendering and animation infrastructure available on both iOS and OS X that you use to animate the views and other visual elements of your app.</p>

<h2>什么时候使用Core Animation?</h2>

<p>In places where you want to perform more sophisticated animations, or animations not supported by the UIView class, you can use Core Animation and the view’s underlying layer to create the animation. Because view and layer objects are intricately linked together, changes to a view’s layer affect the view itself.</p>

<h2>如何使用Core Animation?</h2>

<p>  1)Enabling Core Animation Support in Your App;<br/>
  In iOS apps, Core Animation is always enabled and every view is backed by a layer.iOS apps must link against this framework only if they use Core Animation interfaces explicitly.</p>

<p>  2)Selecting a appropriate Layer Object Associated with a View;<br/>
  Reference:Core Animation Programming Guide &mdash; Different Layer Classes Provide Specialized Behaviors</p>

<p>  3)Add animation to layer.<br/>
  CABasicAnimation provides basic, single-keyframe animation capabilities for a layer property.<br/>
  The CAKeyframeAnimation class provides keyframe animation capabilities for a layer object.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App 开发遇到的问题]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti/"/>
    <updated>2014-08-25T17:09:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>  问题描述：Storyboard中的ViewController上添加一个自定义的view,声明为IBOutlet然后用代码改变view的Frame,打印输出Frame的值确实改变了，但是模拟器上的视图的Frame还是没有改变。</p>

<p>  解决办法：Google找到Stackoverflow上有人说是选中了Auto layout的原因，取消之后确实生效了。PS:但是不知道问题的原因是什么。</p>

<p>Reference:<br/>
o <a href="http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work">http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work</a></p>

<p>问题描述：在switch语句中，如果在case中要定义变量的话要加上大括号。</p>

<p>原因：Case statements are only &lsquo;labels&rsquo;. This means the compiler will interpret this as a jump directly to the label.The problem here is one of scope. Your curly brackets define the scope as everything inside the &lsquo;switch&rsquo; statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that case statement and define your variable within it.</p>

<p>Reference:<a href="http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439">http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)如何让didUpdateLocation兼容iOS 5和iOS 6]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/07/28/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/"/>
    <updated>2014-07-28T16:05:38+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/07/28/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6</id>
    <content type="html"><![CDATA[<p><code>- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation</code>是CLLocationManagerDelegate protocol中的一个常用方法，它让你的应用接收更新位置信息，当检测到任何位置变化。新的位置详情存储在newLocation中，它是一个CLLocation.<br/>
当iOS6启动，上述方法被废弃了，建议使用新版本方法<code>- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations</code>或简称locationManager:didUpdateLocations:.</p>

<p>这个快速教程的的创建目的是为了解释如何处理废弃方法，关于它什么是应该完成的以及你在哪里可以找出关于改变的更多细节。如果你想了解如何使用这个新的locationManager:didUpdateLocations: 方法，看下<a href="http://www.devfright.com/didupdatelocations-ios-example/">didUpdateLocations tutorial</a>，它解释了如何使用方法提供的NSArray.</p>

<h3>当方法被废弃了</h3>

<p>当iOS升级了（这很经常），Apple找到新的或更有效方法。当这发生了，方法可以被标记为废弃并在如何使用的地方给出一个提示。具体到CLLocationManagerDelegate，你可以看到文档中推荐了一个不同的方法。虽然你仍然可以使用废弃的方法，即使是在已经废弃的iOS版本中，Apple在未来某个时间点也许会删除掉这个方法当iOS升级了。在那个时间点，你可能需要修改你的代码，提交到Apple Store通过审核流程。</p>

<h3>如何处理废弃的方法</h3>

<p>已经被废弃的方法在新的iOS版本上仍然可以工作。Apple趋向于让它们在未来的几个新版本中保持可用，然后再将它们从类或协议中删除。与其让你的代码在最后关头更新或重新提交到苹果商店。你可以在改变之前做好准备。</p>

<p>今天的例子，我们会看下 locationManager:didUpdateToLocation:fromLocation:方法以及如何让旧的废弃方法和新的方法在同一份代码中共同工作。<br/>
``` objective-c</p>

<p>&ndash;(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *newLocation = [locations lastObject];
CLLocation *oldLocation = [locations objectAtIndex:locations.count-1];
NSLog(@"didUpdateToLocation %@ from %@", newLocation, oldLocation);
MKCoordinateRegion userLocation = MKCoordinateRegionMakeWithDistance(newLocation.coordinate, 1500.0, 1500.0);
[regionsMapView setRegion:userLocation animated:YES];
</code></pre>

<p>}
<code>
为了兼容iOS 5,我们可以加入旧的方法`- (void)locationManager:(CLLocationManager *)manager didUpdateToLocation:(CLLocation *)newLocation fromLocation:(CLLocation *)oldLocation`，并在旧的方法中调用新的方法，代码看起来会像这样：
</code> objective-c
&ndash;(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations {</p>

<pre><code>CLLocation *newLocation = [locations lastObject];
CLLocation *oldLocation;
if (locations.count &gt;= 2) {
    oldLocation = [locations objectAtIndex:locations.count-1];
} else {
    oldLocation = nil;
}
NSLog(@"didUpdateToLocation %@ from %@", newLocation, oldLocation);
MKCoordinateRegion userLocation = MKCoordinateRegionMakeWithDistance(newLocation.coordinate, 1500.0, 1500.0);
[regionsMapView setRegion:userLocation animated:YES];
</code></pre>

<p>}</p>

<ul>
<li>(void)locationManager:(CLLocationManager <em>)manager didUpdateToLocation:(CLLocation </em>)newLocation fromLocation:(CLLocation *)oldLocation {
  [self locationManager:locationManager didUpdateLocations:[[NSArray alloc] initWithObjects:newLocation, nil]];
}
```</li>
</ul>


<p>如果是iOS5，新的方法不会被调用，它就像自定义的方法，iOS5并不知道locationManager:didUpdateLocations:事实上是什么。旧的方法简单的alloc/init新的名为currentLocation的NSArray并且使用 initWithObjects:newLocation获取一个newLocation,然后NSArray作为信息被传递到locationManager新的方法。</p>

<p>总之，如果设备是iOS5,旧的方法locationManager:didUpdateToLocation:fromLocation: 告诉代理新的位置可用，它把CLLocation加到NSArray中传递给新的方法，但设备的操作系统并不知道新方法。</p>

<p>如果使用的是iOS6,我们从CLLocationManagerDelegate的头文件中了解到如果代码中既有旧方法又有新方法，那么iOS会调用新方法通知代理位置更新了。</p>

<p>虽然这个快速教程提供了一种处理废弃方法的办法，仍然会有其他很多不同的办法。另外，多查看文档和关文件，因为Apple添加了很多信息，它们很有可能会为你手头的任务提供解决办法。</p>

<p>原文<br/>
o <a href="http://www.devfright.com/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/">http://www.devfright.com/how-to-make-didupdatelocations-compatible-with-ios-5-and-ios-6/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Properties]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties/"/>
    <updated>2014-06-24T15:28:20+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties</id>
    <content type="html"><![CDATA[<h3>Properties</h3>

<p>“Properties associate values with a particular class, structure, or enumeration. ” &mdash; Apple</p>

<h4>Type Properties</h4>

<p>属于类型本身的properties称为Type Property.</p>

<p>1)Value Type Properties (keyword: static)<br/>
structrue, enumeration可以定义Stroed 和Computed type properties.</p>

<p>Stored type properties for value types can be variables or constants.<br/>
NOTE:Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<p>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</p>

<p>2)Reference Type Properties (keyword: class)<br/>
class只可以定义Computed type properties.</p>

<h4>Instance Properties</h4>

<p>1)Stroed Properties
In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</p>

<p>P.S:A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p>2)Computed Properties
computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>

<h3>Properties Observer</h3>

<p>Property observers observe and respond to changes in a property’s value.</p>

<p>You have the option to define either or both of these observers on a property:</p>

<p>willSet is called just before the value is stored.<br/>
didSet is called immediately after the new value is stored.</p>
]]></content>
  </entry>
  
</feed>
