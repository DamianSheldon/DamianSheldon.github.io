<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-11-23T23:00:38+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS App 数据持久化]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-data-persistence.html/"/>
    <updated>2014-11-13T15:06:25+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-data-persistence</id>
    <content type="html"><![CDATA[<p>数据的持久化就是让数据能够持久的保存，实现它的方法有两种：云端和本地。本文试着简单总结本地持久化的方法。</p>

<p>本地持久化其实就是将数据保存到闪存，那么我们应该用什么方法保存，又应该保存在哪呢？</p>

<h2>文件系统基础</h2>

<p>在OS X和iOS中，文件系统处理数据文件，应用程序和操作系统本身相关文件的持久存储。
我们要知道把数据保存到哪，就要知道些iOS文件系统的知识。</p>

<p>iOS应用和文件系统的交互基本上仅限于它沙盒内目录。新应用安装过程中，安装程序为应用创建了数个容器。每个容器有个特定的角色。The bundle container holds the app’s bundle, whereas the data container holds data for both the application and the user. The data container is further divided into a number of directories that the app can use to sort and organize its data. The app may also request access to additional containers—for example, the iCloud container—at runtime.</p>

<p>这些容器构成了应用文件系统的基本面。下图是应用沙盒的示意图。</p>

<div style="text-align:center" markdown="1">

<img name="ios_app_layout_2x" src="images/ios_app_layout_2x.png" width="383" height="417">

</div>




<!-- more -->


<p>iOS应用常用的目录列表：</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> Directory </th>
<th align="left"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> AppName.app </td>
<td align="left"> This is the app’s bundle</td>
</tr>
<tr>
<td></td>
<td align="left"> Documents/ </td>
<td align="left"> Use this directory to store user-generated content.</td>
</tr>
<tr>
<td></td>
<td align="left"> Documents/Inbox </td>
<td align="left"> Use this directory to access files that your app was asked to open by outside entities.</td>
</tr>
<tr>
<td></td>
<td align="left"> Library/ </td>
<td align="left"> This is the top-level directory for any files that are not user data files.</td>
</tr>
<tr>
<td></td>
<td align="left"> tmp/ </td>
<td align="left"> Use this directory to write temporary files that do not need to persist between launches of your app.</td>
</tr>
</tbody>
</table>


<h3>数据的建议存储位置</h3>

<p>限于篇幅，关于应用的数据应该放到哪，可以查阅<strong>File System Programming Guide</strong> > <strong>File System Basics</strong> > <strong>About the iOS File System</strong> > <strong>Where You Should Put Your App’s Files</strong>。</p>

<h3>数据持久化的方法</h3>

<ol>
<li>NSUserDefaults;</li>
<li>Property Lists;</li>
<li>Archive;</li>
<li>数据库;</li>
<li>Core Data。</li>
</ol>


<h4>NSUserDefaults</h4>

<p>NSUserDefaults类提供与默认系统交互的程序接口。默认系统允许应用去自定义它的行为来符合用户的偏好。所以它主要是用来存储些配置信息。
它支持的数据类型有：floats，doubles，integers，Booleans，URLs，NSData，NSString，NSNumber，NSDate，NSArray和NSDictionary。如果还想存储其他类型的对象，需要使用NSData对它们进行归档。</p>

<h4>Property Lists</h4>

<p>当我们的需要持久化的数据量在几百KB内时，property list为我们提供了统一而方便的方法持久化数据。如果我们对象的全由NSDictionary, NSArray, NSString, NSDate, NSData, 或NSNumber类派生，我们可以创建property list。事实上，NSUserDefaults就是把数据保存在property list中。</p>

<p>Property list有三种存储方式：XML, binary format, &ldquo;old-style&rdquo; ASCII format inherited from OpenStep。old-style format的序列化API是只读的。</p>

<p>XML property list比binary格式的可移植性好，可以手动编辑，但是binary property lists兼容性好，需要的存储空间少，读写速度要优于XML property lists。通常来说，如果你的property list相对较小，XML property lists的优点会战胜它相对binary property lists的I/O速度，难兼容的缺点。如果你有大量数据，binary property lists, keyed archives，或自定义数据格式会是更好的解决方案。</p>

<h4>Archive</h4>

<p>Archives提供了一种把对象和值转成结构独立的字节流，它保留了对象与值，以及对象与对象的关系信息。</p>

<p>Cocoa archives可以持有Objective-c对象，标量，数组，结构体和字符串。它不能持有和平台相关的类型，例如union, void *, function pointers, 和long chains of pointers。</p>

<p>对象写入archive和从archive读出是使用coder对象。Coder对象是抽象类NSCoder具体子类的实例。它通过给对象发送NSCoding协议定义的encodeWithCoder: 和initWithCoder:方法分别写入或读出archiver。只有支持NSCoding协议的对象才能写入archiver。</p>

<h4>数据库</h4>

<p>iOS中有了以上数据持久化方法，我们为什么还需要数据库？</p>

<p>目前在iOS App开发中，SQLite是个不错的选择。</p>

<hr />

<p>SQLite</p>

<blockquote><p>SQLite is an in-process library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine.</p></blockquote>

<p>SQLite在众多数据库中脱颖而出，目前是个不错的选择，但由于它是C接口，操作略显繁琐，就有了很多对它的封装，FMDB是个不错的选择。</p>

<h4>Core Data</h4>

<p>Core Data是Apple为我们提供的一种持久化方法，比较强大也比较复杂。</p>

<h1>Reference</h1>

<p>File System Programming Guide <br/>
Property List Programming Guide   <br/>
Archives and Serializations Programming Guide  <br/>
<a href="http://www.infoq.com/cn/articles/data-storage-in-ios">对比iOS中的四种数据存储</a>  <br/>
<a href="http://www.cnblogs.com/kenshincui/p/3885689.html#archiver">IOS开发系列—Objective-C之Foundation框架</a>  <br/>
<a href="http://www.cnblogs.com/kenshincui/p/4077833.html">iOS开发系列&mdash;数据存取</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Key-Value Coding &amp; Key-Value Observing]]></title>
    <link href="http://DamianSheldon.github.io/blog/key-value-coding-and-key-value-observing.html/"/>
    <updated>2014-11-12T16:06:13+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/key-value-coding-and-key-value-observing</id>
    <content type="html"><![CDATA[<h2>Key-Value Coding</h2>

<ol>
<li>Key-Value Coding是什么？</li>
<li>为什么要用Key-Value Coding？</li>
<li>如何使用Key-Value Coding?</li>
</ol>


<h3>Key-Value Coding是什么？</h3>

<blockquote><p>Key-value coding is a mechanism for accessing an object’s properties indirectly, using strings to identify properties, rather than through invocation of an accessor method or accessing them directly through instance variables.</p></blockquote>

<p>Key-value coding是一种间接访问对象属性和机制，使用字符串去区别属性，而不是通过调用存取方法或者通过实例变量直接访问它们。</p>

<h3>为什么要用Key-Value Coding？</h3>

<ol>
<li>Scripting（OS X）;</li>
<li>简化代码和提高灵活性；</li>
</ol>


<h3>如何使用Key-Value Coding?</h3>

<p>Key-value coding支持对象属性，也可以是标量类型和结构体。在开始使用之前，我们先熟悉些下key-value coding术语，后文我们用术语来阐述，方便交流。</p>

<p>除了重载现有的术语，key-value coding定义了些专属的术语。</p>

<p>Key-value coding可以被用来访问三种不同的类型的对象值：<strong>attributes</strong>, <strong>to-one relationships</strong>, 和<strong>to-many relationships</strong>。术语<strong>property</strong>指三种类型值的任意一种。</p>

<p>attribute是简单值的property，像标量，字符串，或者布尔值。NSNumber和其他的不可变类型如NSColor也都被认为是attributes。</p>

<p>to-one relationship是拥有自己properties的对象。这些内部的properties可以改变而对象却不变。例如，NSView实例的superview就是to-one relationship。</p>

<p>to-many relationship包括一个相关对象的集合。NSArray或NSSet经常被用来持有这样一个集合。但是，key-value coding允许你使用自定义的类作为集合并且通过实现在to-many Properties中讨论的key-value coding存取方法仍然可以可以像它们是NSArray或NSSet那样访问它们。</p>

<p>既然key-value coding是一种间接访问对象属性的机制，访问就包括存取。</p>

<!-- more -->


<h4>使用key-value coding读取attribute值</h4>

<p>NSKeyValueCoding中定义的的attribute读取方法有：</p>

<p>```
&ndash; (id)valueForKey:(NSString *)key;</p>

<ul>
<li><p>(NSMutableArray <em>)mutableArrayValueForKey:(NSString </em>)key;</p></li>
<li><p>(id)valueForKeyPath:(NSString *)keyPath;</p></li>
<li><p>(NSMutableArray <em>)mutableArrayValueForKeyPath:(NSString </em>)keyPath;</p></li>
<li><p>(NSDictionary <em>)dictionaryWithValuesForKeys:(NSArray </em>)keys;</p></li>
<li><p>(id)valueForUndefinedKey:(NSString *)key;</p></li>
</ul>


<p>```</p>

<h4>使用key-value coding存储attribute值</h4>

<p>```
&ndash; (void)setValue:(id)value forKey:(NSString *)key;</p>

<ul>
<li><p>(NSMutableSet <em>)mutableSetValueForKey:(NSString </em>)key;</p></li>
<li><p>(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</p></li>
<li><p>(NSMutableSet <em>)mutableSetValueForKeyPath:(NSString </em>)keyPath;</p></li>
<li><p>(void)setValue:(id)value forUndefinedKey:(NSString *)key;</p></li>
<li><p>(void)setNilValueForKey:(NSString *)key;</p></li>
<li><p>(void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues;</p></li>
</ul>


<p>```</p>

<p>你需要考虑一个额外的问题就是当你尝试设置非对象的property为nil。这种情况下，接收者给它自己发送一个setNilValueForKey:消息。它默认的实现是抛出NSInvalidArgumentException异常。你的应用可以覆盖这个方法替换默认值或标记值，然后你用新值调用setValue:forKey:。</p>

<p>现在，我们知道怎么用key-value coding去间接访问对象的property了。但是，如果想让我们自定义的类的property也支持key-value coding的话，我们应该怎么做呢？</p>

<h4>如何让自定义类的属性支持key-value coding?</h4>

<blockquote><p>Key-value coding attempts to use accessor methods to get and set values, before resorting to directly accessing the instance variable.</p></blockquote>

<p>在依靠直接访问实例变量之前，key-value coding尝试使用存取方法去访问和设置值。也就是说我们最好实现相应的存取方法，至少也要存在合适的实例变量。</p>

<p>前面提到key-value coding支持三个类型的attribute,针对三种类型的attribute,key-value coding分别是怎么来搜索存取方法和实例变量的呢？</p>

<ol>
<li>简单attributes存取方法搜索模式；</li>
<li>顺序集合存取方法的搜索模式；</li>
<li>唯一顺序集合存取方法的搜索模式；</li>
<li>无序集合存取方法的搜索模式。</li>
</ol>


<p>搜索的细节可以查阅Key-Value Coding Programming Guide。</p>

<h2>Key-Value Observing</h2>

<ol>
<li>Key-Value Observing是什么？</li>
<li>为什么要用Key-Value Observing？</li>
<li>如何使用Key-Value Observing?</li>
</ol>


<h3>Key-Value Observing是什么？</h3>

<blockquote><p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p></blockquote>

<p>Key-value observing是一种允许一对对象的特定属性改变时另一个对象被通知的机制。</p>

<h3>为什么要用Key-Value Observing？</h3>

<p>KVO的主要好处是你不需要实现一套属性每次改变发送通知的机制。</p>

<h3>如何使用Key-Value Observing?</h3>

<ol>
<li>Registering as an Observer;</li>
<li>Receiving Notification of a Change;</li>
<li>Removing an Object as an Observer.</li>
</ol>


<p>同样，自定义的类如何才能让其他的开发者能使用KVO呢？我们要做的是符合KVO标准。</p>

<h4>KVO Compliance</h4>

<ul>
<li>The class must be <strong>key-value coding compliant</strong> for the property, as specified in <strong>Ensuring KVC Compliance</strong> in <strong>Key-Value Coding Programming Guide</strong>.</li>
<li>The class emits KVO change notifications for the property.</li>
<li>Dependent keys are registered appropriately (see <strong>Registering Dependent Keys</strong>).</li>
</ul>


<hr />

<p>There are two techniques for ensuring the change notifications are emitted. Automatic support is provided by NSObject and is by default available for all properties of a class that are key-value coding compliant. Typically, if you follow standard Cocoa coding and naming conventions, you can use automatic change notifications—you don’t have to write any additional code.</p>

<p>Manual change notification provides additional control over when notifications are emitted, and requires additional coding. You can control automatic notifications for properties of your subclass by implementing the class method automaticallyNotifiesObserversForKey:.</p>

<hr />

<h4>One more thing</h4>

<p>Key-Value Observing Implementation Details</p>

<p>Automatic key-value observing is implemented using a technique called <strong>isa-swizzling</strong>.</p>

<p>The <strong>isa</strong> pointer, as the name suggests, points to the object&rsquo;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>

<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>

<p>You should never rely on the <strong>isa</strong> pointer to determine class membership. Instead, you should use the <strong>class</strong> method to determine the class of an object instance.</p>

<p>So how does <strong>class</strong> method determine the class of an object?</p>

<h1>Reference</h1>

<p>Key-Value Coding Programming Guide <br/>
Key-Value Observing Programming Guide</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)iOS 设计模式]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-design-patterns.html/"/>
    <updated>2014-11-10T08:35:43+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-design-patterns</id>
    <content type="html"><![CDATA[<p>iOS设计模式&mdash;你也许听说过这个术语，但是你知道它意味着什么吗？尽管大多数开发者可能同意设计模式非常重要，但关于它的文章并不多，咱们开发者们写代码时并没有花大多注意力放到设计模式上。</p>

<p>在软件设计中设计模式是对常见问题的可复用的解决方法。他们被设计成模板帮助你写出容易理解和复用的代码。他们也帮助你写出低藕合的代码以便你不需要太多争论就能改变或替换你代码的组件。</p>

<p>如果你刚刚接触设计模式，告诉你些好消息！首先，你已经使用过很多设计模式，这得感谢Cocoa建立的方式以及你被鼓励使用的最佳实践。其次，这篇教程将让你掌握iOS的主要（次要）设计模式，它们在Cocoa中很常用。</p>

<p>教程分成多个部分，每部分包含一种设计模式。在每部分，你会看到如下顺序的解释：</p>

<ul>
<li>该设计模式是什么；</li>
<li>你为什么应该使用它；</li>
<li>如何使用它，以及什么场景合适，使用时需要留意的常见陷阱；</li>
</ul>


<p>这篇教程中，你将创建一个Music Library应用，它会显示你的专辑和它们相关的信息。</p>

<p>在开发应用的过程中，你会慢慢熟悉多数常见的Cocoa设计模式：</p>

<ul>
<li>构造类：单例(Singleton)和 抽象工厂(Abstract Factory);</li>
<li>架构类：模型-视图-控制器(MVC), 修饰(Decorator), 适配器(Adapter), 门面(Facade)和合成（Composite);</li>
<li>行为类：观察者(Observer), 记忆(Memento), 响应链(Chain of Responsibility)和命令（Command）。</li>
</ul>


<p>别被误导认为这是篇纯理论的文章；你会在你音乐应用中使用这些应用模式中的大多数。你的应用最终看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="finalapp-180x320" src="http://DamianSheldon.github.io/images/finalapp-180x320.png" width="180" height="320">  

</div>




<!-- more -->


<h3>开始吧</h3>

<p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/BlueLibrary-Starter.zip">启动工程</a>,解压ZIP文件内容，然后在Xcode中打开。</p>

<p>里面内容不多，仅仅是默认的ViewController和一个未实现的简单HTTP客户端。</p>

<p><strong>Note</strong>:你知道吗？当你创建一个新的工程你的代码就已经符合设计模式了。MVC, Delegate, Protocol, Singleton&mdash;你免费得到全部！:]</p>

<p>在你深入第一个设计模式之前，你必须创建两个类去持有和显示专辑数据。</p>

<p>导航到<strong>“File\New\File…”</strong>(或简单地按Command+N)。选中<strong>iOS > Cocoa Touch</strong>，然后<strong>Objective-C class</strong>和单击<strong>Next</strong>。设置类名为<strong>Album</strong>并继承<strong>NSObject</strong>。单击<strong>Next</strong>然后<strong>Create</strong>。</p>

<p>打开<strong>Album.h</strong>，然后添加如下属性和方法原型到<strong>@interface</strong> 和 <strong>@end</strong>间:</p>

<p>```
@property (nonatomic, copy, readonly) NSString <em>title, </em>artist, <em>genre, </em>coverUrl, *year;</p>

<ul>
<li>(id)initWithTitle:(NSString<em>)title artist:(NSString</em>)artist coverUrl:(NSString<em>)coverUrl year:(NSString</em>)year;
```</li>
</ul>


<p>注意到所有的属性都是可读的，因为Album对象被创建之后不需要被改变。</p>

<p>方法是对象的初始化方法。当你创建一个新alum，你将传入album name, artist, album cover URL和year。</p>

<p>现在打开<strong>Album.m</strong>,添加下列代码到<strong>@implementation</strong>和<strong>@end</strong>中间:</p>

<p>```
&ndash; (id)initWithTitle:(NSString<em>)title artist:(NSString</em>)artist coverUrl:(NSString<em>)coverUrl year:(NSString</em>)year
{</p>

<pre><code>self = [super init];
if (self)
{
    _title = title;
    _artist = artist;
    _coverUrl = coverUrl;
    _year = year;
    _genre = @"Pop";
}
return self;
</code></pre>

<p>}
```</p>

<p>这里没有什么神奇的；仅仅是一个简单的init方法去创建一个新Album实例。</p>

<p>再次导航到<strong>File\New\File…</strong>。选择<strong>Cocoa Touch</strong>然后<strong>Objective-C class</strong>，点击<strong>Next</strong>。设置类名为<strong>AlbumView</strong>，但是这次设置它为<strong>UIView</strong>的子类。点击<strong>Next</strong>然后<strong>Create</strong>。</p>

<p><strong>Note</strong>:如果你发现快捷键更容易用的话，<strong>Command+N</strong>将创建新的文件，<strong>Command+Option+N</strong>将创建新组，<strong>Command+B</strong>将编译你的工程，<strong>Command+R</strong>将运行工程。</p>

<p>打开<strong>AlbumView.h</strong>,然后添加下列方法原型到<strong>@interface</strong>和<strong>@end</strong>的中间。</p>

<p><code>
- (id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover;
</code></p>

<p>Now open AlbumView.m and replace all the code after @implementation with the following code:</p>

<p>现在打开<strong>AlbumView.m</strong>，用下面的代码替换<strong>@implementation</strong>之后的内容：</p>

<p>```
@implementation AlbumView
{</p>

<pre><code>UIImageView *coverImage;
UIActivityIndicatorView *indicator;
</code></pre>

<p>}</p>

<ul>
<li><p>(id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover
{
  self = [super initWithFrame:frame];
  if (self)
  {</p>

<pre><code>  self.backgroundColor = [UIColor blackColor];
  // the coverImage has a 5 pixels margin from its frame
  coverImage = [[UIImageView alloc] initWithFrame:CGRectMake(5, 5, frame.size.width-10, frame.size.height-10)];
  [self addSubview:coverImage];

  indicator = [[UIActivityIndicatorView alloc] init];
  indicator.center = self.center;
  indicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhiteLarge;
  [indicator startAnimating];
  [self addSubview:indicator];
</code></pre>

<p>  }
  return self;
}</p></li>
</ul>


<p>@end
```</p>

<p>你注意到的第一件事是这里有个名为coverImage的实例变量。变量代表专辑的封面图片。第二个变量是一个指示器，当专辑在下载时它转动指示器。</p>

<p>在初始化方法的实现中，你设置背影为黑色，创建一个与主视图周边有5个点距离的图片视图，创建并添加了一个活动指示器。</p>

<p><strong>Note</strong>:很奇怪为什么把私有变量定义在实现文件中而不是接口文件中？这是因为AlbumView类之外的其他类并不需要知道这些变量的存在，它们仅被类的内部实现中使用。如果你是在开发库或框架让其他开发者使用，这个惯例极其重要。</p>

<p>编译你的工程（<strong>Command+B</strong>）确认所有事情都准备就绪。都好了吗？然后准备迎接你的第一个设计模式！:]</p>

<h3>模型&mdash;视图&mdash;控制器，设计模式之王</h3>

<div style="text-align:center" markdown="1">

<img name="mvcking" src="http://DamianSheldon.github.io/images/mvcking.png" width="293" height="196">  

</div>


<p>模型&mdash;视图&mdash;控制器（MVC）是Cocoa的一个基石，它毫无疑问是被用得最多的设计模式。它依据应用中类的角色给它们分类，鼓励基于角色简洁地分隔代码。</p>

<p>这三个角色是：</p>

<ul>
<li><p>模型：持有你应用数据并定义如何操作它们的对象。例如，这个应用中的模型是你的Album类。</p></li>
<li><p>视图：控制模型类的可视显示以及和用户的交互的对象;所有的UIView和它们的子类基本上都是。在你这个应用中AlbumView代表视图。</p></li>
<li><p>控制器：控制器是中间件，它协调所有的工作。它从模型类访问数据并显示到视图上，监听事件，在需要时操作数据。你能猜到哪个类是你的控制器吗？对，是ViewController。</p></li>
</ul>


<p>你应用中这个设计模式好的实现意味着每个对象都会是三者之一。</p>

<p>视图和模型的通信可以被最佳描述成下图：</p>

<div style="text-align:center" markdown="1">

<img name="mvc0" src="http://DamianSheldon.github.io/images/mvc0.png" width="424" height="194">  

</div>


<p>任何数据发生改变模型类便通知控制器，接下来，控制器将数据更新到视图上。视图接收到用户的动作时可以通知控制器，控制器会根据需要更新模型数据或获取任何请求的数据。</p>

<p>你也许会奇怪为什么不拿掉Controller,在同一个类中实现视图和模型，这看起来更容易。</p>

<p>这都来源于代码的去藕合和可可复用。理想情况下，视图应该完全和模型隔离，这样它可以被不同的模型复用去展示其他的数据。</p>

<p>例如，如果未来你也想添加电影或书本到你的收藏库中，你仍然可以使用相同的AlbumView去展示你的电影和图书对象。此外，如果你创建了一个新的对象，它和专辑有些关系，你可以简单地复用你的Album类，因为它不依赖任何视图。这就是MVC的强大之处！</p>

<h3>如何使用MVC设计模式</h3>

<p>首先，你需要保证你工程中的类是Controller，View, Model三者之一；不要混合两个角色的功能到一个类中。你创建的<strong>Album</strong>和<strong>AlbumView</strong>到目前为止都做的很好。</p>

<p>其次，为了确保你习惯这种工作方式，你应该创建三个工程组来持有你的代码，每组对应一个类别。</p>

<p>导航到<strong>File\New\Group</strong>（或按<strong>Command+Option+N</strong>）并命名为Model，用相同的方法创建<strong>View</strong>和<strong>Controller</strong>组。</p>

<p>现在拖拽<strong>Album.h</strong>和<strong>Album.m</strong>到<strong>Model</strong>组。拖拽<strong>AlbumView.h</strong>和<strong>AlbumView.m</strong>到<strong>View</strong>组，最后拖拽<strong>ViewController.h</strong>和<strong>ViewController.m</strong>到<strong>Controller</strong>组。</p>

<p>目前你的工程结构应该看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="mvc2-255x320" src="http://DamianSheldon.github.io/images/mvc2-255x320.png" width="255" height="320">  

</div>


<p>你的工程已经没有混乱的文件了看起来好多了。你明显能拥有其他的组和类，但这三个类别中的类是应用的核心。</p>

<p>现在你的组件被组织起来了，你需要从其他地方得到你的专辑数据。你将创建一个API类用于全部代码的数据管理&mdash;这提供了一个机会和你探讨下一个设计模式&mdash;单例。</p>

<h3>单例设计模式</h3>

<p>单例设计模式确保对于指定的类仅存在一个实例，全局的访问都指向它。它经常使用懒散加载，只有第一次需要时才创建这个实例。</p>

<p><strong>Note</strong>:Apple大量使用这种方法。例如：<strong>[NSUserDefaults standardUserDefaults]</strong>, <strong>[UIApplication sharedApplication]</strong>, <strong>[UIScreen mainScreen]</strong>, <strong>[NSFileManager defaultManager]</strong> 全都返回单例对象。</p>

<p>你也许会奇怪为什么你要关心一个类是不是只有一个实例，毕竟代码和内存都很便宜，对不对？</p>

<p>有些场景对于类只存在一个实例是有意义的。例如，没有必要存在多个Logger实例，除非你想同时输出多个log文件。以或者来看一个全局配置处理类：像配置文件，对于单个共享资源实现线程安全访问要比在同时可能有很多配置文件修改时容易的多。</p>

<h3>如何使用单例设计模式</h3>

<p>看下下面这个图：</p>

<div style="text-align:center" markdown="1">

<img name="singleton" src="http://DamianSheldon.github.io/images/singleton.png" width="233" height="152">  

</div>


<p>上图示例了一个Logger类，它有一个属性（它就是这个单独的实例），和两个方法：sharedInstance和init。</p>

<p>客户端第一次发送sharedInstance消息，属性的实例还没被初始化，所以你创建类的一个新的实例，然后返回它的一个引用。</p>

<p>下次调用sharedInstance，实例会立即返回不用初始化。这个逻辑保证任何时候都只仅存在一个实例。</p>

<p>你将实现这种模式通过创建一个单例类来管理专辑的所有数据。</p>

<p>你将注意到工程里有一个组叫<strong>API</strong>；这是你放所有将为应用提供服务类的地方。在组里用<strong>iOS\Cocoa Touch\Objective-C class</strong>模板创建一个新的类。命名为<strong>LibraryAPI</strong>，设置它是<strong>NSObject</strong>的子类。</p>

<p>打开<strong>LibraryAPI.h</strong>,用如下内容替代它：</p>

<p>```
@interface LibraryAPI : NSObject</p>

<ul>
<li>(LibraryAPI*)sharedInstance;</li>
</ul>


<p>@end
```</p>

<p>Now go to LibraryAPI.m and insert this method right after the @implentation line:</p>

<p>现在到<strong>LibraryAPI.m</strong>，在<strong>@implentation</strong>之后插入这个方法：</p>

<p>```
+ (LibraryAPI*)sharedInstance
{</p>

<pre><code>// 1
static LibraryAPI *_sharedInstance = nil;

// 2
static dispatch_once_t oncePredicate;

// 3
dispatch_once(&amp;oncePredicate, ^{
    _sharedInstance = [[LibraryAPI alloc] init];
});
return _sharedInstance;
</code></pre>

<p>}
```</p>

<p>简短的方法里有不少内容：</p>

<ol>
<li><p>声明了一个静态变量来持有你类的实例，确保它在你的类中是全局可用的。</p></li>
<li><p>声明了一个<strong>dispatch_once_t</strong>静态变量，它确保初始化方法只会被执行一次。</p></li>
<li><p>使用Grand Central Dispatch (GCD)来执行块，它初始化了一个<strong>LibraryAPI</strong>的实例。这是单例设计模式的要义：类被实例化之后初始化方法就不会被调用了。</p></li>
</ol>


<p>下次你调用<strong>sharedInstance</strong>，在<strong>dispatch_once</strong>块中代码就不会被执行了（因为它已经被执行过一次了），你会得到一个之前创建的<strong>LibraryAPI</strong>的实例引用。</p>

<p>Note:想了解更多GCD内容以及它的用法，看下网站中的这两篇教程：<a href="http://www.raywenderlich.com/?p=4295">Multithreading and Grand Central Dispatch</a>和<a href="http://www.raywenderlich.com/?p=9328">How to Use Blocks</a>。</p>

<p>你现在有一个单例对象作为入口去管理专辑。我们把它进一步完善，创建一个类来处理你收藏库数据的持久化。</p>

<p>以<strong>iOS\Cocoa Touch\Objective-C class</strong>为模板在API组中创建一个新的类，命名为<strong>PersistencyManager</strong>，设置它为<strong>NSObject</strong>的子类。</p>

<p>打开<strong>PersistencyManager.h</strong>，添加下列引用到文件的顶端:</p>

<p>```</p>

<h1>import &ldquo;Album.h&rdquo;</h1>

<p>```</p>

<p>Next, add the following code to PersistencyManager.h after the @interface line:</p>

<p>然后，添加下列代码到<strong>PersistencyManager.h</strong>中<strong>@interface</strong>后面：</p>

<p><code>
- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></p>

<p>上面是你处理专辑数据的三个方法原型。</p>

<p>打开PersistencyManager.m，添加下列代码到@implementation前面：</p>

<p>```
@interface PersistencyManager () {</p>

<pre><code>// an array of all albums
NSMutableArray *albums;
</code></pre>

<p>}
```</p>

<p>上面添加了一个类的扩展，它是另一种给类添加私有方法和变量而不会暴露给外部类的方法。这里你声明了一个<strong>NSMutableArray</strong>来持有专辑数据。数组的可变性可以让你很容易添加和删除专辑数据。</p>

<p>现在添加下现代码实现到PersistencyManager.m文件中@implementation的后面：</p>

<p>```
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    // a dummy list of albums
    albums = [NSMutableArray arrayWithArray:
             @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
             [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
             [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
             [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
             [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
}
return self;
</code></pre>

<p>}
```</p>

<p>在init中，你用5个样本专辑填充了数组。如果上面的专辑你不喜欢，用你喜欢的音乐替换它们吧. :]</p>

<p>现在添加下面三个方法到<strong>PersistencyManager.m</strong>：</p>

<p>```
&ndash; (NSArray*)getAlbums
{</p>

<pre><code>return albums;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)addAlbum:(Album*)album atIndex:(int)index
{
  if (albums.count >= index)
      [albums insertObject:album atIndex:index];
  else
      [albums addObject:album];
}</p></li>
<li><p>(void)deleteAlbumAtIndex:(int)index
{
  [albums removeObjectAtIndex:index];
}
```</p></li>
</ul>


<p>这些方法能让你获取，添加，删除专辑。</p>

<p>编译你的工程，确保所有的文件仍然能成功被编译。</p>

<p>到这，你可能会奇怪<strong>PersistencyManager</strong>来看哪里呢？它又不是单例。<strong>LibraryAPI</strong>和<strong>PersistencyManager</strong>的关系，我们在下一节会进一步揭示，你还会看到<strong>门面</strong>设计模式。</p>

<h3>门面设计模式</h3>

<div style="text-align:center" markdown="1">

<img name="facade" src="http://DamianSheldon.github.io/images/facade.jpg" width="300" height="212">  

</div>


<p>门面设计模式为复杂的子系统提供一个单一的接口。与其把一系列类和它们的API暴露给用户，还不如仅仅暴露给它们一个简单统一的API。</p>

<p>下图解释了这种理念：</p>

<div style="text-align:center" markdown="1">

<img name="facade2-480x241" src="http://DamianSheldon.github.io/images/facade2-480x241.png" width="480" height="241">  

</div>


<p>API的使用者们完全感觉不到它后面的复杂。当很多类协作时，这种设计模式十分理想，特别是当它们对用户很复杂或很难理解。</p>

<p>门面模式让使用系统的代码从接口和你隐藏实现的类解藕；它也减少了外部代码对内部子系统工作的依赖。当门面底下的类想改变时，这也很有用，因为门面能保留相同的API，尽管后面的代码已经改变了。</p>

<p>例如，如果有一天你想替换你的后端服务，你不需要去修改使用你API的代码。</p>

<h3>如何使用门面设计模式</h3>

<p>目前你有<strong>PersistencyManager</strong>保存专辑数据到本地，<strong>HTTPClient</strong>处理远程交互。工程中其他的类不应该意识到这个逻辑的存在。</p>

<p>为了实现这个设计模式，仅<strong>LibraryAPI</strong>应该持有<strong>PersistencyManager</strong>和<strong>HTTPClient</strong>的实例。然后，<strong>LibraryAPI</strong>会对其他的服务暴露一个简单的API。</p>

<p><strong>Note</strong>:通常，单例在整个应用的生命周期都存在。你不应该让单例保持大多其他对象的强引用，因为他们直到应用关闭才会被释放。</p>

<p>设计看起来像下面这样：</p>

<div style="text-align:center" markdown="1">

<img name="design-patterns-facade-uml-480x71" src="http://DamianSheldon.github.io/images/design-patterns-facade-uml-480x71.png" width="480" height="71">  

</div>


<p><strong>LibraryAPI</strong>将暴露给其他代码，但是会对应用的其他部分隐藏<strong>HTTPClient</strong>和<strong>PersistencyManager</strong>的复杂。</p>

<p>打开<strong>LibraryAPI.h</strong>，添加下列引用到文件的顶端：</p>

<p>```</p>

<h1>import &ldquo;Album.h&rdquo;</h1>

<p>```</p>

<p>然后，添加下列方法定义到<strong>LibraryAPI.h</strong>：</p>

<p><code>
- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></p>

<p>现在，这些方法是你会暴露给其他类的。</p>

<p>到LibraryAPI.m中，添加下面两个引用：</p>

<p>```</p>

<h1>import &ldquo;PersistencyManager.h&rdquo;</h1>

<h1>import &ldquo;HTTPClient.h&rdquo;</h1>

<p>```</p>

<p>这将是你唯一导入这些类的地方。记住：你的API将会是唯一的入口去访问你"复杂"的系统。</p>

<p>现在，通过类的扩展添加些私有变量（在@implementation上面）：</p>

<p>```
@interface LibraryAPI () {</p>

<pre><code>PersistencyManager *persistencyManager;
HTTPClient *httpClient;
BOOL isOnline;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p><strong>isOnline</strong>决定任何专辑列表的改变，例如，添加或删除专辑，是否应该被更新到服务器。</p>

<p>你现在需要通过<strong>init</strong>来初始化这些变量。添加下列代码到<strong>LibraryAPI.m</strong>：</p>

<p>```
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    persistencyManager = [[PersistencyManager alloc] init];
    httpClient = [[HTTPClient alloc] init];
    isOnline = NO;
}
return self;
</code></pre>

<p>}
```</p>

<p>HTTP Client最终不会和真实的服务器交互，这里仅仅是为示例门面模式的使用，所以<strong>isOnline</strong>将一直是<strong>NO</strong>。</p>

<p>下一步，添加下面三个方法到<strong>LibraryAPI.m</strong>：</p>

<p>```
&ndash; (NSArray*)getAlbums
{</p>

<pre><code>return [persistencyManager getAlbums];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)addAlbum:(Album*)album atIndex:(int)index
{
  [persistencyManager addAlbum:album atIndex:index];
  if (isOnline)
  {
      [httpClient postRequest:@&ldquo;/api/addAlbum&rdquo; body:[album description]];
  }
}</p></li>
<li><p>(void)deleteAlbumAtIndex:(int)index
{
  [persistencyManager deleteAlbumAtIndex:index];
  if (isOnline)
  {
      [httpClient postRequest:@&ldquo;/api/deleteAlbum&rdquo; body:[@(index) description]];
  }
}
```</p></li>
</ul>


<p>看一眼<strong>addAlbum:atIndex:</strong>。类首先更新本地数据，然后如果是联网的话，更新远程服务器。这是门面的真正力量；当你系统外面添加一个新专辑，它不知道，也不需要知道这底下的复杂。</p>

<p><strong>Note</strong>:当你为子系统的类设计门面时，记住没任何东西防止客户端直接访问隐藏的类。不要吝啬你的防御代码，不要假设所有客户端按门面相同的方式使用这些类是必须的。</p>

<p>编译并运行你的应用。你会看到像下面这样令人兴奋和无法置信的空的黑色屏幕。</p>

<div style="text-align:center" markdown="1">

<img name="2013-09-01_12-08-44-211x320" src="http://DamianSheldon.github.io/images/2013-09-01_12-08-44-211x320.png" width="211" height="320">  

</div>


<p>你将会需要些东西来显示专辑数据到屏幕上&mdash;这是个完美的使用场景对于你的下个设计模式：修饰。</p>

<h3>修饰设计模式</h3>

<p>修饰设计模式动态添加行为和能力到一个对象而不需要修改它的代码。它是不同于子类那样通过包装到另一个对象来修改类的行为的方法。</p>

<p>在Objective-C中，这种设计模式有两个很常见的实现：<strong>Category</strong>和<strong>Delegation</strong>。</p>

<h4>Category</h4>

<p>Category是一个极其强大的机制，它允许你添加方法到已经存在的类而不需要子类化。新的方法在编译时被添加，可以像扩展类的普通方法一样被执行。它和经典的修饰模式有点不同，因为一个Category不能持有扩展类的实例。</p>

<p><strong>Note</strong>:除了扩展你自己的类，你还可以添加方法到任意Cocoa拥有的类。</p>

<h4>如何使用Categories</h4>

<p>想像这么一个场景，你有一个Album对象，你想让它显示在一个表格视图中:</p>

<div style="text-align:center" markdown="1">

<img name="design-patterns-category1" src="http://DamianSheldon.github.io/images/design-patterns-category1.png" width="310" height="188">  

</div>


<p>专辑标题是从哪来的呢？<strong>Album</strong>是一个模型对象，所以它不关心你如何展示数据。你将需要些外部代码来为<strong>Album</strong>类添加该功能，但是不能直接修改类。</p>

<p>你将创建一个category，这是Album的扩展；它将定义一个新方法，这个新方法会返回一个让UITableView很容易使用的数据结构。</p>

<p>The data structure will look like the following:</p>

<p>这个数据结构会看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="delegate2-480x67" src="http://DamianSheldon.github.io/images/delegate2-480x67.png" width="480" height="67">  

</div>


<p>为了添加<strong>Category</strong>到<strong>Album</strong>，导航到<strong>File\New\File…</strong>，选择<strong>Objective-C category</strong>模板&mdash;不要习惯性地选择了<strong>Objective-C class</strong>！输入<strong>TableRepresentation</strong>到<strong>Category</strong>字段，<strong>Album</strong>到<strong>Category on</strong>字段。</p>

<p>Note:你有没注意到新文件的名字？<strong>Album+TableRepresentation</strong>意味着你正在扩展<strong>Album</strong>类。这个惯例很重要，因为它易读并且它防止和你事其他人可能创建的categories冲突。</p>

<p>Go to Album+TableRepresentation.h and add the following method prototype:</p>

<p>进入Album+TableRepresentation.h，添加如下方法原型：</p>

<p><code>
- (NSDictionary*)tr_tableRepresentation;
</code></p>

<p>注意这里的方法名前有个<strong>tr_</strong>，是<strong>category:TableRepresentation</strong>的缩写。再次提醒，像这样的惯例将防止和其他方法冲突！</p>

<p><strong>Note</strong>:如果你在category中声明的方法和源类，或都同一个类其他的category（甚至父类）方法相同，运行时会使用哪个方法实现是示定义的。这种情况在你使用自己拥有类的category时很少发生，但是当使用categories添加方法到标准的Cocoa或Cocoa Touch类时能导致严重问题。</p>

<p>Go to Album+TableRepresentation.m and add the following method:</p>

<p>进入<strong>Album+TableRepresentation.m</strong>，添加如下方法：</p>

<p>```
&ndash; (NSDictionary*)tr_tableRepresentation
{</p>

<pre><code>return @{@"titles":@[@"Artist", @"Album", @"Genre", @"Year"],
         @"values":@[self.artist, self.title, self.genre, self.year]};
</code></pre>

<p>}
```</p>

<p>Consider for a moment how powerful this pattern can be:</p>

<p>思考下这种模式在某个时刻有多强大：</p>

<ul>
<li>你正在使用直接来自Album属性。</li>
<li>你添加了内容到Album类，但是你并没有子类化它。如果你需要子类化Album，你仍然也可以这么做。</li>
<li>这个简单的额外内容让你能返回一个UITableView式的专辑，并没有修改Album的代码。</li>
</ul>


<p>Apple在Foundation类中大量使用Categories。打开<strong>NSString.h</strong>看下他们是如何做的。找到 <strong>@interface NSString</strong>，你将会看到总共定义了三个categories：<strong>NSStringExtensionMethods</strong>, <strong>NSExtendedStringPropertyListParsing</strong> 和 <strong>NSStringDeprecated</strong>。Categories帮助方法组织和分隔到各个部分。</p>

<h4>Delegation</h4>

<p>另一个修饰设计模式，Delegation，是一种一个对象的行为代表或协调另一个对象。例如，当你使用<strong>UITableView</strong>，你必须实现的方法之一是<strong>tableView:numberOfRowsInSection:</strong>。</p>

<p>你不能期望UITableView知道你想每个部分有多少行，因为这是应用特定的。因此，计算每个部分有多少行的任务传递给了UITableView delegate。它允许UITableView类独立于它显示的数据。</p>

<p>这里有一个当你创建一个UITableView时是如何进行的虚拟场景解释：</p>

<div style="text-align:center" markdown="1">

<img name="delegate-480x252" src="http://DamianSheldon.github.io/images/delegate-480x252.png" width="480" height="252">  

</div>


<p>UITableView对象的工作是显示table view。但是，最终它将需要一些它没有的信息。然后，它救助于它的delegates，发送消息询问额外的信息。在Objective-C中实现delegate模式，一个类通过protocol可以声明可选和必选的方法。你将教程的稍候全面了解protocols。</p>

<p>表面看起来仅仅去继承一个对象然后覆盖必要的方法要简单，但是考虑下你只能继承单一的一个类。如果你想让某个类成为两或多个对象的delegate，这是不能通过继承实现的。</p>

<p>Note:这是个很重要的模式。Apple应用这种方法到大多数UIKit类：<strong>UITableView</strong>, <strong>UITextView</strong>, <strong>UITextField</strong>, <strong>UIWebView</strong>, <strong>UIAlert</strong>, <strong>UIActionSheet</strong>, <strong>UICollectionView</strong>, <strong>UIPickerView</strong>, <strong>UIGestureRecognizer</strong>, <strong>UIScrollView</strong>。列表还在继续。</p>

<p>未完待续&hellip;</p>

<h3>原文</h3>

<p>iOS Design Patterns（<a href="http://www.raywenderlich.com/46988/ios-design-patterns%EF%BC%89">http://www.raywenderlich.com/46988/ios-design-patterns%EF%BC%89</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为MacBook Pro配置一个像guake的终端]]></title>
    <link href="http://DamianSheldon.github.io/blog/setup-iterm2-to-behave-like-guake.html/"/>
    <updated>2014-11-07T10:31:19+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/setup-iterm2-to-behave-like-guake</id>
    <content type="html"><![CDATA[<p>以前在Arch下经常使用一个名为guake的终端，体验很好，用MacBook Pro之后也想有个这样的终端，由于各种原因，这事一直耽搁着，但并没有放下，今天特意找了下，还真找到了。不费话了，进入正题。</p>

<h3>让iTerm2的行为像guake</h3>

<p>1)下载<a href="http://iterm2.com/">iTerm2</a>,然后解压;</p>

<p>2)打开iTerm2,然后iTerm2&mdash;>Prefences&hellip;&ndash;>Profiles;</p>

<p>3)创建一个新Profiles,命名为guake;</p>

<p>4)在Window选项中根据自己的喜好配置;</p>

<p><img name="create_new_iterm_profile" src="http://DamianSheldon.github.io/images/create_new_iterm_profile.png" width="913" height="533"></p>

<p>5)在Keys选项中激活"Show/hide iTerm2 with a system-wide hotkey",由于F12用来移动到Dashboard,只能用其他的快捷键了，可以根据自己喜好设置，我这里设置为⌘F12,(Note:⌘ + fn + F12);</p>

<p><img name="assign_a_hotkey" src="http://DamianSheldon.github.io/images/assign_a_hotkey.png" width="897" height="528"></p>

<!-- more -->


<h3>开机启动iTerm2时不打开终端窗口</h3>

<p>安装好iTerm2,并把它配置像guake, 加入开机自启动(System Preferences > Users&amp;Groups > Login Items > + iTerm2)之后，还有一个小问题困扰着我，就是它会默认打开一个终端窗口，这让人很不舒坦，解决方法如下:</p>

<p>1)打开iTerm2;</p>

<p>2)关闭所有的窗口(iTerm2菜单栏&mdash;>shell&mdash;>Close);</p>

<p>3)Window&mdash;>Save Window Arrangement;</p>

<p>4)将新的窗口布局命名为“No Windows”;</p>

<p>5)将这个新窗口布局设置默认布局，Preferences > Arrangements > Set it as default;</p>

<p>6)最后在Preferences… > General > Startup, 只选中“Open default window arrangement” 。</p>

<h3>Reference:</h3>

<p>SETUP ITERM2 TO BEHAVE LIKE GUAKE(<a href="http://ivanvillareal.com/osx/setup-iterm2-to-behave-like-guake/">http://ivanvillareal.com/osx/setup-iterm2-to-behave-like-guake/</a>)</p>

<p>Launch iTerm 2 on startup without opening a terminal window (<a href="http://rottmann.net/2013/03/launch-iterm-2-on-startup-without-opening-a-terminal-window/">http://rottmann.net/2013/03/launch-iterm-2-on-startup-without-opening-a-terminal-window/</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 小结]]></title>
    <link href="http://DamianSheldon.github.io/blog/git-summary.html/"/>
    <updated>2014-11-05T10:13:13+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/git-summary</id>
    <content type="html"><![CDATA[<h1>Git</h1>

<ol>
<li>Git是什么？</li>
<li>为什么使用Git?</li>
<li>如何使用Git?</li>
</ol>


<h2>Git是什么？</h2>

<p>git &ndash; the stupid content tracker</p>

<p>这是man git中对它的介绍，我们看到它的核心是content tracker。Git是一个分布式的版本控制系统，项目是出于维护Linux内核源码的需求, 由Linus Torvalds启动的，现在已经成为最流行的版本管理系统，学会Git几乎成了开发者的必备技能。</p>

<h2>为什么使用Git?</h2>

<ol>
<li>系统稳定，安全性高，不会丢失辛苦的劳动成果；</li>
<li>操作十分快速；</li>
<li>功能强大；</li>
<li>&hellip;</li>
</ol>


<h2>如何使用Git?</h2>

<h3>安装Git</h3>

<p>安装Git主要有两种方法：一种是通过编译源代码来安装;另一种是使用为特定平台预编译好的安装包。</p>

<!-- more -->


<h3>在服务器上布署Git</h3>

<p>尽管技术上可以从个人的仓库里推送和拉取改变,但是我们不鼓励这样做,因为一不留心就很 容易弄混其他人的进度。另外,你也一定希望合作者们即使在自己不开机的时候也能从仓库获取数据——拥有 一个更稳定的公共仓库十分有用。因此,更好的合作方式是建立一个大家都可以访问的共享仓库,从那里推送和拉取数据。我们将把这个仓库称为 “Git 服务器”;代理一个 Git 仓库只需要花费很少的资源,几乎从不 需要整个服务器来支持它的运行。</p>

<p>架设一个 Git 服务器有很多种选择，这里不打算展开，不是一下子能讲清楚的，让我们看个实例。架设一个使用SSH传输数据和使用 authorized_keys 方法来给用户授权的Git服务器：
```bash
// Step 1:创建一个 ‘git’ 用户并为其创建一个 .ssh 目录
$ sudo adduser git
$ su -l git
$ cd ~
$ mkdir .ssh</p>

<p>// Step 2:把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。
// 假设你通过 e-mail 收到了几个 公钥并存到了临时文件里
$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys</p>

<p>// Step 3:使用 &mdash;bare 选项运行 git init 来设定一个空仓库,这会初始化一个不包含工作目录的仓库
$sudo mkdir /opt/git
$sudo chown -R git /opt/git
$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git &mdash;bare init</p>

<p>// Mac 下需要开启ssh并允许remote login
$launchctl start sshd
// System Preferences &ndash;> Sharing &ndash;> Remote Login &ndash;> All Users</p>

<p>// Step 4:Join,Josie 或者 Jessica 就可以把它加为远程仓库,
推送一个分支,从而把第一个版本的工程上 传到仓库里了</p>

<h1>在 John 的电脑上</h1>

<p>$ cd myproject
$ git init
$ git add .
$ git commit -m &lsquo;initial commit&rsquo;
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master</p>

<p>// Step 5:其他人的克隆和推送也一样变得很简单
$ git clone git@gitserver:/opt/git/project.git $ vim README
$ git commit -am &lsquo;fix for the README file&rsquo;
$ git push origin master</p>

<p>// Step 6:用这个方法可以很快捷的为少数几个开发者架设一个可读写的 Git 服务</p>

<p>// 如何生成 SSH 公钥？
// Step 1:首先,确定一下是否已经有一个公钥了。SSH 公钥默认储存 在账户的 ~/.ssh 目录。
// 进入那里并查看其内容,有没有公钥一目了然:
$ cd ~/.ssh
$ ls
authorized_keys2 id_dsa known_hosts config id_dsa.pub</p>

<p>// Step 2:关键是看有没有用 文件名 和 文件名.pub 来命名的一对文件,
// 这个 文件名 通常是 id_dsa 或者 id_rsa。 .pub 文件是公钥,另一个文件是密钥。
// 假如没有这些文件(或者干脆连 .ssh 目录都没有),你可以用 ssh- keygen 的程序来建立它们,
// 该程序在 Linux/Mac 系统由 SSH 包提供, 在 Windows 上则包含在 MSysGit 包 里:
$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/schacon/.ssh/id_rsa.
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#115;&#99;&#x68;&#x61;&#x63;&#111;&#110;&#x40;&#97;&#103;&#97;&#100;&#x6f;&#x72;&#x6c;&#97;&#x70;&#116;&#x6f;&#112;&#46;&#108;&#x6f;&#x63;&#x61;&#x6c;">&#x73;&#99;&#x68;&#x61;&#99;&#111;&#110;&#x40;&#x61;&#x67;&#x61;&#x64;&#x6f;&#x72;&#x6c;&#x61;&#112;&#116;&#111;&#x70;&#46;&#108;&#x6f;&#x63;&#97;&#108;</a></p>

<p>// Step 3:它先要求你确认保存公钥的位置(.ssh/id_rsa),然后它会让你重复一个密码两次,
// 如果不想在使用公钥的 时候输入密码,可以留空。
// 现在,所有做过这一步的用户都得把它们的公钥给你
// 或者 Git 服务器的管理者(假设 SSH 服务被设定为使 用公钥机制)。
// 他们只需要复制 .put 文件的内容然后 e-email 之。公钥的样子大致如下:
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#x3a;&#115;&#99;&#x68;&#97;&#99;&#111;&#x6e;&#x40;&#x61;&#103;&#97;&#x64;&#111;&#114;&#x6c;&#97;&#112;&#116;&#x6f;&#112;&#x2e;&#108;&#111;&#x63;&#97;&#108;">&#x73;&#x63;&#x68;&#x61;&#99;&#x6f;&#x6e;&#64;&#97;&#x67;&#97;&#x64;&#x6f;&#114;&#108;&#x61;&#x70;&#116;&#x6f;&#112;&#46;&#108;&#111;&#x63;&#97;&#x6c;</a>
```</p>

<p>作为一个额外的防范措施,你可以用 Git 自带的 git-shell 简单工具来把 git 用户的活动限制在仅与 Git 相关。把它设为 git 用户登入的 shell,那么该用户就不能拥有主机正常的 shell 访问权。为了实现这一 点,需要指明用户的登入shell 是 git-shell ,而不是 bash 或者 csh。你可能得编辑 /etc/passwd 文件:
```bash
// Step 1:
$ sudo vim /etc/passwd</p>

<p>// Step 2:在文件末尾,你应该能找到类似这样的行
git:x:1000:1000::/home/git:/bin/sh</p>

<p>// Step 3:把 bin/sh 改为 /usr/bin/git-shell (或者用 which git-shell 查看它的位置)。该行修改后的样子如下
git:x:1000:1000::/home/git:/usr/bin/git-shell</p>

<p>// Step 4:现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库,而不能直接使用主机 shell。
// 尝试登录的话,你会 看到下面这样的拒绝信息
$ ssh git@gitserver
fatal: What do you think I am? A shell? (你以为我是个啥?shell吗?)
Connection to gitserver closed. (gitserver 连接已断开。)
```</p>

<h3>Git基础</h3>

<p>为了和其他人愉快地的合作开发，我们要掌握Git的基本命令。你不会想看到人民群众仇恨你。  <br/>
1)Git基础要点; <br/>
2)配置Git; <br/>
3)Git分支;
4)记录每次更新到仓库;  <br/>
5)撤消操作; <br/>
6)远程仓库的使用;  <br/>
7)打标签;  <br/>
8)查看提交历史。</p>

<h4>Git基础要点</h4>

<p>对于任何一个文件,在 Git 内都只有三种状态:已提交 (committed),已修改(modified)和已暂存(staged)。已提交表示该文件已经被安全地保存在本地数据 库中了;已修改表示修改了某个文件,但还没有提交保存;已暂存表示把已修改的文件放在下次提交时要保存 的清单中。
由此我们看到 Git 管理项目时,文件流转的三个工作区域:Git 的本地数据目录,工作目录以及暂存区域。</p>

<p>每个项目都有一个 git 目录,它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要,每次克隆 镜像仓库的时候,实际拷贝的就是这个目录里面的数据。
从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录。这些文件实际上都是从 git 目录中的压缩对象数据库中提取出来的,接下来就可以在工作目录中对这些文件进行编辑。
所谓的暂存区域只不过是个简单的文件,一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件,不过标准说法还是叫暂存区域。</p>

<p>基本的 Git 工作流程如下:  <br/>
a)在工作目录中修改某些文件;  <br/>
b)对这些修改了的文件作快照,并保存到暂存区域;  <br/>
c)提交更新,将保存在暂存区域的文件快照转储到 git 目录中.</p>

<h5>配置Git</h5>

<p>一般在新的系统上,我们都需要先配置下自己的 Git 工作环境。配置工作只需一次,以后升级时还会沿用 现在的配置。当然,如果需要,你随时可以用相同的命令修改已有的配置。</p>

<p>Git 提供了一个叫做 git config 的工具(译注:实际是 git-config 命令,只不过可以通过 git 加一个 名字来呼叫此命令。),专门用来配置或读取相应的工作环境变量。而正是由这些环境变量,决定了 Git 在 各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方:  <br/>
1)/etc/gitconfig文件:系统中对所有用户都普遍适用的配置。若使用 git config 时用 &mdash;system 选项,读写 的就是这个文件。  <br/>
2)~/.gitconfig文件:用户目录下的配置文件只适用于该用户。若使用 git config 时用 &mdash;global 选项,读写 的就是这个文件。 <br/>
3)当前项目的 git 目录中的配置文件(也就是工作目录中的 .git/config 文件):这里的配置仅仅针对当前 项目有效。每一个级别的配置都会覆盖上层的相同配置,所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</p>

<p>```bash
// Quilk config
// 用户信息
$ git config &mdash;global user.name &ldquo;John Doe&rdquo;
$ git config &mdash;global user.email <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#106;&#x6f;&#x68;&#x6e;&#x64;&#x6f;&#x65;&#64;&#101;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#106;&#x6f;&#x68;&#x6e;&#100;&#x6f;&#101;&#x40;&#x65;&#x78;&#x61;&#109;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a></p>

<p>// 文本编辑器
$ git config &mdash;global core.editor emacs</p>

<p>// 差异分析工具
$ git config &mdash;global merge.tool vimdiff</p>

<p>// 查看配置信息
$ git config &mdash;list</p>

<p>```</p>

<h5>Git分支</h5>

<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来,然后在不影响主线的同时继续工作。
1)新建分支;
```bash
// 新建本地分支
git branch [&mdash;set-upstream | &mdash;track | &mdash;no-track] [-l] [-f] <branchname> [&lt;start-point>]</p>

<p>&mdash;set-upstream
如果指定的分支不存在，或者指定了&mdash;force参数，作用和&mdash;track一样。
否则当创建分支时建立像&mdash;track一样的配置，除了分支的指向没有改变。</p>

<p>&mdash;track</p>

<p>当创建新的分支，从新分支建立branch.<name>.remote和branch.<name>.merge的配置入口
去标记start-point 分支作为“upstream”。
这个配置会告诉git在git status和git branch -v中显示两个分支的关系。
而且，当新的分支被检出时，它会引导git pull在没带参数时去从upstream拉代码。</p>

<p>当我们的start point是remote-tracking分支时，这一行为是默认的。
如果你想让git checkout和git branch总是像给定&mdash;no-track一样执行，设置branch.autosetupmerge 配置变量为false。
当start-point是local或remote-tracking分支时，上述行为是你想要的，那么设置它为always。</p>

<p>&mdash;no-track
不建立"upstream"配置，即使branch.autosetupmerge配置变量的值是true。</p>

<p>-l
创建分支的引用日志。它会激活对分支引用所有改变模式的记录，开启使用基于sha1表达式的日期，
如"<branchname>@{yesterday}&ldquo;。
注意在non-bare仓库中，引用日志由于core.logallrefupdates配置选项默认都开启的。</p>

<p>-f
如果<branchname>已经存在，重置<branchname>到<startpoint>。没有-f git branch将会拒绝改变。</p>

<p><branchname>
要创建或删除分支的名称。新分支的名称必须通过git-check-ref-format(1)定义的所有检查。
有些检查会限制分支名称中能使用的字符。</p>

<p>&lt;start-point>
已经存在的分支名，对它应用和<branchname>相同的限制。</p>

<p>如果我们没有指定&lt;start-point>,它默认是HEAD。
$git branch <branchname> &lt;start-point></p>

<p>// 新建远程仓库分支
git push [远程名] [本地分支]:[远程分支]</p>

<p>```</p>

<p>2)删除分支;
```bash
// 删除本地分支
$ git branch -d <branchname></p>

<p>// 删除远程分支
// 如果想在服务器上删 除 serverfix 分支,运行下面的命令:
$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
&ndash; [deleted] serverfix
```</p>

<p>3)切换分支;
<code>bash
git checkout &lt;branchname&gt;
</code></p>

<p>4)合并分支;
<code>bash
// 将sourceBranchname合并到destinationBranchname
$git checkout destinationBranchname
$git merge sourceBranchname
</code></p>

<p>5)衍合分支。
```bash
// 把一个分支整合到另一个分支的办法有两种:merge(合并) 和 rebase(衍合)。
// 把在 branchA 里产生的变化补丁重新在 branchB 的基础上打一遍。在 Git 里,这种 操作叫做衍合(rebase)。
// 有了 rebase 命令,就可以把在一个分支里提交的改变在另一个分支里重放一遍。
// 例如将experiment衍合到master分支:
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it&hellip; Applying: added staged command</p>

<p>```
关于如何进行分支管理，可以看看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">这篇博文</a>。</p>

<h5>记录每次更新到仓库</h5>

<p>版本控制的主要作用就是记录我们的更新，如果我们不将更新记录到远程仓库就失去意义了。
```bash
// 检查当前文件状态
$ git status</p>

<h1>On branch master</h1>

<p>nothing to commit (working directory clean)</p>

<p>// 跟踪新文件
$ git add newFilename</p>

<p>// 暂存已修改文件
$ git add trackedFilename</p>

<p>// 忽略某些文件
//一般我们总会有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。
我们可以创建一个名为 .gitignore 的文件,列出要忽略的 文件模式。</p>

<p>// 文件 .gitignore 的格式规范如下:
// 1)所有空行或者以注释符号 # 开头的行都会被 Git 忽略。
// 2)可以使用标准的 glob 模式匹配, 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。
// 3)匹配模式最后跟反斜杠(/)说明要忽略的是目录。
/*</p>

<h1>此为注释 – 将被 Git 忽略</h1>

<p><em>.a # 忽略所有 .a 结尾的文件
!lib.a # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件
doc/</em>.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
*/</p>

<p>// 查看已暂存和未暂存的更新
// 实际上 git status 的显示比较简单,仅仅是列出了修改过的文件,如果要查看具体修改了什么地方,可以用 git diff 命令。
$ git diff
diff &mdash;git a/benchmarks.rb b/benchmarks.rb index 3cb747f..da65585 100644
&mdash;&ndash; a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6
+ + + +
+36,10 @@ def main @commit.parents[0].parents[0].parents[0]
end
run_code(x, &lsquo;commits 1&rsquo;) do git.commits.size
end
run_code(x, &lsquo;commits 2&rsquo;) do
log = git.commits(&lsquo;master&rsquo;, 15) log.size</p>

<p>// 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用 git diff &mdash;cached 命令。</p>

<p>// 提交更新
$ git commit</p>

<p>// 跳过使用暂存区域
// 尽管使用暂存区域的方式可以精心准备要提交的细节,但有时候这么做略显繁琐。
Git 提供了一个跳过使用 暂存区域的方式,只要在提交的时候,给 git commit 加上 -a 选项,
Git 就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过 git add 步骤:
$ git commit -a -m &lsquo;added new benchmarks&rsquo;
[master 83e38c7] added new benchmarks
1 files changed, 5 insertions(+), 0 deletions(&ndash;)</p>

<p>// 移除文件
// 要从 Git 中移除某个文件,就必须要从已跟踪文件清单中移除(确切地说,是从暂存区域移除),然后提交。
可以用 git rm 命令完成此项工作,并连带从工作目录中删除指定的文件,这样以后就不会出现在未跟踪 文件清单中了。
// 如果只是简单地从工作目录中手工删除文件,运行 git status 时就会在 “Changed but not updated” 部分(也就是<em>未暂存</em>清单)看到。</p>

<p>// 移动文件
$ git mv file_from file_to</p>

<p>```</p>

<h5>撤消操作</h5>

<p>任何时候,你都有可能需要撤消刚才所做的某些操作。
```bash
// 修改最后一次提交
// 有时候我们提交完了才发现漏掉了几个文件没有加,或者提交信息写错了。想要撤消刚才的提交操作,可以 使用 &mdash;amend 选项重新提交:
$ git commit &mdash;amend</p>

<p>// 取消已经暂存的文件
git reset HEAD <file>&hellip;</p>

<p>// 取消对文件的修改
use &ldquo;git checkout &mdash; <file>&hellip;&rdquo; to discard changes in working directory</p>

<p>```</p>

<h5>远程仓库的使用</h5>

<p>```bash
// 查看当前的远程库
git remote [-v]</p>

<p>// 添加远程仓库
git remote add [shortname] [url]</p>

<p>// 从远程仓库抓取数据
$ git fetch [remote-name]</p>

<p>// 推送数据到远程仓库
git push [remote-name] [branch-name]</p>

<p>// 查看远程仓库信息
git remote show [remote-name]</p>

<p>// 远程仓库的删除和重命名
// 可以用 git remote rename 命令修改某个远程仓库的简短名称,比如想把 pb 改成 paul,可以这么运行:
$ git remote rename pb paul $ git remote
origin
paul</p>

<p>// 移除 对应的远端仓库,可以运行 git remote rm 命令:
$ git remote rm paul $ git remote
origin
```</p>

<h5>打标签</h5>

<p>人们在发布某个软件版本(比如 v1.0 等等)的时候,经常会打上一标签。
```bash
// 列显已有的标签
$ git tag v0.1
v1.3</p>

<p>// 新建标签
// Git 使用的标签有两种类型:轻量级的(lightweight)和含附注的(annotated)。
轻量级标签就像是个不 会变化的分支,实际上它就是个指向特定提交对象的引用。
而含附注标签,实际上是存储在仓库中的一个独立 对象,它有自身的校验和信息,
包含着标签的名字,电子邮件地址和日期,以及标签说明,标签本身也允许使 用 GNU Privacy Guard (GPG) 来签署或验证。
一般我们都建议使用含附注型的标签,以便保留相关信息;
当然,如果只是临时性加注标签,或者不需要旁注额外信息,用轻量级标签也没问题。</p>

<p>// 创建一个含附注类型的标签非常简单,用 -a (译注:取 annotated 的首字母)指定标签名字即可:
$ git tag -a v1.4 -m &lsquo;my version 1.4&rsquo;</p>

<p>// 可以使用 git show 命令查看相应标签的版本信息,并连同显示打标签时的提交对象。
$ git show v1.4
tag v1.4
Tagger: Scott Chacon <a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#115;&#x63;&#x68;&#x61;&#99;&#111;&#110;&#x40;&#x67;&#101;&#101;&#x2d;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#x73;&#99;&#104;&#x61;&#x63;&#x6f;&#110;&#x40;&#103;&#101;&#101;&#45;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;</a> Date: Mon Feb 9 14:45:11 2009 -0800
my version 1.4
commit 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge: 4a447f7&hellip; a6b4c97&hellip;
Author: Scott Chacon <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#x73;&#99;&#x68;&#97;&#99;&#111;&#110;&#x40;&#x67;&#x65;&#101;&#45;&#x6d;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#x73;&#x63;&#x68;&#x61;&#99;&#x6f;&#x6e;&#64;&#x67;&#101;&#x65;&#45;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#x6d;</a> Date: Sun Feb 8 19:02:46 2009 -0800
Merge branch &lsquo;experiment&rsquo;</p>

<p>// 签署标签
//如果你有自己的私钥,还可以用 GPG 来签署标签,只需要把之前的 -a 改为 -s (译注: 取 Signed 的首
字母)即可:
$ git tag -s v1.5 -m &lsquo;my signed 1.5 tag&rsquo;
You need a passphrase to unlock the secret key for user: &ldquo;Scott Chacon <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x73;&#x63;&#x68;&#x61;&#99;&#111;&#110;&#x40;&#103;&#101;&#101;&#45;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#115;&#x63;&#x68;&#97;&#99;&#111;&#x6e;&#64;&#x67;&#x65;&#x65;&#45;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a>&rdquo;
1024-bit DSA key, ID F721C45A, created 2009-02-09</p>

<p>// 轻量级标签
// 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。
要创建这样的标签,一个 -a,-s 或 -m 选项都不用,直接给出标签名字即可:
$ git tag v1.4-lw</p>

<p>// 验证标签
// 可以使用 git tag -v [tag-name] (译注:取 verify 的首字母)的方式验证已经签署的标签。
此命令会调用 GPG 来验证签名,所以你需要有签署者的公钥,存放在 keyring 中,才能验证:
$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x6a;&#117;&#110;&#107;&#x69;&#x6f;&#x40;&#x63;&#x6f;&#x78;&#46;&#x6e;&#101;&#x74;">&#106;&#117;&#x6e;&#107;&#x69;&#x6f;&#64;&#x63;&#x6f;&#x78;&#46;&#x6e;&#101;&#x74;</a> 1158138501 -0700
GIT 1.4.2.1
Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &ldquo;Junio C Hamano <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#106;&#117;&#110;&#x6b;&#105;&#111;&#x40;&#x63;&#111;&#x78;&#46;&#x6e;&#101;&#116;">&#106;&#117;&#x6e;&#x6b;&#x69;&#111;&#64;&#99;&#111;&#x78;&#46;&#110;&#x65;&#x74;</a>&rdquo;
gpg: aka &ldquo;[jpeg image of size 1513]&rdquo;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A</p>

<p>// 后期加注标签
// 比如在下面展示的提交历史中:
$ git log &mdash;pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &lsquo;experiment&rsquo;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &lsquo;experiment&rsquo;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</p>

<p>// 我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2,没关系,现在也能做。
只要在打标 签的时候跟上对应提交对象的校验和(或前几位字符)即可:
$ git tag -a v1.2 9fceb02</p>

<p>// 分享标签
// 默认情况下,git push 并不会把标签传送到远端服务器上,只有通过显式命令才能分享标签到远端仓库。
其命令格式如同推送分支,运行 git push origin [tagname] 即可:
$ git push origin v1.5
Counting objects: 50, done.
Compressing objects: 100% (38/38), done. Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
* [new tag] v1.5 &ndash;> v1.5</p>

<p>// 如果要一次推送所有(本地新增的)标签上去,可以使用 &mdash;tags 选项:
$ git push origin &mdash;tags
```</p>

<h5>查看提交历史</h5>

<p>```bash
// 在提交了若干更新之后,又或者克隆了某个项目,想回顾下提交历史,可以使用 git log 命令。</p>

<p>// 我们常用 -p 选项展开显示每次提交的内容差异,用 -2 则仅显示最近的两次更新:
$ git log –p -2</p>

<p>// 还有 许多摘要选项可以用,比如 &mdash;stat,仅显示简要的增改行数统计:
$git log &mdash;stat</p>

<p>// 限制输出长度
// 列出所有最近两周内的提交
$ git log &mdash;since=2.weeks</p>

<p>```</p>

<h3>分布式工作流程</h3>

<p>在服务器上布暑好了Git，并建好代码仓库以后，团队成员就可以愉快地合作开发了。由于团队的规模不一样，工作流程也会略有区别，我们先通过最简单的私有的小型团队来掌握基本的流程，其他的情况也就容易理解了。
```bash
//一个私有项目,与你一起协作的还有另外一到两位开发者。这里说私有,是指源代码不公开,其他人无法访问项目仓库。</p>

<h1>John&rsquo;s Machine</h1>

<p>// Step 1: 克隆一份项目代码到本地
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/ &hellip;</p>

<p>// Step 2: 打开项目，编辑，完成属于自己的任务
$ cd simplegit/
$ vim lib/simplegit.rb</p>

<p>// Step 3:更新项目，因为在你完成任务的时间窗口中团队其他成员可能提交过代码
$ git fetch origin
&hellip;
From john@githost:simplegit
+ 049d078&hellip;fbff5bc master &ndash;> origin/master</p>

<p>// Step 4:合并分支，将团队成员的代码和自己的代码合并到一起
$ git merge origin/master Merge made by recursive.
TODO | 1 +
1 files changed, 1 insertions(+), 0 deletions(&ndash;)</p>

<p>// Step 5:合并分支冲突时
$git status</p>

<p>index.html: needs merge</p>

<h1># # # # #</h1>

<p>On branch master
Changed but not updated:
(use &ldquo;git add <file>&hellip;&rdquo; to update what will be committed)
(use &ldquo;git checkout &mdash; <file>&hellip;&rdquo; to discard changes in working directory)
unmerged: index.html</p>

<p>// 任何包含未解决冲突的文件都会以未合并(unmerged)状态列出。
Git 会在有冲突的文件里加入标准的冲突 解决标记,可以通过它们来手工定位并解决这些冲突。
可以看到此文件包含类似下面这样的部分:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</p>

<div id="footer">contact : email.support@github.com</div>


<h1> </h1>

<div id="footer">
please contact us at support@github.com </div>


<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>iss53:index.html</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

<p>// 可以看到 ======= 隔开的上半部分,是 HEAD(即 master 分支,在运行 merge 命令时检出的分支)中的内 容,
下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
比如你可以通过把这段内容替换为下面这样来解决:</p>

<div id="footer">
please contact us at email.support@github.com </div>


<p>// Step 6:手动解决冲突，然后运行 git add 将把它们标记为已解决(resolved),
如果觉得满意了,并且确认所有冲突都已解决,也就是进入了缓存区,就可以用 git commit 来完成这次合并提交。</p>

<p>$ git commit -am &lsquo;removed invalid default value&rsquo;
[master 738ee87] removed invalid default value
1 files changed, 1 insertions(+), 1 deletions(&ndash;)</p>

<p>// Step 7:将完成的代码推送到服务器的代码仓库中
$ git push origin master
&hellip;
To jessica@githost:simplegit.git
1edee6b..fbff5bc master &ndash;> master</p>

<p>```</p>

<h4>Reference</h4>

<p><a href="http://git-scm.com/book/zh/v1">Pro Git</a></p>
]]></content>
  </entry>
  
</feed>
