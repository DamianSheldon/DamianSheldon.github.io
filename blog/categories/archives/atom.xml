<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-12-05T17:16:26+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何创建自定义的Xcode 6 工程模板]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-to-creating-custom-xcode-6-project-templates.html/"/>
    <updated>2014-12-05T14:34:04+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-to-creating-custom-xcode-6-project-templates</id>
    <content type="html"><![CDATA[<p>使用Xcode 6新建工程时，Apple准备了好些模板，这些模板写个Demo还是没有问题的，但是用来组织项目文件还是太弱了，所以情况经常是不得不每次去新建各种目录，这种重复性的劳动一来乏味，二来浪费时间。那么我们能不像创建自己的模板呢？这样新建的工程就能按自己的想法包含各种目录和文件。好消息是可以，坏消息是Apple没有提供相应的文档。虽然没有文档，还是试着来创建一个模板，每次都重复实在太烦（就是这么任性）。</p>

<p>既然没有文档，我们就把Apple的模板复制一份，在它的基础上修改成我们需要的样子。<strong>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/</strong>有iOS所有工程模板。用户自定义的模板建议放到<strong>~/Library/Developer/Xcode/Templates/</strong>，目录如果不存在就创建。模板至少要包含两部分：一是扩展名为<strong>.xctemplate</strong>的文件夹；二是名称为<strong>TemplateInfo.plist</strong>的属性列表文件。好了，我们来创建一个自定义模板：</p>

<p>```
// Step 1:
$ mkdir ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>// Step 2:
$ cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/Project\ Templates/iOS/Application/Single\ View\ Application.xctemplate/* ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>```</p>

<!-- more -->


<p>现在我们有了一个和Single View Application一样的模板，但这和我们目标还相差很远。接下来我们要做就是修改<strong>TemplateInfo.plist</strong>，让模板为我们做更多准备工作。</p>

<table>
<thead>
<tr>
<th></th>
<th> Keys </th>
<th> Advice </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Ancestors   </td>
<td> No          | Import settings from another Project Template.</td>
</tr>
<tr>
<td></td>
<td> Concrete    </td>
<td> Recommended | Visible or hide Template form New Project Window.</td>
</tr>
<tr>
<td></td>
<td> Definitions </td>
<td> No          | Work with workplace. Can write to file example source code.</td>
</tr>
<tr>
<td></td>
<td> Description </td>
<td> Recommended | New Project Window &ndash; Project Template Description.</td>
</tr>
<tr>
<td></td>
<td> Identifier  </td>
<td> Yes         | Project Template Unique Identifier.</td>
</tr>
<tr>
<td></td>
<td> Kind        </td>
<td> Yes         | XCode Template Kind. Project or File.</td>
</tr>
<tr>
<td></td>
<td> Nodes       </td>
<td> Recommended | Create or Copy Files to Project. Copy works</td>
</tr>
<tr>
<td></td>
<td> Options     </td>
<td> Recommended | New Project Wizard >> Choose Options for Project. Add Text Fields, Combo Boxes.</td>
</tr>
<tr>
<td></td>
<td> Platforms   </td>
<td> Recommended | Set Platform.</td>
</tr>
<tr>
<td></td>
<td> Project     </td>
<td> Yes         | Set Project Build Settings.</td>
</tr>
<tr>
<td></td>
<td> Targets     </td>
<td> Recommended | Set Build Settings, Build Phases for Targets. Link Libraries.</td>
</tr>
</tbody>
</table>


<p>上面列出了TemplateInfo.plist大部分键，详细介绍在<a href="https://snipt.net/yonishin/about-xcode-4-project-template/">这里</a>。</p>

<p>我自己新建的模板主要用到Definitions和Nodes，它们俩组合起来可以控制模板会新建哪些文件。例如我想让模板包含Models目录：</p>

<p>```
// Step 1:
$ cd ~/Library/Developer/Xcode/Templates/CocoaBite.xctemplate/</p>

<p>// Step 2:
$ mkdir -p Models</p>

<p>// Step 3: 编辑TemplateInfo.plist 如下图所示。</p>

<p>```</p>

<div style="text-align: center" markdown="1">

    <img name="PropertyList" src="http://DamianSheldon.github.io/images/PropertyList.png" width="623" height="836">

</div>


<p>完整的模板放在<a href="https://github.com/DamianSheldon/Xcode-6-Project-Templates">这里</a>。</p>

<h2>Reference</h2>

<p><a href="http://meandmark.com/blog/2011/12/creating-custom-xcode-4-project-templates/">Creating Custom Xcode 4 Project Templates</a><br/>
<a href="https://snipt.net/yonishin/about-xcode-4-project-template/">About XCode 4 Project Template (How To Create Custom Project Template)</a><br/>
<a href="https://github.com/reidmain/Xcode-6-Project-Templates">Xcode-6-Project-Templates</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App Cache]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-cache.html/"/>
    <updated>2014-11-25T16:36:04+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-cache</id>
    <content type="html"><![CDATA[<p>在互联网时代的今天，iOS App几乎都要联网，缓存可以解决网络连接不良甚至无网络所造成的性能问题，而且还可以节约用户的流量。我们可以采用两种缓存策略：预缓存和按需缓存。预缓存就是应用启动以后开个后台线程去把需要用到的数据先取下来。按需缓存就是应用请求网络数据后在本地保存一份，只要本地数据没有过期就使用本地数据。</p>

<h3>预缓存</h3>

<p>实现预缓存可能需要一个后台线程访问数据并以有意义的格式保存，以便本地缓存无需连接服务器即可被编辑。Core Data(或者任何结构化存储)是实现这种缓存的一种方式。</p>

<h3>按需缓存</h3>

<p>按需缓存工作原理类似于浏览器缓存，它允许我们查看以前访问过的内容，主要有四种实现方法：</p>

<ol>
<li>URL缓存；</li>
<li>数据模型缓存；</li>
<li>Core Data;</li>
<li>SQLite。</li>
</ol>


<p>上述的序号是推荐使用的顺序。</p>

<h4>URL缓存</h4>

<p>如果服务器设计得体，遵循HTTP 1.1的缓存规范时，URL缓存效果最好，通常网络库会提供支持。</p>

<!-- more -->


<h4>数据模型缓存</h4>

<p>数据模型缓存是把模型对象用NSKeyedArchiver归档，模型类需要实现NSCoding协议。</p>

<p>使用数据模型缓存时，有个小技巧，可以为它创建内存缓存。这样有两点好处：一是可以延长闪存的使用寿命；二是可以略微提高性能。</p>

<h4>Core Data</h4>

<p>使用Core Data进行按需缓存，需要权衡Core Data的复杂度是否值得。</p>

<h4>SQLite</h4>

<p>使用SQLite时，要注意当前的二进制包是否是线程安全的。</p>

<h2>Reference</h2>

<p>iOS 6 Programming Push the Limits</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 调试技巧（持续更新）]]></title>
    <link href="http://DamianSheldon.github.io/blog/xcode-debug-tips.html/"/>
    <updated>2014-11-24T17:14:52+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/xcode-debug-tips</id>
    <content type="html"><![CDATA[<p>iOS App开发过程中不可避免地遇到程序崩溃的问题。当程序崩溃时，我们首先要找到它崩溃的原因。一旦找到原因，问题就容易解决了。Xcode Debugger是查找崩溃原因的有利工具，我们应该学会熟练使用它，迅速解决问题，节约宝贵的开发时间。</p>

<h3>崩溃在main( )</h3>

<p>添加Exception Breakpoint</p>

<p>Project > Breakpoint navigator > +（Bottom left）> Add Exception Breakpoint</p>

<h3>符号断点</h3>

<p>符号断点是我们验证某个方法是否被调用的一种方法。添加方法：</p>

<p>Project > Breakpoint navigator > +（Bottom left）> Add Symbolic Breakpoint</p>

<p>例如：<code>application:DidFinishLaunchingWithOptions:</code>。</p>

<h3>打印方法名</h3>

<p>```
NSLog(@&ldquo;%s&rdquo;, <strong>PRETTY_FUNCTION</strong>);</p>

<p>```</p>

<h3>控制台打印</h3>

<p>```
(lldb) p // 打印标量变量
(lldb) p (int)self.myAge
(lldb) p (CGPoint)self.view.center</p>

<p>(lldb) po // 打印对象</p>

<p>```</p>

<!-- more -->


<h3>打印异常信息</h3>

<p>```
/<em>
The symbol $eax refers to one of the CPU registers.  <br/>
In the case of an exception, <br/>
this register will contain a pointer to the NSException object. <br/>
Note: $eax only works for the simulator, <br/>
if you’re debugging on the device you’ll need to use register $r0.<br/>
</em>/
// Simulator</p>

<p>(lldb) po [$eax class]</p>

<p>(lldb) po [$eax name]</p>

<p>(lldb) po [$eax reason]</p>

<p>// Real Device
(lldb) po $r0
```</p>

<h3>SIGABRT</h3>

<p>SIGABRT:SIGNAL ABORT(中止信号)。通常可以让程序继续运行，之后会输出些有助于定位问题的信息。</p>

<h3>EXC_BAD_ACCESS</h3>

<p>它出现的原因是因为访问一个已经释放的对象或向它发送消息。通常可以开启Zombie Objects(Toolbar > Edit Scheme&hellip; > Run > Diagnostics > Enabled Zombie Objects)重新运行程序以定位问题。</p>

<p>Note that you shouldn’t leave Zombie Objects enabled all the time. Because this tool never deallocates memory, but simply marks it as being undead, you end up leaking all over the place and will run out of free memory at some point. So only enable Zombie Objects to diagnose a memory-related error, and then disable it again.</p>

<p>Enabled Zombie Objects后，控制台通常会打印出<code>*** -[CFNumber respondsToSelector:]: message sent to deallocated instance 0x31ab5cfe0</code>类似的信息，那么问题来了，我们怎么知道0x31ab5cfe0是哪个对象？</p>

<p>Apple Memory Usage Performace Guidelines中介绍了记录内存分配历史的方法，简述如下：</p>

<ol>
<li>设置环境变量： MallocStackLogging，MallocStackLoggingNoCompact为1；</li>
</ol>


<div style="text-align: center" markdown="1">

    <img name="Environment" src="http://DamianSheldon.github.io/images/Environment.png" width="448" height="252">

</div>




<div style="text-align: center" markdown="1">

    <img name="Zombie" src="http://DamianSheldon.github.io/images/Zombie.png" width="448" height="252">

</div>


<ol>
<li>使用malloc_history命令找到相应的对象。</li>
</ol>


<p>```
malloc_history &lt;pid/partial-process-name> [options] <mode> [<address> &hellip;]</p>

<p>// pid/partial-process-name是当前上下文NSLog输出时的前面[]的对应数字
2014-12-02 14:44:39.355 srsApp[7946:300216] selector:0x1014d70b3, jsonValue:0x31a896fd0</p>

<p>malloc_history 5968/224511 0x2d9e23fe0 | grep &ldquo;0x2d9e23fe0"。
```</p>

<div style="text-align: center" markdown="1">

    <img name="Malloc_history" src="http://DamianSheldon.github.io/images/Malloc_history.png" width="720" height="106">

</div>


<p>Reference:</p>

<p>Memory Usage Performace Guidelines <br/>
iOS 6 Programming Pushing the Limits<br/>
<a href="http://www.raywenderlich.com/10209/my-app-crashed-now-what-part-1">My App Crashed, Now What? – Part 1</a>  <br/>
<a href="http://www.raywenderlich.com/10505/my-app-crashed-now-what-part-2">My App Crashed, Now What? – Part 2</a><br/>
<a href="http://www.raywenderlich.com/28289/debugging-ios-apps-in-xcode-4-5">Intermediate Debugging with Xcode 4.5</a>   <br/>
<a href="http://www.iwangke.me/2013/01/15/xcode-debugging-tips/">Xcode调试技巧</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App 数据持久化]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-data-persistence.html/"/>
    <updated>2014-11-13T15:06:25+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-data-persistence</id>
    <content type="html"><![CDATA[<p>数据的持久化就是让数据能够持久的保存，实现它的方法有两种：云端和本地。本文试着简单总结本地持久化的方法。</p>

<p>本地持久化其实就是将数据保存到闪存，那么我们应该用什么方法保存，又应该保存在哪呢？</p>

<h2>文件系统基础</h2>

<p>在OS X和iOS中，文件系统处理数据文件，应用程序和操作系统本身相关文件的持久存储。
我们要知道把数据保存到哪，就要知道些iOS文件系统的知识。</p>

<p>iOS应用和文件系统的交互基本上仅限于它沙盒内目录。新应用安装过程中，安装程序为应用创建了数个容器。每个容器有个特定的角色。The bundle container holds the app’s bundle, whereas the data container holds data for both the application and the user. The data container is further divided into a number of directories that the app can use to sort and organize its data. The app may also request access to additional containers—for example, the iCloud container—at runtime.</p>

<p>这些容器构成了应用文件系统的基本面。下图是应用沙盒的示意图。</p>

<div style="text-align:center" markdown="1">

<img name="ios_app_layout_2x" src="images/ios_app_layout_2x.png" width="383" height="417">

</div>




<!-- more -->


<p>iOS应用常用的目录列表：</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> Directory </th>
<th align="left"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> AppName.app </td>
<td align="left"> This is the app’s bundle</td>
</tr>
<tr>
<td></td>
<td align="left"> Documents/ </td>
<td align="left"> Use this directory to store user-generated content.</td>
</tr>
<tr>
<td></td>
<td align="left"> Documents/Inbox </td>
<td align="left"> Use this directory to access files that your app was asked to open by outside entities.</td>
</tr>
<tr>
<td></td>
<td align="left"> Library/ </td>
<td align="left"> This is the top-level directory for any files that are not user data files.</td>
</tr>
<tr>
<td></td>
<td align="left"> tmp/ </td>
<td align="left"> Use this directory to write temporary files that do not need to persist between launches of your app.</td>
</tr>
</tbody>
</table>


<h3>数据的建议存储位置</h3>

<p>限于篇幅，关于应用的数据应该放到哪，可以查阅<strong>File System Programming Guide</strong> > <strong>File System Basics</strong> > <strong>About the iOS File System</strong> > <strong>Where You Should Put Your App’s Files</strong>。</p>

<h3>数据持久化的方法</h3>

<ol>
<li>NSUserDefaults;</li>
<li>Property Lists;</li>
<li>Archive;</li>
<li>数据库;</li>
<li>Core Data。</li>
</ol>


<h4>NSUserDefaults</h4>

<p>NSUserDefaults类提供与默认系统交互的程序接口。默认系统允许应用去自定义它的行为来符合用户的偏好。所以它主要是用来存储些配置信息。
它支持的数据类型有：floats，doubles，integers，Booleans，URLs，NSData，NSString，NSNumber，NSDate，NSArray和NSDictionary。如果还想存储其他类型的对象，需要使用NSData对它们进行归档。</p>

<h4>Property Lists</h4>

<p>当我们的需要持久化的数据量在几百KB内时，property list为我们提供了统一而方便的方法持久化数据。如果我们对象的全由NSDictionary, NSArray, NSString, NSDate, NSData, 或NSNumber类派生，我们可以创建property list。事实上，NSUserDefaults就是把数据保存在property list中。</p>

<p>Property list有三种存储方式：XML, binary format, &ldquo;old-style&rdquo; ASCII format inherited from OpenStep。old-style format的序列化API是只读的。</p>

<p>XML property list比binary格式的可移植性好，可以手动编辑，但是binary property lists兼容性好，需要的存储空间少，读写速度要优于XML property lists。通常来说，如果你的property list相对较小，XML property lists的优点会战胜它相对binary property lists的I/O速度，难兼容的缺点。如果你有大量数据，binary property lists, keyed archives，或自定义数据格式会是更好的解决方案。</p>

<h4>Archive</h4>

<p>Archives提供了一种把对象和值转成结构独立的字节流，它保留了对象与值，以及对象与对象的关系信息。</p>

<p>Cocoa archives可以持有Objective-c对象，标量，数组，结构体和字符串。它不能持有和平台相关的类型，例如union, void *, function pointers, 和long chains of pointers。</p>

<p>对象写入archive和从archive读出是使用coder对象。Coder对象是抽象类NSCoder具体子类的实例。它通过给对象发送NSCoding协议定义的encodeWithCoder: 和initWithCoder:方法分别写入或读出archiver。只有支持NSCoding协议的对象才能写入archiver。</p>

<h4>数据库</h4>

<p>iOS中有了以上数据持久化方法，我们为什么还需要数据库？</p>

<p>目前在iOS App开发中，SQLite是个不错的选择。</p>

<hr />

<p>SQLite</p>

<blockquote><p>SQLite is an in-process library that implements a self-contained, serverless, zero-configuration, transactional SQL database engine.</p></blockquote>

<p>SQLite在众多数据库中脱颖而出，目前是个不错的选择，但由于它是C接口，操作略显繁琐，就有了很多对它的封装，FMDB是个不错的选择。</p>

<h4>Core Data</h4>

<p>Core Data是Apple为我们提供的一种持久化方法，比较强大也比较复杂。</p>

<h1>Reference</h1>

<p>File System Programming Guide <br/>
Property List Programming Guide   <br/>
Archives and Serializations Programming Guide  <br/>
<a href="http://www.infoq.com/cn/articles/data-storage-in-ios">对比iOS中的四种数据存储</a>  <br/>
<a href="http://www.cnblogs.com/kenshincui/p/3885689.html#archiver">IOS开发系列—Objective-C之Foundation框架</a>  <br/>
<a href="http://www.cnblogs.com/kenshincui/p/4077833.html">iOS开发系列&mdash;数据存取</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Key-Value Coding &amp; Key-Value Observing]]></title>
    <link href="http://DamianSheldon.github.io/blog/key-value-coding-and-key-value-observing.html/"/>
    <updated>2014-11-12T16:06:13+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/key-value-coding-and-key-value-observing</id>
    <content type="html"><![CDATA[<h2>Key-Value Coding</h2>

<ol>
<li>Key-Value Coding是什么？</li>
<li>为什么要用Key-Value Coding？</li>
<li>如何使用Key-Value Coding?</li>
</ol>


<h3>Key-Value Coding是什么？</h3>

<blockquote><p>Key-value coding is a mechanism for accessing an object’s properties indirectly, using strings to identify properties, rather than through invocation of an accessor method or accessing them directly through instance variables.</p></blockquote>

<p>Key-value coding是一种间接访问对象属性和机制，使用字符串去区别属性，而不是通过调用存取方法或者通过实例变量直接访问它们。</p>

<h3>为什么要用Key-Value Coding？</h3>

<ol>
<li>Scripting（OS X）;</li>
<li>简化代码和提高灵活性；</li>
</ol>


<h3>如何使用Key-Value Coding?</h3>

<p>Key-value coding支持对象属性，也可以是标量类型和结构体。在开始使用之前，我们先熟悉些下key-value coding术语，后文我们用术语来阐述，方便交流。</p>

<p>除了重载现有的术语，key-value coding定义了些专属的术语。</p>

<p>Key-value coding可以被用来访问三种不同的类型的对象值：<strong>attributes</strong>, <strong>to-one relationships</strong>, 和<strong>to-many relationships</strong>。术语<strong>property</strong>指三种类型值的任意一种。</p>

<p>attribute是简单值的property，像标量，字符串，或者布尔值。NSNumber和其他的不可变类型如NSColor也都被认为是attributes。</p>

<p>to-one relationship是拥有自己properties的对象。这些内部的properties可以改变而对象却不变。例如，NSView实例的superview就是to-one relationship。</p>

<p>to-many relationship包括一个相关对象的集合。NSArray或NSSet经常被用来持有这样一个集合。但是，key-value coding允许你使用自定义的类作为集合并且通过实现在to-many Properties中讨论的key-value coding存取方法仍然可以可以像它们是NSArray或NSSet那样访问它们。</p>

<p>既然key-value coding是一种间接访问对象属性的机制，访问就包括存取。</p>

<!-- more -->


<h4>使用key-value coding读取attribute值</h4>

<p>NSKeyValueCoding中定义的的attribute读取方法有：</p>

<p>```
&ndash; (id)valueForKey:(NSString *)key;</p>

<ul>
<li><p>(NSMutableArray <em>)mutableArrayValueForKey:(NSString </em>)key;</p></li>
<li><p>(id)valueForKeyPath:(NSString *)keyPath;</p></li>
<li><p>(NSMutableArray <em>)mutableArrayValueForKeyPath:(NSString </em>)keyPath;</p></li>
<li><p>(NSDictionary <em>)dictionaryWithValuesForKeys:(NSArray </em>)keys;</p></li>
<li><p>(id)valueForUndefinedKey:(NSString *)key;</p></li>
</ul>


<p>```</p>

<h4>使用key-value coding存储attribute值</h4>

<p>```
&ndash; (void)setValue:(id)value forKey:(NSString *)key;</p>

<ul>
<li><p>(NSMutableSet <em>)mutableSetValueForKey:(NSString </em>)key;</p></li>
<li><p>(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</p></li>
<li><p>(NSMutableSet <em>)mutableSetValueForKeyPath:(NSString </em>)keyPath;</p></li>
<li><p>(void)setValue:(id)value forUndefinedKey:(NSString *)key;</p></li>
<li><p>(void)setNilValueForKey:(NSString *)key;</p></li>
<li><p>(void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues;</p></li>
</ul>


<p>```</p>

<p>你需要考虑一个额外的问题就是当你尝试设置非对象的property为nil。这种情况下，接收者给它自己发送一个setNilValueForKey:消息。它默认的实现是抛出NSInvalidArgumentException异常。你的应用可以覆盖这个方法替换默认值或标记值，然后你用新值调用setValue:forKey:。</p>

<p>现在，我们知道怎么用key-value coding去间接访问对象的property了。但是，如果想让我们自定义的类的property也支持key-value coding的话，我们应该怎么做呢？</p>

<h4>如何让自定义类的属性支持key-value coding?</h4>

<blockquote><p>Key-value coding attempts to use accessor methods to get and set values, before resorting to directly accessing the instance variable.</p></blockquote>

<p>在依靠直接访问实例变量之前，key-value coding尝试使用存取方法去访问和设置值。也就是说我们最好实现相应的存取方法，至少也要存在合适的实例变量。</p>

<p>前面提到key-value coding支持三个类型的attribute,针对三种类型的attribute,key-value coding分别是怎么来搜索存取方法和实例变量的呢？</p>

<ol>
<li>简单attributes存取方法搜索模式；</li>
<li>顺序集合存取方法的搜索模式；</li>
<li>唯一顺序集合存取方法的搜索模式；</li>
<li>无序集合存取方法的搜索模式。</li>
</ol>


<p>搜索的细节可以查阅Key-Value Coding Programming Guide。</p>

<h2>Key-Value Observing</h2>

<ol>
<li>Key-Value Observing是什么？</li>
<li>为什么要用Key-Value Observing？</li>
<li>如何使用Key-Value Observing?</li>
</ol>


<h3>Key-Value Observing是什么？</h3>

<blockquote><p>Key-value observing is a mechanism that allows objects to be notified of changes to specified properties of other objects.</p></blockquote>

<p>Key-value observing是一种允许一对对象的特定属性改变时另一个对象被通知的机制。</p>

<h3>为什么要用Key-Value Observing？</h3>

<p>KVO的主要好处是你不需要实现一套属性每次改变发送通知的机制。</p>

<h3>如何使用Key-Value Observing?</h3>

<ol>
<li>Registering as an Observer;</li>
<li>Receiving Notification of a Change;</li>
<li>Removing an Object as an Observer.</li>
</ol>


<p>同样，自定义的类如何才能让其他的开发者能使用KVO呢？我们要做的是符合KVO标准。</p>

<h4>KVO Compliance</h4>

<ul>
<li>The class must be <strong>key-value coding compliant</strong> for the property, as specified in <strong>Ensuring KVC Compliance</strong> in <strong>Key-Value Coding Programming Guide</strong>.</li>
<li>The class emits KVO change notifications for the property.</li>
<li>Dependent keys are registered appropriately (see <strong>Registering Dependent Keys</strong>).</li>
</ul>


<hr />

<p>There are two techniques for ensuring the change notifications are emitted. Automatic support is provided by NSObject and is by default available for all properties of a class that are key-value coding compliant. Typically, if you follow standard Cocoa coding and naming conventions, you can use automatic change notifications—you don’t have to write any additional code.</p>

<p>Manual change notification provides additional control over when notifications are emitted, and requires additional coding. You can control automatic notifications for properties of your subclass by implementing the class method automaticallyNotifiesObserversForKey:.</p>

<hr />

<h4>One more thing</h4>

<p>Key-Value Observing Implementation Details</p>

<p>Automatic key-value observing is implemented using a technique called <strong>isa-swizzling</strong>.</p>

<p>The <strong>isa</strong> pointer, as the name suggests, points to the object&rsquo;s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>

<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>

<p>You should never rely on the <strong>isa</strong> pointer to determine class membership. Instead, you should use the <strong>class</strong> method to determine the class of an object instance.</p>

<p>So how does <strong>class</strong> method determine the class of an object?</p>

<h1>Reference</h1>

<p>Key-Value Coding Programming Guide <br/>
Key-Value Observing Programming Guide</p>
]]></content>
  </entry>
  
</feed>
