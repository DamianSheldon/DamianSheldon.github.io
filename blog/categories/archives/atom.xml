<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2022-04-12T09:42:06+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Top Spring Framework Interview Questions(翻译)]]></title>
    <link href="http://DamianSheldon.github.io/blog/top-spring-framework-interview-questions.html"/>
    <updated>2022-04-11T10:07:29+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/top-spring-framework-interview-questions</id>
    <content type="html"><![CDATA[<h1>1.概述</h1>

<p>在本教程中，我们将看看在求职面试中可能出现的一些最常见的与 Spring 有关的问题。</p>

<h1>2. Spring Core</h1>

<h2>Q1. 什么是 Spring 框架？</h2>

<p>Spring是开发 Java 企业版应用程序最广泛使用的框架。此外，Spring 的核心功能可用于开发任何 Java 应用程序。</p>

<p>我们使用它的扩展功能在 Jakarta EE 平台之上构建各种网络应用。我们也可以在简单的独立应用程序中使用它的依赖注入条款。</p>

<h2>Q2. 使用 Spring 的好处是什么？</h2>

<p>Spring 的目标是使 Jakarta EE的 开发更容易，所以我们来看看它的好处:</p>

<ul>
<li><strong>轻量级</strong>&ndash;在开发中使用该框架的开销很小</li>
<li><strong>反转控制（IoC）</strong>&ndash;Spring 容器负责连接各种对象的依赖关系，而不是创建或寻找依赖对象</li>
<li><strong>面向方面的编程（AOP）</strong>&ndash;Spring支持AOP，将业务逻辑与系统服务分开</li>
<li><strong>IoC容器</strong>&ndash;管理 Spring Bean 的生命周期和项目特定的配置</li>
<li><strong>MVC框架</strong>&ndash;用于创建 Web 应用程序或 RESTful Web服务，能够返回XML/JSON响应</li>
<li><strong>事务管理</strong> &ndash; 通过使用 Java 注解或 Spring Bean 的 XML 配置文件，减少JDBC操作、文件上传等方面的模板代码量</li>
<li><strong>异常处理</strong>&ndash;Spring 提供了一个方便的 API，用于将特定技术的异常转化为未检查的异常</li>
</ul>


<h2>Q3. 您知道哪些 Spring 子项目？简要描述一下吧。</h2>

<ul>
<li><strong>核心</strong>&ndash;提供框架基础部分的关键模块，如 IoC 或 DI</li>
<li><strong>JDBC</strong>&ndash;实现了一个 JDBC 抽象层，不需要为特定的供应商数据库进行 JDBC 编码</li>
<li><strong>ORM 集成</strong> &ndash; 为流行的对象关系映射 API 提供集成层，如 JPA、JDO 和 Hibernate</li>
<li><strong>Web</strong>&ndash;一个面向网络的集成模块，提供多部分文件上传、Servlet监听器和面向网络的应用程序上下文功能</li>
<li><strong>MVC 框架</strong>&ndash;一个实现模型-视图-控制器设计模式的 Web 模块</li>
<li><strong>AOP 模块</strong>&ndash;面向切面的编程实现，允许定义干净的方法拦截器和切点</li>
</ul>


<!--more-->


<h2>Q4. 什么是依赖性注入？</h2>

<p>依赖注入是控制反转（IoC）的一个方面，它是一个一般的概念，即我们不手动创建我们的对象，而是描述它们应该如何被创建。然后IoC容器将在需要时实例化所需的类。</p>

<p>更多细节，请看<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">这里</a>。</p>

<h2>Q5. 我们如何在 Spring 中注入 Bean？</h2>

<p>为了注入Spring Bean，有几个不同的选择。</p>

<ul>
<li>Setter 方法注入</li>
<li>构造器注入</li>
<li>字段注入</li>
</ul>


<p>配置可以使用XML文件或注解来完成。</p>

<p>更多细节，请查看<a href="https://www.baeldung.com/inversion-control-and-dependency-injection-in-spring">这篇文章</a>。</p>

<h2>Q6. 哪种方式是注入 Bean 的最佳方式，为什么？</h2>

<p>推荐的方法是对强制性的依赖使用构造函数参数，对选择性的依赖使用设置器。这是因为构造函数注入允许向不可变的字段注入值，使测试更容易。</p>

<h2>Q7. BeanFactory 和 ApplicationContext 之间的区别是什么？</h2>

<p>BeanFactory 代表一个提供和管理 Bean 实例的容器接口。默认的实现是在调用 <code>getBean()</code>时懒惰地将 Bean 实例化。</p>

<p>相比之下，ApplicationContext 代表一个容纳了应用程序中元数据和 bean 等所有信息、元数据和bean 的容器接口。它也扩展了 BeanFactory 接口，但默认实现是在应用程序启动时迫切地实例化 Bean。然而，这种行为可以为单个 Bean 重写。</p>

<p>关于所有的区别，请参考<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html">文档</a>。</p>

<p>译者点评：正如它们的名字一样，BeanFactory 是代表它是 Bean 工厂，它的主要功能是像工厂一样生产管理 Bean；ApplicationContext 则表示它是应用上下文，它是 BeanFactory 的子接口，扩展了很多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。</p>

<h2>Q8. 什么是 Spring Bean？</h2>

<p>Spring Bean 是由 Spring IoC 容器初始化的 Java 对象。</p>

<p>译者点评：个人觉得 Spring 官方文档的解释更好:</p>

<blockquote><p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans.</p></blockquote>

<p>在 Spring 中， 那些被 Spring IoC 容器管理并形成应用骨架的对象称为 beans。</p>

<h2>Q9. Spring 框架中默认的 Bean 作用域是什么？</h2>

<p>默认情况下，Spring Bean 被初始化为一个单例。</p>

<h2>Q10. 如何定义一个 Bean 的作用域？</h2>

<p>为了设置Spring Bean的作用域，我们可以使用 <code>@Scope</code> 注解或在 XML 配置文件中使用 <code>"scope"</code> 属性。请注意，有五个支持的作用域。</p>

<ul>
<li>Singleton</li>
<li>Prototype</li>
<li>Request</li>
<li>Session</li>
<li>Global-session</li>
</ul>


<p>关于差异，请看<a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch03s05.html">这里</a>。</p>

<h2>Q11. 单例 bean 是线程安全的吗？</h2>

<p>单例 Bean 不是线程安全的，因为线程安全是关于执行的，而单例是一种专注于创建的设计模式。线程安全只取决于Bean的实现本身。</p>

<h2>Q12. Spring Bean 的生命周期是怎样的？</h2>

<p>首先，Spring Bean 需要根据 Java 或 XML Bean 定义进行实例化。它可能还需要执行一些初始化，使其进入可用状态。之后，当不再需要该 Bean 时，它将被从IoC 容器中删除。</p>

<p>所有初始化方法的整个周期显示在图片中（<a href="http://www.dineshonjava.com/2012/07/bean-lifecycle-and-callbacks.html">来源</a>）。</p>

<p><img src="https://www.baeldung.com/wp-content/uploads/2017/06/Spring-Bean-Life-Cycle.jpg" alt="Spring Bean Life Cycle" /></p>

<h2>Q13. 什么是基于 Java 的 Spring 配置？</h2>

<p>它是一种以类型安全的方式配置基于 Spring 的应用程序的方法。它是基于 XML 的配置的替代品。</p>

<p>另外，要把一个项目从 XML 配置迁移到 Java 配置，请参考<a href="https://www.baeldung.com/spring-xml-vs-java-config">这篇文章</a>。</p>

<h2>Q14. 我们可以在一个项目中拥有多个 Spring 配置文件吗？</h2>

<p>是的，在大型项目中，建议拥有多个 Spring 配置以提高可维护性和模块化程度。</p>

<p>我们可以加载多个基于 Java 的配置文件:</p>

<pre><code>@Configuration
@Import({MainConfig.class, SchedulerConfig.class})
public class AppConfig {
</code></pre>

<p>或者我们可以加载一个XML文件，该文件将包含所有其他配置:</p>

<pre><code>ApplicationContext context = new ClassPathXmlApplicationContext("spring-all.xml");
</code></pre>

<p>在这个XML文件中，我们将有以下内容:</p>

<pre><code>&lt;import resource="main.xml"/&gt;
&lt;import resource="scheduler.xml"/&gt;
</code></pre>

<h2>Q15. 什么是 Spring Security？</h2>

<p>Spring Security 是 Spring 框架的一个独立模块，主要是在 Java 应用程序中提供认证和授权方法。它还负责处理大多数常见的安全漏洞，如CSRF攻击。</p>

<p>要在Web应用程序中使用Spring Security，我们可以通过简单的注解 @EnableWebSecurity 来开始。</p>

<p>欲了解更多信息，我们有一系列与<a href="https://www.baeldung.com/security-spring">安全</a>有关的文章。</p>

<h2>Q16. 什么是 Spring Boot？</h2>

<p>Spring Boot 是一个提供了一套预配置框架以减少模板配置的项目。这样，我们就可以用最少的代码来启动和运行一个 Spring 应用程序。</p>

<h2>Q17. 请说出 Spring 框架中使用的一些设计模式？</h2>

<ul>
<li><strong>单例模式</strong>&ndash;单例范围的 bean</li>
<li><strong>工厂模式</strong>&ndash; Bean 工厂类</li>
<li><strong>原型模式</strong>（Prototype Pattern）&ndash;原型作用域的 Bean。</li>
<li><strong>适配器模式</strong>&ndash;Spring Web和Spring MVC</li>
<li><strong>代理模式</strong>&ndash;支持Spring面向切面的编程</li>
<li><strong>模板方法模式</strong>&ndash;JdbcTemplate、HibernateTemplate等。</li>
<li><strong>前端控制器</strong>&ndash;Spring MVC DispatcherServlet</li>
<li><strong>数据访问对象</strong>&ndash;支持Spring DAO</li>
<li><strong>模型视图控制器</strong>&ndash;Spring MVC</li>
</ul>


<p>译者点评：可能按照创建型、结构型和行为模式从 GoF 23 个设计模式中匹配会容易记忆点：</p>

<ul>
<li><p><strong>创建型模式</strong></p>

<ul>
<li>生成器(Builder)</li>
<li>工厂(Factory)</li>
<li>原型(Prototype)</li>
<li>单例(Singleton)</li>
</ul>
</li>
<li><p><strong>结构型模式</strong></p>

<ul>
<li>适配器(Adatper)</li>
<li>组成(Composite)</li>
<li>外观(Facade)</li>
<li>代理(Proxy)</li>
</ul>
</li>
<li><p><strong>行为模式</strong></p>

<ul>
<li>职责链(Chain of responsibility)</li>
<li>迭代器(Iterator)</li>
<li>策略(Strategy)</li>
<li>模板(Template Method)</li>
</ul>
</li>
</ul>


<h2>Q18. 原型作用域是如何工作的？</h2>

<p>原型作用域意味着每次我们需要 Bean 的一个实例时，Spring都会创建一个新的实例并返回它。这与默认的单例作用域不同，在单例作用域中，每个 Spring IoC 容器只实例化一个对象实例。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS 8 迁移到 Rocky Linux 时遇到的问题]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-to-migrate-to-rocky-linux-from-centos-8.html"/>
    <updated>2022-03-08T11:25:32+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-to-migrate-to-rocky-linux-from-centos-8</id>
    <content type="html"><![CDATA[<p>虽然 Rocky Linux 专门写了一篇文档介绍如何从 CentOS 8 迁移过来，但实际迁移还是遇到了问题，这里简单记一下。</p>

<pre><code>Error: 
 Problem 1: cannot install both ibus-libs-1.5.19-14.el8_5.x86_64 and ibus-libs-1.5.19-12.el8.x86_64
  - package ibus-devel-1.5.19-12.el8.x86_64 requires ibus-libs(x86-64) = 1.5.19-12.el8, but none of the providers can be installed
  - cannot install the best update candidate for package ibus-libs-1.5.19-12.el8.x86_64
  - problem with installed package ibus-devel-1.5.19-12.el8.x86_64
 Problem 2: cannot install both marisa-0.2.4-36.el8.x86_64 and marisa-0.2.4-4.el7.x86_64
  - package marisa-devel-0.2.4-4.el7.x86_64 requires marisa(x86-64) = 0.2.4-4.el7, but none of the providers can be installed
  - cannot install the best update candidate for package marisa-0.2.4-4.el7.x86_64
  - problem with installed package marisa-devel-0.2.4-4.el7.x86_64
(try to add '--allowerasing' to command line to replace conflicting packages or '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages)
</code></pre>

<p>第一个问题是升级 <code>ibus-devel</code> 失败，这是因为 <code>ibus-devel</code> 在 PowerTools 的仓库中，默认可能没有使能这个仓库，我们可以手动使能安装或升级：<code>sudo dnf --enablerepo=powertools install ibus-devel</code>。</p>

<p>第二个问题是 CentOS 8 上有最新的 <code>marisa-0.2.4-36.el8.x86_64</code>，但是只有<code>marisa-devel-0.2.4-4.el7.x86_64</code>, 这个有点奇怪，不知道为什么两个版本没有同步升级，<code>marisa-devel</code> 一般是用于开发，我们可能暂时用不到，可以先尝试卸载它完成升级：<code>sudo dnf remove marisa-devel</code>。</p>

<pre><code>Syncing packages

Last metadata expiration check: 0:00:13 ago on Tue Mar  8 12:23:04 2022.

Error: 
 Problem: package kyotocabinet-1.2.77-1.el7.x86_64 requires kyotocabinet-libs(x86-64) = 1.2.77-1.el7, but none of the providers can be installed
  - kyotocabinet-libs-1.2.77-1.el7.x86_64 does not belong to a distupgrade repository
  - problem with installed package kyotocabinet-1.2.77-1.el7.x86_64
(try to add '--skip-broken' to skip uninstallable packages or '--nobest' to use not only best candidate packages)

Error during distro-sync.

An error occurred while we were attempting to convert your system to Rocky Linux. Your system may be unstable. Script will now exit to prevent possible damage.
</code></pre>

<p>第三个问题是 kyotocabinet 的版本问题导致 <code>distro-sync</code> 失败。我查询了一下系统中安装的 kyotocabinet 版本又确实是 <code>1.2.77-1.el7</code>，也可以查询到迁移成功了：</p>

<pre><code>$ hostnamectl 
   Static hostname: centos.tenneshop.com
         Icon name: computer-vm
           Chassis: vm
        Machine ID: 2af6da6bd3624e0988bd30e22574b645
           Boot ID: 6edac64aba294e1e9f3b7cfdb7b6970c
    Virtualization: oracle
  Operating System: Rocky Linux 8.5 (Green Obsidian)
       CPE OS Name: cpe:/o:rocky:rocky:8:GA
            Kernel: Linux 4.18.0-240.15.1.el8_3.x86_64
      Architecture: x86-64
</code></pre>

<p>通过 <code>Syncing packages</code> 搜索 migrate2rocky 脚本，这已经是最后三步了，于是尝试手动完成剩下的工作。  先 <code>dnf --allowerasing distro-sync</code>，然后查看会删除哪些软件，我这里是会删除 kyotocabinet，根据情况确认是否接受删除软件同步。</p>

<p>最后的 Disable Stream repos 和移除 <code>subscription-manage</code>，因为是 CentOS 8, 所以并不需要。</p>

<p>重启之后又遇到新的问题：</p>

<pre><code>vboxclient the virtualbox kernel service is not running. exiting
</code></pre>

<p>查看 <code>/var/log/vboxadd-setup.log</code>，</p>

<pre><code>/tmp/vbox.0/r0drv/linux/alloc-r0drv-linux.c:204:14: error: implicit declaration of function ‘map_vm_area’; did you mean ‘get_vm_area’? [-Werror=implicit-function-declaration]
         if (!map_vm_area(pVmArea, PAGE_KERNEL_EXEC,
              ^~~~~~~~~~~
              get_vm_area
cc1: some warnings being treated as errors
make[2]: *** [scripts/Makefile.build:316: /tmp/vbox.0/combined-os-specific.o] Error 1
make[1]: *** [Makefile:1571: _module_/tmp/vbox.0] Error 2
make: *** [/tmp/vbox.0/Makefile-footer.gmk:117: vboxguest] Error 2
</code></pre>

<p>经过一番搜索，我意识到可能是 <code>VBoxGuestAdditions.iso</code> 的版本不对，因为之前确实有提示类似 <code>unable to insert the virtual optical disk /usr/share/virtualbox/vboxguestadditions.iso</code> 的错误，原因是我没有把之前版本的 <code>VBoxGuestAdditions.iso</code> 从虚拟光驱中弹出，于是先弹出再插入新版本，果然新版本成功安装。</p>

<h2>Reference:</h2>

<ul>
<li><a href="https://docs.rockylinux.org/guides/migrate2rocky/">How to Migrate to Rocky Linux from CentOS Stream, CentOS, Alma Linux, RHEL, or Oracle Linux</a></li>
<li><a href="https://access.redhat.com/discussions/4452161">vboxclient the virtualbox kernel service is not running. exiting</a></li>
<li><a href="https://forums.virtualbox.org/viewtopic.php?t=103528">CentOS 8 Stream - vboxdrv wont build</a></li>
<li><a href="https://forums.virtualbox.org/viewtopic.php?t=82201">Cannot install Guest Addtions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox 搭建 CentOS 7 集群]]></title>
    <link href="http://DamianSheldon.github.io/blog/cluster-virtualbox-centos-7.html"/>
    <updated>2021-10-21T15:57:18+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/cluster-virtualbox-centos-7</id>
    <content type="html"><![CDATA[<p>软件开发时我们可能需要集群环境，特别是现在微服务很流行的情况下。如果我们手里的电脑配置不错就可以用 来搭建集群，用于学习或开发还是很不错，性价比很高。</p>

<p>我这里是用 VirtualBox 搭建 CentOS 7 集群，宿主机是内存 16 GB 加 SSD 1 TB 的 MacBook Pro。集群的核心是选择网络模式，VirtualBox 的网络模式概况如下:</p>

<table>
<thead>
<tr>
<th> Mode </th>
<th> VM -> Host </th>
<th> VM &lt;- Host </th>
<th> VM1 <-> VM2 </th>
<th> VM -> Net/LAN </th>
<th> VM &lt;- Net/LAN </th>
</tr>
</thead>
<tbody>
<tr>
<td> Host-only </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> - </td>
<td> - </td>
</tr>
<tr>
<td> Internal </td>
<td> - </td>
<td> - </td>
<td> + </td>
<td> - </td>
<td> - </td>
</tr>
<tr>
<td> Bridged </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> + </td>
</tr>
<tr>
<td> NAT </td>
<td> + </td>
<td> Port forward </td>
<td> - </td>
<td> + </td>
<td> Port forward </td>
</tr>
<tr>
<td> NAT service </td>
<td> + </td>
<td> Port forward </td>
<td> + </td>
<td> + </td>
<td> Port forward </td>
</tr>
</tbody>
</table>


<p>我希望集群的机器可以互相访问并能访问网络，从上面的列表可知，我们可以选择 Bridged，或者 NAT service 搭配 Port forward。在搭建之初，我搜索了相关的资料，但是并没找到特别理想的，这篇 <a href="https://subscription.packtpub.com/book/web-development/9781785288685/1/ch01lvl1sec09/setting-up-centos-7-nodes">Setting up CentOS 7 nodes</a> 勉强还凑合，于是我主要参考它来搭建，网络模式也同样是选择的 Bridged，它还使用了双网卡，虚拟机之间通信使用的 Internal Networking， 感觉上性能可能会好点，没实测。双网卡并不是必须的，VirtualBox 对 Internal Networking 的说明是其在安全方面更有优势:</p>

<blockquote><p>Even though technically, everything that can be done using internal networking can also be done using bridged networking, there are security advantages with internal networking. In bridged networking mode, all traffic goes through a physical interface of the host system. It is therefore possible to attach a packet sniffer such as Wireshark to the host interface and log all traffic that goes over it. If, for any reason, you prefer two or more VMs on the same machine to communicate privately, hiding their data from both the host system and the user, bridged networking therefore is not an option.</p></blockquote>

<p>由于 CentOS 主要是运行服务，我们可以使用 Minimal 安装，这样可以减少资源开销，安装好后，默认是没有启用网络的， 网络相关的配置是在 <code>/etc/sysconfig/network-scripts</code> 目录下，配置文件的命令惯例是 <code>ifcfg-enp0sX</code> ， <code>X</code> 是整数，我这里是 <code>ifcfg-enp0s3</code> 和 <code>ifcfg-enp0s8</code>，将 <code>/etc/sysconfig/network-scripts/ifcfg-enp0s3</code> 和 <code>/etc/sysconfig/network-scripts/ifcfg-enp0s8</code> 中的 <code>ONBOOT</code> 改成 <code>yes</code>。</p>

<p>构建 Internal Network 时，手动去指定 ip 会很麻烦，VirtualBox 给了我们另一个选择:</p>

<blockquote><p>Unless you configure the virtual network cards in the guest operating systems that are partici- pating in the internal network to use static IP addresses, you may want to use the DHCP server that is built into Oracle VM VirtualBox to manage IP addresses for the internal network.</p></blockquote>

<p>我们可以 <code>10.0.0.0/8</code>, <code>172.16.0.0/12</code> 和 <code>192.168.0.0/16</code> 选择一个合适的私有 ip 地址范围来构建 Internal Network，我这里选择 <code>172.16.0.0/12</code>。</p>

<p>在宿主机下运行命令 <code>/Applications/VirtualBox.app/Contents/MacOS/VBoxManage dhcpserver add --netname=intnet --server-ip=172.16.0.1 --netmask=255.240.0.0 --lower-ip=172.16.0.2 --upper-ip=172.16.255.255 --enable</code> 创建好 DHCP server。</p>

<p>之后我们可以利用 VirtualBox 的克隆功能来扩展我们的集群节点。</p>

<h1>修改记录</h1>

<ul>
<li>2021/10/21：第一次完成</li>
</ul>


<h1>Reference</h1>

<ul>
<li><a href="https://subscription.packtpub.com/book/web-development/9781785288685/1/ch01lvl1sec09/setting-up-centos-7-nodes">Setting up CentOS 7 nodes</a></li>
<li><a href="https://54m4ri74n.medium.com/building-an-internal-network-in-virtualbox-d0a4974882d0">Building an Internal Network in VirtualBox</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次 docker 网络问题排查]]></title>
    <link href="http://DamianSheldon.github.io/blog/remembering-a-docker-network-issue-troubleshooting.html"/>
    <updated>2021-03-30T14:40:26+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/remembering-a-docker-network-issue-troubleshooting</id>
    <content type="html"><![CDATA[<p>最近在学 docker，虽然很早之前就简单体验过一次，但限于时间没有深入，最近有点空余时间，于是准备深入学习一下。但没想到一开始就遇到了拦路虎，照着官方文档 Get Started 一步一步往下，在构建一个自己的镜像时就遇到了问题，在多容器之间也无法通信，这可愁坏我了，只能硬着头皮来排查问题。</p>

<p>构建镜像时问题表现是牵涉到连接网络的命令会失败，google 一圈之后，找到使用 <code>--network=host</code> 的偏方，成功绕过问题。而多容器之间无法通信却一时措手无策。现在就只有 <code>--network=host</code> 这一个线索，于是就想加上这个参数后有什么区别呢？</p>

<p>在官方文档上搜寻一圈之后我没查到有用信息，于是我想相关的书可能会讲讲 docker 网络这块，在微信读书上找了杨保华、戴王剑和曹亚仑合著的《Docker 技术入门与实战(第3版)》。因为 docker 技术在快速发展，所以书中的命令与当前版本有些许差异，但问题不大，不妨碍理解。这本书有两节专门介绍 docker 网络，于是我便先看了这两节，从这里得到一条重要线索：docker 和宿主机的通信是依靠防火墙转发。<code>--network=host</code> 也验证了这条线索，加上这参数会直接使用宿主机的网络配置，这样 docker 和宿主机的通信就不需要防火墙转发了。</p>

<p>问题现在定位到了防火墙，那么为什么防火墙不转发 docker 的网络数据包呢？是不是哪条防火墙规则没配对？另外我还怀疑是不是我的实践环境有问题？我的实践环境是这样的:物理主机是 macOS，上面安装 virtulbox，使用 virtulbox 创建了一个 CentOS 8 的虚拟机, 虚拟机的网络模式是 NAT。这种情况无疑增加了问题排查的难度，怎么来排查呢？</p>

<p>我先看了一下 virtulbox 的用户手册中的网络模式介绍，NAT 是可以连接到宿主机，而且现在虚拟机是可以访问网络的。如果想快速定位问题，我想还得从网络请求的数据包入手，想办法来跟踪数据包。</p>

<p>于是就来查怎么调试 iptables。查到可以通过 TRACE 和 LOG 来输出日志，看介绍也没看出这俩有什么区别。凭经验觉得 TRACE 好像比 LOG 后出来，看起来也高大上一点，先试着用 TRACE 。Google 了一圈，找到都是 CentOS 6 或 CentOS 7 相关的配置，也只能先将就着用吧。</p>

<p>我先是参考的 <a href="https://www.programmersought.com/article/68601428960/">CentOS implements iptables log output and debugging through raw table</a></p>

<pre><code>$sudo modprobe ipt_LOG
$sudo sysctl net.netfilter.nf_log.2
</code></pre>

<p>输出的结果是 NONE，于是尝试显示设置 <code>sudo sysctl net.netfilter.nf_log.2=ipt_LOG</code></p>

<!--more-->


<p>结果给我报一个 <code>sysctl: setting key "net.netfilter.nf_log.2": No such file or directory</code>, 为什么没有这个 key 呢？于是我查询一下:</p>

<pre><code>$ sudo sysctl -a | grep net.netfilter.nf_log
net.netfilter.nf_log.0 = NONE
net.netfilter.nf_log.1 = NONE
net.netfilter.nf_log.10 = NONE
net.netfilter.nf_log.11 = NONE
net.netfilter.nf_log.12 = NONE
net.netfilter.nf_log.2 = NONE
net.netfilter.nf_log.3 = NONE
net.netfilter.nf_log.4 = NONE
net.netfilter.nf_log.5 = NONE
net.netfilter.nf_log.6 = NONE
net.netfilter.nf_log.7 = NONE
net.netfilter.nf_log.8 = NONE
net.netfilter.nf_log.9 = NONE
net.netfilter.nf_log_all_netns = 0
</code></pre>

<p>明明有这个 key 啊, Google 一圈不得要领。继续搜索, 找到这篇 <a href="https://vocon-it.com/2020/03/30/tracing-iptables-on-centos-cheat-sheet/">Tracing iptables on CentOS – Cheat sheet</a>, 它提到的方法如下:</p>

<pre><code>modprobe nf_log_ipv4
sudo sysctl net.netfilter.nf_log.2=nf_log_ipv4
</code></pre>

<p>因为我对 linux 模块相关命令还是有点了解，知道 <code>modprobe</code> 是用来加载模块， <code>modinfo</code> 可以查看模块的信息,我发现 <code>nf_log_ipv4</code> 这个模块在我的系统中已经加载，所以我就直接尝试 <code>sudo sysctl net.netfilter.nf_log.2=nf_log_ipv4</code>, 得到的仍然是 <code>sysctl: setting key "net.netfilter.nf_log.2": No such file or directory</code>，不得不说这很迷，为什么会一直报这么一个不相关的错误。</p>

<p>没办法，继续搜索, 找到 <a href="https://forums.centos.org/viewtopic.php?t=54411">IPTables. Setting nf_log kernel parameter</a>,它其中提到：</p>

<blockquote><p>I think they split the xt_LOG code in newer kernel versions and you need to modprobe nf_log_ipv4 now and sysctl net.netfilter.nf_log.2=nf_log_ipv4 (assuming you want to trace ipv4 packets)</p></blockquote>

<p>很奇怪，为什么其他人都可以设置，我这里却不行，而且这三篇文章用的方法都类似，不至于啊，google 到的也就这几篇文章，于是我回过头去再次研读第一篇文章，在想要不要试下作者提供 CentOS 7 系列的配置方法，毕竟版本更接近，而且这三篇文章都提到用 <code>nf_log_ipv4</code>, 这时我发现他的方法里 <code>modprobe nf_log_ipv4</code> 之后并不需要设置， <code>net.netfilter.nf_log.2</code> 的值便设置了,于是我也照做，终于配置成功。我觉得这里可能是 CentOS 8 有 bug，因为明明有 key 却设置不上，现在设置成功，也就不管那么多了，继续解决问题要紧。</p>

<p>我到 <code>/etc/rsyslog.conf</code> 中开启内核日志输出：</p>

<pre><code>kern.*                                                 /var/log/messages
</code></pre>

<p>重启日志输出服务 <code>sudo systemctl restart rsyslog.service</code>,往防火墙里添加 TRACE 规则:</p>

<pre><code>sudo iptables -t raw -A OUTPUT     -p tcp -j TRACE
sudo iptables -t raw -A PREROUTING -p tcp -j TRACE
</code></pre>

<p>监视系统日志 <code>sudo tail -f /var/log/messages</code></p>

<p>重启 docker 服务 <code>sudo systemctl restart docker.service</code>, 运行容器 <code>sudo docker run -it busybox</code>, 然后在 busybox 容器中触发网络请求:</p>

<pre><code>cd /tmp/
wget http://www.bing.com/
</code></pre>

<p>系统日志并没有输出， 查看 <code>sudo dmesg</code> 也没有日志输出。真是让挫败啊，没办法，只能退而求其次改用 LOG。</p>

<pre><code># 删除 TRACE 规则
sudo iptable -t raw -D PREROUTING 1
sudo iptable -t raw -D OUTPUT 1

## 添加 LOG 规则
sudo iptables -t raw -A OUTPUT     -p tcp -j LOG --log-level debug
sudo iptables -t raw -A PREROUTING     -p tcp -j LOG --log-level debug
</code></pre>

<p>同样重启日志服务 <code>sudo systemctl restart rsyslog.service</code>, 监视系统日志 <code>sudo tail -f /var/log/messages</code>，重启 docker 服务 <code>sudo systemctl restart docker.service</code>, 运行容器 <code>sudo docker run -it busybox</code>, 然后在 busybox 容器中触发网络请求:</p>

<pre><code>cd /tmp/
wget http://www.bing.com/
</code></pre>

<p>日志是成功输出了，内心着实高兴了一把，但由于我的规则设置太宽泛，输出的太多了，很难找到有用的信息，脑中闪过一个念头，那把规则设置更严格一点不就可以了，搓搓小手，兴奋地实践起来，于是我把规则调整成容器发出的网络数据包：</p>

<pre><code>sudo iptables -t raw -A OUTPUT     -p tcp -s 172.17.0.0/16 -j LOG --log-level debug
sudo iptables -t raw -A PREROUTING     -p tcp -s 172.17.0.0/16 -j LOG --log-level debug
</code></pre>

<p>果然，相关日志输出少多了，只有两条,具体如下:</p>

<pre><code>Mar 29 15:51:46 centos kernel: IN=docker0 OUT= PHYSIN=vethfeab609 MAC=02:42:5d:dd:2d:af:02:42:ac:11:00:02:08:00 SRC=172.17.0.2 DST=222.246.1
29.80 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=30005 DF PROTO=TCP SPT=60366 DPT=80 WINDOW=29200 RES=0x00 SYN URGP=0 
Mar 29 15:51:47 centos kernel: IN=docker0 OUT= PHYSIN=vethfeab609 MAC=02:42:5d:dd:2d:af:02:42:ac:11:00:02:08:00 SRC=172.17.0.2 DST=222.246.1
29.80 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=30006 DF PROTO=TCP SPT=60366 DPT=80 WINDOW=29200 RES=0x00 SYN URGP=0 
</code></pre>

<p>这对解决问题帮助不大，摔！这几乎要击垮我了，但还是心有不甘。于是只能把希望再次寄托给 TRACE，我在 CentOS 8 上直接 <code>man iptables</code>，发现它和网络上找到的 man page 内容确实有些差异, 它的 target 专门独立到 <code>iptables-extensions</code>:</p>

<blockquote><p>iptables  can  use  extended packet matching and target modules.  A list of these is available in the iptables-extensions(8) man‐page.</p></blockquote>

<p>继续 <code>man 8 iptables-extensions</code>，搜索 TRACE, 相关介绍如下:</p>

<blockquote><p>This  target  marks  packets so that the kernel will log every rule which match the packets as those traverse the tables, chains,rules. It can only be used in the raw table.</p>

<p>With iptables-legacy, a logging backend, such as ip(6)t_LOG or nfnetlink_log, must be loaded for this to be visible.  The packets are  logged  with the string prefix: &ldquo;TRACE: tablename:chainname:type:rulenum &rdquo; where type can be &ldquo;rule&rdquo; for plain rule, &ldquo;return&rdquo; for implicit rule at the end of a user defined chain and &ldquo;policy&rdquo; for the policy of the built in chains.</p>

<p>With iptables-nft, the target is translated into nftables' meta nftrace expression. Hence  the  kernel  sends  trace  events  via netlink to userspace where they may be displayed using xtables-monitor &ndash;trace command. For details, refer to xtables-monitor(8).</p></blockquote>

<p>原来配合 <code>iptables-nft</code> 时, 日志是使用  <code>xtables-monitor --trace</code>, 似乎又看到了一丝曙光,于是赶紧删除 LOG 规则，添加 TRACE 规则:</p>

<pre><code># 删除 LOG 规则
sudo iptable -t raw -D PREROUTING 1
sudo iptable -t raw -D OUTPUT 1

# 添加 TRACE 规则
sudo iptables -t raw -A OUTPUT     -p tcp -j TRACE
sudo iptables -t raw -A PREROUTING -p tcp -j TRACE
</code></pre>

<p>准备就绪之后就按前面相关的步骤触发网络请求，果然成功输出日志，而且输出了很多日志，我往屏幕下面翻，最后竟然输出的 &ldquo;Failed to received netlink message: No buffer space available&rdquo;,为什么报错了呢？我尝试 <code>man xtables-monitor</code>,文档上明明说的是： xtables-monitor will run until the user aborts execution, typically by using CTRL-C.我这里为什么报错终止了呢？Google 一圈一无所获，想到之前 LOG 因为规则太宽松输出了很多日志，就想是不是这规则太宽松导致日志太多，缓冲区不够用，赶紧调整 TRACE 规则:</p>

<pre><code># 删除 TRACE 规则
sudo iptable -t raw -D PREROUTING 1
sudo iptable -t raw -D OUTPUT 1

# 添加 TRACE 规则
sudo iptables -t raw -A OUTPUT     -p tcp -s 172.17.0.0/16  -j TRACE
sudo iptables -t raw -A PREROUTING -p tcp -s 172.17.0.0/16 -j TRACE
</code></pre>

<p>这下好了，日志正常输出，也没有报错了。于是仔细查看日志，终于找到： <code>firewalld:filter_FORWARD:rule:0x93:DROP</code>,原来是 firewall 将包丢掉了。可是对 firewall 一点也不熟，先找了一遍 firewall 教程看了一下，但是还不知道怎么在 firewall 中添加规则，要学会添加规则也得花点力气，这时脑海中冒出另一个想法：我何不直接停止 firewall，确认下是不是 firewall 导致的问题。</p>

<pre><code>sudo systemctl stop firewalld.service
sudo systemctl stop docker.service
sudo systemctl start docker.service
sudo docker run -it busybox
</code></pre>

<p>尝试一下,发现可以了，确定确实是 firewall 导致的问题。那么现在是自己研究 firewall 添加规则吗？有点复杂啊，我在想是不是我 docker 版本太低了，检查一下确实比最新的版本要低，新版本可能解决了。在文档也确实找到了对应描述:</p>

<blockquote><p>If you are running Docker version 20.10.0 or higher with firewalld on your system with &ndash;iptables enabled, Docker automatically creates a firewalld zone called docker and inserts all the network interfaces it creates (for example, docker0) into the docker zone to allow seamless networking.</p></blockquote>

<p>于是升级新版本，新版本也确实解决了这个问题，嗯，这下暂时不用研究 firewall 添加规则了。</p>

<p>这次能成功排查 docker 的网络问题还是挺开心的，说实话一开始我是没信心的，毕竟才开始接触 docker，另一方面 linux 网络这块牵涉到的知识非常多，甚至在心里想实在解决不了就算了,直接在 macOS 上来学好了。得到的启发是不管有没有解决问题，首先解决问题的方法要对，方法对了之后还得要坚持；其次是注意自己软件使用的版本，相关的命令参数可能需要查看对应版本的文档去核实；最后是虽然项目的官方文档是入门的不错材料，但很多时候官方文档写得很浅或者对新手不友好，这时候如果觉得项目值得投入时间学习的话，看相关的书籍是一个很好的选择，对系统学习和精进大有禆益。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://www.programmersought.com/article/68601428960/">CentOS implements iptables log output and debugging through raw table</a></li>
<li><a href="https://vocon-it.com/2020/03/30/tracing-iptables-on-centos-cheat-sheet/">Tracing iptables on CentOS – Cheat sheet</a></li>
<li><a href="https://forums.centos.org/viewtopic.php?t=54411">IPTables. Setting nf_log kernel parameter</a></li>
<li><a href="https://stackoverflow.com/questions/37536687/what-is-the-relation-between-docker0-and-eth0">What is the relation between docker0 and eth0?</a></li>
<li><a href="https://serverfault.com/questions/78240/debugging-rules-in-iptables">Debugging rules in Iptables</a></li>
<li><a href="https://unix.stackexchange.com/questions/199966/how-to-configure-centos-7-firewalld-to-allow-docker-containers-free-access-to-th">How to configure Centos 7 firewallD to allow docker containers free access to the host&rsquo;s network ports?</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-using-firewalld-on-centos-8">How To Set Up a Firewall Using firewalld on CentOS 8</a></li>
<li><a href="https://firewalld.org/documentation/howto/enable-and-disable-firewalld.html">Enable and Disable firewalld</a></li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UI 设计与屏幕适配]]></title>
    <link href="http://DamianSheldon.github.io/blog/ui-design-and-screen-adaptation.html"/>
    <updated>2021-03-17T15:12:26+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ui-design-and-screen-adaptation</id>
    <content type="html"><![CDATA[<p>目前移动设备的尺寸很多，所以前端 (iOS, Android, Web, 小程序等)开发需要适配多种尺寸屏幕。在适配时我们可能会有困惑，设计稿通常是 px 来表示尺寸，设备的分辨率也是以 px 来表示，它们之间是一样的吗？还是存在什么关系？iOS 开发者用 point 来表示视图的尺寸； Android 开发者用 dp 来表示视图尺寸； Web 开发者用 px 来表示尺寸？它们和设计稿的 px 是什么关系？设计师应该以什么基准尺寸来设计会有利于屏幕适配？应该输出几套切图？除了切图，设计师还可以做些什么来配合开发者做屏幕适配？要搞清楚这些问题，我们需要翻翻历史了。</p>

<p>Tim Chien 和 Robert Nyman 的这篇 <a href="https://hacks.mozilla.org/2013/09/css-length-explained/">CSS Length Explained</a> 帮了我的大忙，本文就是基于它而写成。</p>

<h2>英寸</h2>

<p>我们经常是用英寸为度量单位来表示手机屏幕尺寸，一英寸相当于2.54厘米或0.0254米。</p>

<h2>设备像素(device pixel)</h2>

<p>计算机屏幕显示事物的单位是像素。显示屏上的单个物理 &ldquo;光点"，能够独立于它的邻居显示出完整的颜色，被称为像素（图片元素）。我们把屏幕上的物理像素称为 "设备像素"。</p>

<h2>DPI, PPI</h2>

<p>DPI 是 dots per inch 的英文缩写，即每英寸点数； PPI 是 pixels per inch 的缩写，即每英寸像素。 它们都用来表示显示像素密度 (Display pixel density)。</p>

<p>计算机屏幕是由大量发光二极管整齐排列构成的集成电路，由于屏幕制造商工艺水平差异，每英寸集成电路上排列的二极管的数量会不一样，屏幕出厂时我们可以从厂商那里得知屏幕的 PPI。</p>

<p>于是我们可以知道:</p>

<pre><code>width or height of one device pixel = 1 / device's DPI  
</code></pre>

<p>例如 MacBook Air(2011) 的 DPI 为 125 ， 所以：</p>

<pre><code>(width or height of one device pixel) = 1/125 inch = 0.008 inch = 0.02032 cm
</code></pre>

<!--more-->


<h2>The CSS pixel (px)</h2>

<p>CSS像素的尺寸大致可以看成是人的肉眼能够舒适地看到的尺寸，不要太小，这样你就得眯着眼睛，也不要大到让你看到像素化。"看得很舒服 &ldquo; 的定义比较笼统，<a href="http://www.w3.org/TR/CSS2/syndata.html%23length-units">W3C CSS规范</a>中给我们一个推荐的参考。</p>

<blockquote><p>The reference pixel is the visual angle of one pixel on a device with a pixel density of 96 DPI and a distance from the reader of an arm’s length.</p></blockquote>

<h2>The viewing distance</h2>

<p>如前所述，观看距离因人而异，因设备而异，这就是为什么我们必须将设备按外形因素分类的原因。推荐的参考观看距离(&ldquo;一臂之长&rdquo;)和参考像素密度(&ldquo;96 DPI&rdquo;)其实是历史数据。</p>

<p>对于21世纪的日常设备，我们有不同的参考建议:</p>

<table>
<thead>
<tr>
<th> Device </th>
<th> Baseline pixel density </th>
<th> Width/height of one CSS pixel </th>
<th> Viewing distance</th>
</tr>
</thead>
<tbody>
<tr>
<td> A 20th century PC with CRT display </td>
<td> 96 DPI </td>
<td> ~0.2646 mm (1/96in) </td>
<td> 28 in (71.12cm) </td>
</tr>
<tr>
<td> Modern laptop with LCD </td>
<td> 125 DPI </td>
<td> 0.2032 mm (1/125in) </td>
<td> 21.5 in (54.61cm)</td>
</tr>
<tr>
<td> Smartphones/Tablets </td>
<td> 160 DPI </td>
<td> ~0.159mm (1/160 in) </td>
<td> 16.8in (42.672cm) </td>
</tr>
</tbody>
</table>


<p>因此，我们在 CSS 的世界里建立了一个基本的事实：一个 CSS 像素会以不同的物理尺寸显示，但它总是以正确的尺寸显示，让浏览者感到舒适。</p>

<h2>Device pixel ratio (DPPX)</h2>

<p>随着我们步入未来，现在很多智能手机在出厂时都采用了高密度的显示屏。为了保证 CSS 像素在每一个访问网络的设备(即一切有屏幕和网络连接的设备)上的尺寸一致，设备制造商不得不将多个设备像素映射到一个 CSS 像素上，以弥补它相对更大的物理尺寸。CSS 像素相对于设备像素的尺寸比就是设备像素比(DPPX)。</p>

<p>我们以 iPhone 4 为最著名的例子。它配备了一块 326 DPI 的显示屏。根据我们上面的表格，作为一款智能手机，它的典型观看距离是 16.8 英寸，它的基准像素密度是 160DPI。为了创建一个 CSS 像素，苹果选择将设备像素比设置为 2，这就等于让 iOS Safari 显示网页的方式和 163 DPI 手机上一样。</p>

<p>在我们继续之前，先回头看看上面的数字。其实我们可以做得更好，不把设备像素比设置为2，而是设置为<code>326/160=2.0375</code>，让一个 CSS 像素与参考尺寸相比完全一样。不幸的是，这样的比例会导致一个意想不到的结果：由于每个 CSS 像素并不是由整个设备像素来显示的，所以浏览器不得不对所有的位图图像、边框等进行反锯齿，因为它们几乎总是被当作整个 CSS 像素来显示。浏览器很难利用2.0375个设备像素来绘制你的1个CSS像素宽的边框：如果比例是简单的2，那就容易多了。</p>

<p>顺带一提，163 DPI恰好是上一代 iPhone 的像素密度，所以网页的工作方式也是一样的，不需要开发者对自己的网站进行任何特殊的"升级"。</p>

<p>设备制造商通常选择1.5，或2，或其他整数作为 DPPX 值。偶尔，有些设备决定不这么玩了，发货时使用1.325 DPPX这样的值；作为开发者，我们也许应该忽略这些设备。</p>

<p>现在我们就比较清楚 CSS pixel 和 device pixel 的关系了。接下来我们看下 iOS 的 point 和 device pixel 的关系。</p>

<h2>point</h2>

<blockquote><p>The coordinate system iOS uses to place content onscreen is based on measurements in points, which map to pixels in the display. A standard-resolution display has a <code>1:1</code> pixel density (or <code>@1x</code>), where one pixel is equal to one point. High-resolution displays have a higher pixel density, offering a scale factor of 2.0 or 3.0 (referred to as <code>@2x</code> and <code>@3x</code>). As a result, high-resolution displays demand images with more pixels.</p></blockquote>

<p>从 Apple 这段描述可知， scale factor (<code>@1x</code>, <code>@2x</code> 和 <code>@3x</code>) 就是我们上面据说的设备像素比（DPPX)。point 和 css pixel 是对应的。</p>

<h2>dp</h2>

<p>那 dp 和 device pixel 又是什么关系呢？</p>

<blockquote><p>To preserve the visible size of your UI on screens with different densities, you must design your UI using density-independent pixels (dp) as your unit of measurement. One dp is a virtual pixel unit that&rsquo;s roughly equal to one pixel on a medium-density screen (160dpi; the &ldquo;baseline&rdquo; density). Android translates this value to the appropriate number of real pixels for each other density.</p></blockquote>

<p>Google 这段描述更加直接，dp 是一个虚拟的像素单位，大致相当于中密度屏幕上的一个像素(160dpi;&ldquo;基线"密度)，所以 dp 和 css pixel 也是对应的。而 xhdpi, xxhdpi 和 xxxhdpi 是表示设备像素比(DPPX)2、3 和 4。</p>

<p>现在我们还剩下设计稿的 px。我们回忆一下在前端开发时，如果我们不指定图片尺寸而直接去显示设计师的切图，这时图片是有一个固有尺寸的，在设备像素比为1的设备上，这个固有尺寸就是图片的尺寸，而在设备像素比为2上尺寸是图片的尺寸除以2，所以设计稿的 px是对应设备像素(device pixel)的，这也是为什么我们需要提供多套图片来做适配。假设我们不提供多套图片，现在我们有一个 <code>100 x 100 css pixel</code>的图片， 在设备像素比为3的设备上也会去加载 <code>100 x 100 device pixel</code> 尺寸的资源图，按上面的分析，实际它应该加载 <code>300 x 300 device pixel</code> 尺寸的资源图，那么相当于资源图上一个像素点会对应显示三个设备像素点，这样可能会出现模糊或锯齿的情况。</p>

<p>理清了各平台尺寸单位的关系以及它们与设备像素的关系后，我们来看下设备尺寸。</p>

<h2>设备尺寸</h2>

<p>我们先看下 iOS 设备尺寸分布:</p>

<table>
<thead>
<tr>
<th> 型号 </th>
<th> points </th>
<th> 物理像素 </th>
<th style="text-align:center;"> 设备像素比(DPPX) </th>
</tr>
</thead>
<tbody>
<tr>
<td> 2G,3G,3GS </td>
<td> 320 x 480 </td>
<td> 320 x 480</td>
<td style="text-align:center;"> 1 </td>
</tr>
<tr>
<td> 4,4S </td>
<td> 320 x 480 </td>
<td> 640 x 960 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 5,5C,5S,SE </td>
<td> 320 x 568 </td>
<td> 640 x 1136 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 6,6S,7,8,SE2</td>
<td> 375 x 667 </td>
<td> 750 x 1334 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 6+,6S+,7+,8+ </td>
<td> 414 x 736 </td>
<td> 1080 x 1920 </td>
<td style="text-align:center;"> 3 </td>
</tr>
<tr>
<td> 11Pro,X,Xs </td>
<td> 375 x 812 </td>
<td> 1125 x 2436 </td>
<td style="text-align:center;"> 3 </td>
</tr>
<tr>
<td> 11, Xr </td>
<td> 414 x 896 </td>
<td> 828 x 1792 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 11Pro Max,Xs Max </td>
<td> 414 x 896 </td>
<td> 1242 x 2688 </td>
<td style="text-align:center;"> 3 </td>
</tr>
</tbody>
</table>


<p>对于 iOS 来说，现在的主流设备应该是从 <code>6,6S,7,8,SE2</code> 开始，对应的设备像素是<code>750 x 1334 px</code>。</p>

<p>再来看下 android 这边， Google 有一个 <a href="https://developer.android.com/about/dashboards/index.html#Screens">Screen sizes and densities</a> 统计表，本文写作时查询的结果如下:</p>

<table>
<thead>
<tr>
<th> </th>
<th> ldpi </th>
<th> mdpi </th>
<th> tvdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> Total </th>
</tr>
</thead>
<tbody>
<tr>
<td> Small </td>
<td> 0.1% </td>
<td>  </td>
<td>  </td>
<td> </td>
<td> 0.1% </td>
<td>  </td>
<td> 0.2% </td>
</tr>
<tr>
<td> Normal </td>
<td>  </td>
<td> 0.3% </td>
<td> 0.3% </td>
<td> 14.8% </td>
<td> 41.3% </td>
<td> 26.1% </td>
<td> 82.8% </td>
</tr>
<tr>
<td> Large </td>
<td>  </td>
<td> 1.7% </td>
<td> 2.2% </td>
<td> 0.8% </td>
<td> 3.2% </td>
<td> 2.0% </td>
<td> 9.9%  </td>
</tr>
<tr>
<td> Xlarge </td>
<td>  </td>
<td> 4.2% </td>
<td> 0.2% </td>
<td> 2.3% </td>
<td> 0.4% </td>
<td>  </td>
<td> 7.1% </td>
</tr>
<tr>
<td> Total </td>
<td> 0.1% </td>
<td> 6.2% </td>
<td> 2.7% </td>
<td>  17.9% </td>
<td> 45.0% </td>
<td> 28.1% </td>
<td>  </td>
</tr>
</tbody>
</table>


<p><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#ScreenSizeQualifier">Small,Normal,Large 和 Xlarge</a> 是屏幕的尺寸分类，具体含义如下:</p>

<blockquote><ul>
<li><p>small: Screens that are of similar size to a low-density QVGA screen. The minimum layout size for a small screen is approximately 320x426 dp units. Examples are QVGA low-density and VGA high density.</p></li>
<li><p>normal: Screens that are of similar size to a medium-density HVGA screen. The minimum layout size for a normal screen is approximately 320x470 dp units. Examples of such screens a WQVGA low-density, HVGA medium-density, WVGA high-density.</p></li>
<li><p>large: Screens that are of similar size to a medium-density VGA screen. The minimum layout size for a large screen is approximately 480x640 dp units. Examples are VGA and WVGA medium-density screens.</p></li>
<li><p>xlarge: Screens that are considerably larger than the traditional medium-density HVGA screen. The minimum layout size for an xlarge screen is approximately 720x960 dp units. In most cases, devices with extra-large screens would be too large to carry in a pocket and would most likely be tablet-style devices. Added in API level 9.</p></li>
</ul>
</blockquote>

<p>从上表的数据可知，目前 android 设备的主流尺寸分布是从 normal-hdpi 这个分类开始，根据 google 对 normal 的解释，它的大小相当于 medium-density HVGA 屏幕上的 <code>320x470 dp</code>，换算成设备像素就是 <code>480x705 px</code>，注意如果我们以这个尺寸去设计的话，那么得到的切图就是对应 hdpi(1.5)，要输出xhdpi(2) 的切图则要放大 1.3333 倍，这就有点不方便了，很容易得到奇数的像素尺寸，所以我们将 <code>480x705 px</code> 换算到 xhdpi(2) 的设备像素，得到 <code>640x940 px</code>。</p>

<p>我们知道宽屏比窄屏能显示更多内容，如果我们以宽屏为其准尺寸设计，那么在窄屏上就可能出现控件放不下、文字截断的情况。反过来，如果我们以窄屏为基准设计，那么在宽屏上布局时会容易处理，控件的宽度增加或者间隔增加就可以了。高度和宽度存在同样的问题，所以也应该选高度小的作为基准。设计时扣除固定元素高度之和后分配给可滚动区域，这样方便界面的元素布局能够动态响应，开发更好做屏幕适配。</p>

<p>所以选择基准尺寸和我们想支持的设备紧密相关，这需要基于多方面的因素考虑。 例如，如果我们希望支持尽可能多的设备，就越有可能获取更多用户，但开发的兼容工作量就相应增加，很多新特性就可能不适合作为应用的主要功能，而只适合作为增强功能。通常可以考虑覆盖 90% 以上，团队资金和人员比较充足的话可以考虑覆盖 95%，98% 甚至更多。</p>

<p>以覆盖 90% 以上为例，如果我们同时支持 iOS 和 android，或只支持 android 时，应该选 <code>640x940 px</code>作为基准尺寸，而如果只支持 iOS ， 我们应该选 <code>750 x 1334 px</code> 作为基准尺寸。</p>

<p>iOS 的设备像素比主要分布在2和3，而 android 这边设备像素比主要分布在 1.5(hdpi), 2(xhdpi)和 3(xxhdpi)，所以 iOS 需要输出<code>@2x</code> 和 <code>@3x</code> 两套切图； android 需要输出 hdpi, xhdpi 和 xxhdpi 三套切图。</p>

<h2>总结</h2>

<p>现在我们知道，设计基准尺寸的选择以及切图的输出是和我们想支持的设备紧密相关，写作本文时：</p>

<h3>基准尺寸</h3>

<ul>
<li>仅支持 iOS ， 应该选 <code>750 x 1334 px</code> 作为基准尺寸，对应的设备像素比是2</li>
<li>仅支持 android 时，应该选 <code>640x940 px</code> 作为基准尺寸，对应的设备像素比是2</li>
<li>支持 iOS 和 android，应该选 <code>640x940 px</code> 作为基准尺寸，对应的设备像素比是2</li>
</ul>


<h3>切图</h3>

<ul>
<li>支持 iOS 需要输出<code>@2x</code> 和 <code>@3x</code> 两套切图</li>
<li>支持 android 需要输出 hdpi, xhdpi 和 xxhdpi 三套切图</li>
</ul>


<p>基准尺寸对应的切图是 <code>@2x</code> 和 xhdpi，输出 hdpi(1.5) 则是切图缩小 0.75, <code>@3x</code> 和 xxhdpi(3) 则是切图放大 1.5 。</p>

<p>我们需要需要注意，随着设备的更新换代，我们的基准尺寸和切图会发生变化，就像以前我们可能需要为 android 提供 mdpi 的切图。</p>

<p>另外想说一下，设计师在设计之初就要把屏幕适配这事放在心上，将界面的元素看成水流一样，尽量让它们能自由流动，这样开发者就能更好地也更容易地做屏幕适配。Apple 在屏幕适配这块提出了 auto layout 的解决方案，这是一个设计师视角的解决方案，也是我们日常的生活中的视角，用界面元素的之间的约束来表达布局，推荐设计师用约束这种方式去做设计并最终输出。可以看到 google 实际上也很认可 auto layout 用约束来布局的想法，在新版本的 android 开发中默认的根布局容器就是 ConstraintLayout，它就是用约束来表达布局。最后我们再看 web 开发布局这边，css 布局的核心就是流，为支持屏幕适配，目前的主流方案是响应式布局，而这种布局的核心我认为仍然是约束。可以看到在屏幕适配这块，各平台最终的想法其实是一样的。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://hacks.mozilla.org/2013/09/css-length-explained/">CSS Length Explained</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution</a></li>
<li><a href="https://developer.android.google.cn/training/multiscreen/screendensities">Support different pixel densities</a></li>
<li><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#ScreenSizeQualifier">ScreenSizeQualifier</a></li>
<li><a href="https://developer.android.google.cn/training/multiscreen/screensizes">Support different screen sizes</a></li>
<li><a href="https://developer.android.com/about/dashboards/index.html#Screens">Screen sizes and densities</a></li>
<li><a href="https://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions">The Ultimate Guide To iPhone Resolutions</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
