<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2017-04-14T21:33:09+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[输出自定义尺寸视频]]></title>
    <link href="http://DamianSheldon.github.io/blog/how-to-specify-a-resolution-for-output-video.html"/>
    <updated>2017-04-10T10:12:09+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/how-to-specify-a-resolution-for-output-video</id>
    <content type="html"><![CDATA[<p>最近要做的一个项目中要拍摄视频，于是就开始来研究视频。看了几遍 AVFoundation Programming Guide 之后也写了个 Demo，把基本功能都过了一遍。这其中有意思的一件事情是我发现微信拍摄短视频的尺寸是 540x944, 这尺寸很奇怪，不是任何一个预设值。不清楚微信为什么用这么一个尺寸，但我想搞清楚怎么输出自定义尺寸的视频。</p>

<p>AVFoundation 捕获数据输出时，各组件的关系如下：</p>

<div style="text-align:center" markdown="1">
                                                                                           <img name="Capture Detail" src="http://DamianSheldon.github.io/images/captureDetail_2x.png">
                                                                                        </div>


<p>要想输出自定义尺寸的视频，我们可以从输入端和输出端着手。但是从文档来看，并没有提供可以自定捕获尺寸的方法，所以只能从输出端着手。</p>

<!--more-->


<p>首先我用 AVCaptureMovieFileOutput 做输出，然后调用 <code>setOutputSettings(_ outputSettings: [AnyHashable : Any]!, for connection: AVCaptureConnection!)</code> 来达到目标。但是很不幸，控制台输出了异常，查看 AVCaptureMovieFileOutput 的头文件，</p>

<blockquote><p>On iOS, you may only specify the AVVideoCodecKey in the outputSettings. If you specify any other key, an NSInvalidArgumentException will be thrown. See the availableVideoCodecTypes property.</p></blockquote>

<p>所以这个方法行不通。</p>

<p>于是我又尝试用 AVAssetWriter 来接收每一帧捕获的数据，然后按配置输出，理论上来讲这是可行的，实际上只有第一帧数据能成功被接收，之后的数据都会接收失败，具体原因不详。</p>

<p>直接处理每一帧数据失败之后，我又反复翻阅文档，发现编辑章节中提到可以修改 renderSize, 于是又一个想法冒出来，也许可以通过修改 renderSize 来输出自定义尺寸。按照文档编写好相关代码，激动地运行测试。结果得到的是：</p>

<pre><code>Optional(Error Domain=AVFoundationErrorDomain Code=-11800 "The operation could not be completed" UserInfo={NSUnderlyingError=0x1700505c0 {Error Domain=NSOSStatusErrorDomain Code=-12108 "(null)"}, NSLocalizedFailureReason=An unknown error occurred (-12108), NSLocalizedDescription=The operation could not be completed})
</code></pre>

<p>说实话，内心是崩溃的。但对这件事情还是耿耿于怀，又浏览了一下官方示例列表，发现了 AVSimpleEditoriOS,</p>

<blockquote><p>AVSimpleEditor is a simple AVFoundation based movie editing application which exercises the APIs of AVVideoComposition, AVAudioMix and demonstrates how they can be used for simple video editing tasks. It also demonstrates how they interact with playback (AVPlayerItem) and export (AVAssetExportSession). The application performs trim, rotate, crop, add music, add watermark and export. This sample is ARC-enabled.</p></blockquote>

<p>嗯，看到里面提到可以裁剪，于是就想它是怎么做？可以剪成我想要的大小吗？阅读相关的代码片断，原来它就是用的 renderSize 来实现裁剪的，跟我第三种方法的代码基本一致，差别是它是 Objc 写的，我用 Swift 写的。既然它能正常工作，那我就用这份代码来输出自定义尺寸吧。把代码移进来，运行测试，居然输出了指定的尺寸，难道代码用 Objc 和 Swift 写还有这种差别，整个人是懵的，这个原因暂时是不清楚的。</p>

<p>虽然输出的尺寸对了，但是画面没有铺满尺寸，而且方向错了。这有点太虐了，既然都走到这一步，就想那我再试试能不手动把它纠正吧。纠正的方法是使用 transform, 但是文档对它的介绍不详细，我先参考了 QuartZ 2D Programming Guide 中 Transforms 来变换，发现不对，整个画面全变成了黑色，又在 AVSimpleEditoriOS 的注释中发现了新的线索，</p>

<blockquote><p>Note: the point of origin for rotation is the upper left corner of the composition, t3 is to compensate for origin</p></blockquote>

<p>这么说它用的坐标和 QuartZ 2D 还不一样啊，这么坑爹，好吧，只能先确定好它们是怎么变换的。于是我先输出一段没变换的视频，之后每次测试一个变换，用这个办法确认了它们的变换是这样的，变换的原点是屏幕的左上角，Translation 向右是 X 轴的正方向，向下是 Y 轴的正方向; Rotation 的度数为正是按顺时针方向旋转，为负则是逆时针方向旋转；Scaling 的值大于1为放大，小于1则是缩小。</p>

<p>这样我就做了这么一个变换：</p>

<pre><code>t1 = CGAffineTransformScale(asset.preferredTransform, sx, sy);

t1 = CGAffineTransformRotate(t1, degreesToRadians(90));

t1 = CGAffineTransformTranslate(t1, 540, 0);
</code></pre>

<p>控制台报错了，说这个视频不支持编辑，这是个什么鬼？完全没有道理啊！于是我又把这段代码从下往上一行一行注释，看是谁导致的问题，发现是 <code>t1 = CGAffineTransformRotate(t1, degreesToRadians(90));</code> ，这样我又试着调整变换的顺序，改成：</p>

<pre><code>t1 = CGAffineTransformTranslate(asset.preferredTransform, 540, 0);

t1 = CGAffineTransformScale(t1, sx, sy);

t1 = CGAffineTransformRotate(t1, degreesToRadians(90));
</code></pre>

<p>运行测试，苍天啊，居然可以了。经历这么一出，感觉写代码都成了玄学了, 无力吐槽!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AVFoundation 使用笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/notes-of-using-avfoundation.html"/>
    <updated>2017-04-06T15:09:30+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/notes-of-using-avfoundation</id>
    <content type="html"><![CDATA[<p>使用一个框架时，我们可能有这么三个问题：</p>

<ol>
<li>这个框架是做什么的？</li>
<li>为什么要使用这个框架而不是其他的框架？</li>
<li>怎么用这个框架？</li>
</ol>


<h3>这个框架是做什么的？</h3>

<p>Apple 在 iOS Technology Overview 中的 Audio Technologies 和 Video Technologies 分别是这么介绍 AVFoundation 的：</p>

<blockquote><p>AV Foundation is an Objective-C interface for managing the recording and playback of audio and video. Use this framework for recording audio and when you need fine-grained control over the audio playback process.</p>

<p>AV Foundation provides advanced video playback and recording capabilities. Use this framework in situations where you need more control over the presentation or recording of video. For example, augmented reality apps could use this framework to layer live video content with other app-provided content.</p></blockquote>

<p>从这两个介绍中我们可以知道 AVFoundation 是用来播放和录制音频和视频的。</p>

<p>在 AVFoundation Programming Guide 中则是这么介绍的：</p>

<blockquote><p>AVFoundation is one of several frameworks that you can use to play and create time-based audiovisual media. It provides an Objective-C interface you use to work on a detailed level with time-based audiovisual data. For example, you can use it to examine, create, edit, or reencode media files. You can also get input streams from devices and manipulate video during realtime capture and playback.</p></blockquote>

<p>从这里我们可以知道它不仅可以播放和创建基于时间的视听媒体，还可以让我们在很细微的层面去操作这些视听数据。例如，你可以使用它检查、创建、编辑或者重编码媒体文件。你还可以用它从设备那里拿到输出流，并且可以在实时的捕获和播放过程中操作视频。</p>

<p>所以结论就是：这个框架是处理音频和视频的，而且处理的粒度可以非常细。</p>

<!--more-->


<h3>为什么要用这个框架而不是其他的框架？</h3>

<p>在选择框架时我们的原则应该首先是使用 Apple 自己提供的框架，其次才是第三方框架。在 Apple 自带的框架中选择时，又应该按抽象程度从高到低去选择。在音频技术中，抽象程度是这样的：Media Player framework > AVFoundation > OpenAL > Core Audio; 在视频技术中：UIImagePickerController > AVKit > AVFoundation > Core Media.</p>

<p>在音视频技术中，抽象程度高于 AVFoundation 的技术多侧重于简单的播放和录制，要进行其他的操作时则要使用 AVFoundation，而且它的能力也比较强，所以通常要对媒体数据进行处理时，我们会经常使用到它，它不满足要求时才去寻找其他的技术。</p>

<h3>怎么用这个框架？</h3>

<p>前面提到 AVFoundation 是用来播放、录制和操作视听数据的，操作视听数据则可以细分为 Editing 和 Exporting，所以我们这里会介绍这个框架:Playback, Capture, Editing 和 Exporting 四个大方面的使用。</p>

<h4>Playback</h4>

<p>在介绍怎么使用 AVFoundation 播放视听媒体之前，我们还要聊聊在 AVFoundation 中是怎么表示媒体的。AVFoundation 中用来代表媒体最主要的类是 AVAsset, 一个 AVAsset 实例是一片或多片媒体数据(音频曲目和视频轨迹)集合的综合代表。它提供关于这个集合的信息，例如它的标题，持续时间，本身的展示尺寸等等。AVAsset 没有绑定特定的数据类型。它是其他用来从指定 URL 媒体创建资产实例和创建新构成的父类。</p>

<p>资产中每片单独的媒体数据是统一的类型称为track. 在经典的简单场景，一个轨迹代表音频组件，另一个轨迹代表视频组件；在一个复杂的构成中，这里可能有多个重叠的音视频轨迹。</p>

<p>你为播放配置资产的方法取决于你想要播放资产的种类，广义上来讲，这里有两大类型：基于文件的资产和基于流的资产。</p>

<ol>
<li><p>加载和播放基于文件的资产。</p>

<ul>
<li>Create an asset using AVURLAsset.</li>
<li>Create an instance of AVPlayerItem using the asset.</li>
<li>Associate the item with an instance of AVPlayer.</li>
<li>Wait until the item’s status property indicates that it’s ready to play (typically you use key-value observing to receive a notification when the status changes).</li>
</ul>
</li>
<li><p>为播放创建和准备一个 HTTP 实时流。</p></li>
</ol>


<pre><code>NSURL *url = [NSURL URLWithString:@"&lt;#Live stream URL#&gt;];
// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.
self.playerItem = [AVPlayerItem playerItemWithURL:url];
[playerItem addObserver:self forKeyPath:@"status" options:0 context:&amp;ItemStatusContext];
self.player = [AVPlayer playerWithPlayerItem:playerItem];
</code></pre>

<ol>
<li><p>如果你不知道你拥有的 URL 是什么类型。</p>

<p> 1)Try to initialize an AVURLAsset using the URL, then load its tracks key.
 If the tracks load successfully, then you create a player item for the asset.</p>

<p> 2)If 1 fails, create an AVPlayerItem directly from the URL.
 Observe the player’s status property to determine whether it becomes playable.</p></li>
</ol>


<h4>Capture</h4>

<p>为了管理来自相机、麦克风的捕获，你组装对象去表示输入和输出，使用 AVCaptureSession 的实例来协调它们之间的数据流。你最少需要：</p>

<ul>
<li>一个 AVCaptureDevice 的实例来表示输入设备，例如相机或麦克风</li>
<li>一个 AVCaptureInput 具体子类的实例去配置来自输入设备的端口</li>
<li>一个 AVCaptureOutput 具体子类的实例去管理到电影或静态图片的输出</li>
<li>一个 AVCaptureSession 的实例来协调从输入到输出的数据流</li>
</ul>


<p>Capturing Video Frames as UIImage Objects</p>

<pre><code>// 1. Create and Configure a Capture Session
AVCaptureSession *session = [[AVCaptureSession alloc] init];
session.sessionPreset = AVCaptureSessionPresetMedium;

// 2. Create and Configure the Device and Device Input
AVCaptureDevice *device =
[AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];

NSError *error = nil;
AVCaptureDeviceInput *input =
[AVCaptureDeviceInput deviceInputWithDevice:device error:&amp;error];
if (!input) {
    // Handle the error appropriately.
}
[session addInput:input];

// 3. Create and Configure the Video Data Output
AVCaptureVideoDataOutput *output = [[AVCaptureVideoDataOutput alloc] init];
[session addOutput:output];
output.videoSettings =
@{ (NSString *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) };
output.minFrameDuration = CMTimeMake(1, 15);

dispatch_queue_t queue = dispatch_queue_create("MyQueue", NULL);
[output setSampleBufferDelegate:self queue:queue];
dispatch_release(queue);

// 4. Implement the Sample Buffer Delegate Method
- (void)captureOutput:(AVCaptureOutput *)captureOutput
didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer
fromConnection:(AVCaptureConnection *)connection {

    UIImage *image = imageFromSampleBuffer(sampleBuffer);
    // Add your code here that uses the image.
}
// 5. Starting and Stopping Recording
NSString *mediaType = AVMediaTypeVideo;

[AVCaptureDevice requestAccessForMediaType:mediaType completionHandler:^(BOOL granted) {
    if (granted)
    {
        //Granted access to mediaType
        [self setDeviceAuthorized:YES];
    }
    else
    {
        //Not granted access to mediaType
        dispatch_async(dispatch_get_main_queue(), ^{
                [[[UIAlertView alloc] initWithTitle:@"AVCam!"
                message:@"AVCam doesn't have permission to use Camera, please change privacy settings"
                delegate:self
                cancelButtonTitle:@"OK"
                otherButtonTitles:nil] show];
                [self setDeviceAuthorized:NO];
                });
    }
}];

[session startRunning];

// To stop recording, you send the session a stopRunning message.
</code></pre>

<h4>Editing</h4>

<p>AVFoundation 框架提供了丰富的类来方便编辑音视资产。编辑 API 的核心是 composition. 一个 Compostion 是简单的来自一个或多个不同媒体资产的聚合。AVMutableCompostion 类提供插入和移除轨迹的接口，并且管理它们的时间顺序。图 3-1 展示了一个新的 composition
是如何用由现存资产联合形成的新资产拼装在一起的。如果你所有想要做的就是将多个资产按顺序的合成到一个单一的文件，那么这就是你得知道的所有细节。如果你想对你 compostion 里面的轨迹进行自定义的音频或视频处理，你相应地需要引入一个 audio mix 或 video compostion.</p>

<div style="text-align:center" markdown="1">
    <img name="AVMutableComposition" src="http://DamianSheldon.github.io/images/avmutablecomposition_2x.png">
</div>


<p>使用 AVMutableAudioMix 类， 你可以在你的 composition 的音频轨迹上进行自定义音频处理，像图 3-2 显示的。你现在可以指定一个最大的音量或者设置 volume ramp.</p>

<div style="text-align:center" markdown="1">
    <img name="AVMutableAudioMix" src="http://DamianSheldon.github.io/images/avmutableaudiomix_2x.png">
</div>


<p>你为了编辑可以像图 3-3 那样使用 AVMutableVideoCompostion 类来直接操作你 compostion 里的视频轨迹. 拥有一个 video composition, 你可以为输出视频指定想要的渲染尺寸,缩放以及帧率。通过一个 video composition&rsquo;s instruction(由 AVMutableVideoCompositionInstruction 类代表)，你可以修改你视频的背景颜色和应用 layer instructions. 这些 layer instructions（由 AVMutableVideoCompositionLayerInstruction 类代表) 可以用来应用 transforms, transform ramps, opacity and opacity ramps。Video
composition 类使用 animationTool 属性赋予你引入来自 Core Animation 框架效果的能力。</p>

<div style="text-align:center" markdown="1">
    <img name="AVMutableVideoCompostion" src="http://DamianSheldon.github.io/images/avmutablevideocomposition_2x.png">
</div>


<p>为了把你的 compostion 和 audio mix, video compostion 混合，你使用一个 AVAssetExportSession 对象，像 图 3-4 那样。你用你的 compostion 初始化 export session, 然后简单地把你的 audio mix 和 video composition 相应地赋值给 audioMix 和 videoComposition 属性。</p>

<div style="text-align:center" markdown="1">
    <img name="AVAssetExportSession" src="http://DamianSheldon.github.io/images/puttingitalltogether_2x.png">
</div>


<p>Combining Multiple Assets and Saving the Result to the Camera Roll</p>

<pre><code>// 1. Creating the Composition
AVMutableComposition *mutableComposition = [AVMutableComposition composition];
AVMutableCompositionTrack *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];
AVMutableCompositionTrack *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];

// 2. Adding the Assets
AVAssetTrack *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];
AVAssetTrack *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];
[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration) ofTrack:firstVideoAssetTrack atTime:kCMTimeZero error:nil];
[videoCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) ofTrack:secondVideoAssetTrack atTime:firstVideoAssetTrack.timeRange.duration error:nil];
[audioCompositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) ofTrack:[[audioAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0] atTime:kCMTimeZero error:nil];

// 3. Checking the Video Orientations
BOOL isFirstVideoPortrait = NO;
CGAffineTransform firstTransform = firstVideoAssetTrack.preferredTransform;
// Check the first video track's preferred transform to determine if it was recorded in portrait mode.
if (firstTransform.a == 0 &amp;&amp; firstTransform.d == 0 &amp;&amp; (firstTransform.b == 1.0 || firstTransform.b == -1.0) &amp;&amp; (firstTransform.c == 1.0 || firstTransform.c == -1.0)) {
        isFirstVideoPortrait = YES;
}
BOOL isSecondVideoPortrait = NO;
CGAffineTransform secondTransform = secondVideoAssetTrack.preferredTransform;
// Check the second video track's preferred transform to determine if it was recorded in portrait mode.
if (secondTransform.a == 0 &amp;&amp; secondTransform.d == 0 &amp;&amp; (secondTransform.b == 1.0 || secondTransform.b == -1.0) &amp;&amp; (secondTransform.c == 1.0 || secondTransform.c == -1.0)) {
        isSecondVideoPortrait = YES;
}
if ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) || (!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) {
        UIAlertView *incompatibleVideoOrientationAlert = [[UIAlertView alloc] initWithTitle:@"Error!" message:@"Cannot combine a video shot in portrait mode with a video shot in landscape mode." delegate:self cancelButtonTitle:@"Dismiss" otherButtonTitles:nil];
            [incompatibleVideoOrientationAlert show];
                return;
}

// 4. Applying the Video Composition Layer Instructions
AVMutableVideoCompositionInstruction *firstVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];
// Set the time range of the first instruction to span the duration of the first video track.
firstVideoCompositionInstruction.timeRange = CMTimeRangeMake(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);
AVMutableVideoCompositionInstruction * secondVideoCompositionInstruction = [AVMutableVideoCompositionInstruction videoCompositionInstruction];
// Set the time range of the second instruction to span the duration of the second video track.
secondVideoCompositionInstruction.timeRange = CMTimeRangeMake(firstVideoAssetTrack.timeRange.duration, CMTimeAdd(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));
AVMutableVideoCompositionLayerInstruction *firstVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];
// Set the transform of the first layer instruction to the preferred transform of the first video track.
[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];
AVMutableVideoCompositionLayerInstruction *secondVideoLayerInstruction = [AVMutableVideoCompositionLayerInstruction videoCompositionLayerInstructionWithAssetTrack:videoCompositionTrack];
// Set the transform of the second layer instruction to the preferred transform of the second video track.
[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];
firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];
secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];
AVMutableVideoComposition *mutableVideoComposition = [AVMutableVideoComposition videoComposition];
mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];

// 5. Setting the Render Size and Frame Duration
CGSize naturalSizeFirst, naturalSizeSecond;
// If the first video asset was shot in portrait mode, then so was the second one if we made it here.
if (isFirstVideoAssetPortrait) {
    // Invert the width and height for the video tracks to ensure that they display properly.
        naturalSizeFirst = CGSizeMake(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);
            naturalSizeSecond = CGSizeMake(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);
}
else {
    // If the videos weren't shot in portrait mode, we can just use their natural sizes.
        naturalSizeFirst = firstVideoAssetTrack.naturalSize;
            naturalSizeSecond = secondVideoAssetTrack.naturalSize;
}
float renderWidth, renderHeight;
// Set the renderWidth and renderHeight to the max of the two videos widths and heights.
if (naturalSizeFirst.width &gt; naturalSizeSecond.width) {
        renderWidth = naturalSizeFirst.width;
}
else {
        renderWidth = naturalSizeSecond.width;
}
if (naturalSizeFirst.height &gt; naturalSizeSecond.height) {
        renderHeight = naturalSizeFirst.height;
}
else {
        renderHeight = naturalSizeSecond.height;
}
mutableVideoComposition.renderSize = CGSizeMake(renderWidth, renderHeight);
// Set the frame duration to an appropriate value (i.e. 30 frames per second for video).
mutableVideoComposition.frameDuration = CMTimeMake(1,30);

// 6. Exporting the Composition and Saving it to the Camera Roll
// Create a static date formatter so we only have to initialize it once.
static NSDateFormatter *kDateFormatter;
if (!kDateFormatter) {
        kDateFormatter = [[NSDateFormatter alloc] init];
            kDateFormatter.dateStyle = NSDateFormatterMediumStyle;
                kDateFormatter.timeStyle = NSDateFormatterShortStyle;
}
// Create the export session with the composition and set the preset to the highest quality.
AVAssetExportSession *exporter = [[AVAssetExportSession alloc] initWithAsset:mutableComposition presetName:AVAssetExportPresetHighestQuality];
// Set the desired output URL for the file created by the export process.
exporter.outputURL = [[[[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:@YES error:nil] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[NSDate date]]] URLByAppendingPathExtension:CFBridgingRelease(UTTypeCopyPreferredTagWithClass((CFStringRef)AVFileTypeQuickTimeMovie, kUTTagClassFilenameExtension))];
// Set the output file type to be a QuickTime movie.
exporter.outputFileType = AVFileTypeQuickTimeMovie;
exporter.shouldOptimizeForNetworkUse = YES;
exporter.videoComposition = mutableVideoComposition;
// Asynchronously export the composition to a video file and save this file to the camera roll once export completes.
[exporter exportAsynchronouslyWithCompletionHandler:^{
        dispatch_async(dispatch_get_main_queue(), ^{
                    if (exporter.status == AVAssetExportSessionStatusCompleted) {
                                    ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];
                                                if ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) {
                                                                    [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:NULL];
                                                                                }
                                                                                        }
                                                                                            });
}];
</code></pre>

<h4>Exporting</h4>

<p>为了读写视听资产，你必须使用 AVFoundation 框架提供的导出 API. AVAssetExportSession 类为简单的导出需求提供接口，例如修改文件格式或者裁剪资产的长度。对于更深的导出需求，使用 AVAssetReader 和 AVAssetWriter 类。</p>

<p>当你想要操作资产的内容时使用 AVAssetReader. 例如，你可能读取资产中的音频轨迹去生成表示声波的图形。使用 AVAssetWriter 从像 sample buffers 或 still images 的媒体中生成资产。</p>

<p>Reading an Asset</p>

<p>每个 AVAssetReader 对象一次只能关联单个的资产， 但是这个资产可能包含多个轨迹。基于这个原因，为了配置如何去读取媒体数据，你必须在读取前给你的 asset reader 赋予 AVAssetReaderOutput 的具体子类。这里有三个具体的子类：AVAssetReaderTrackOutput, AVAssetReaderAudioMixOutput 和 AVAssetReaderVideoCompositionOutput.</p>

<ol>
<li>Creating the Asset Reader</li>
</ol>


<pre><code>NSError *outError;
AVAsset *someAsset = &lt;#AVAsset that you want to read#&gt;;
AVAssetReader *assetReader = [AVAssetReader assetReaderWithAsset:someAsset error:&amp;outError];
BOOL success = (assetReader != nil);
</code></pre>

<ol>
<li>Setting Up the Asset Reader Outputs</li>
</ol>


<pre><code>AVAsset *localAsset = assetReader.asset;
// Get the audio track to read.
AVAssetTrack *audioTrack = [[localAsset tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];
// Decompression settings for Linear PCM
NSDictionary *decompressionAudioSettings = @{ AVFormatIDKey : [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM] };
// Create the output with the audio track and decompression settings.
AVAssetReaderOutput *trackOutput = [AVAssetReaderTrackOutput assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];
// Add the output to the reader if possible.
if ([assetReader canAddOutput:trackOutput])
        [assetReader addOutput:trackOutput];
</code></pre>

<ol>
<li>Reading the Asset’s Media Data</li>
</ol>


<pre><code>// Start the asset reader up.
[self.assetReader startReading];
BOOL done = NO;
while (!done)
{
    // Copy the next sample buffer from the reader output.
    CMSampleBufferRef sampleBuffer = [self.assetReaderOutput copyNextSampleBuffer];
    if (sampleBuffer)
    {
        // Do something with sampleBuffer here.
        CFRelease(sampleBuffer);
        sampleBuffer = NULL;
    }
    else
    {
        // Find out why the asset reader output couldn't copy another sample buffer.
        if (self.assetReader.status == AVAssetReaderStatusFailed)
        {
            NSError *failureError = self.assetReader.error;
            // Handle the error here.
        }
        else
        {
            // The asset reader output has read all of its samples.
            done = YES;
        }
    }
}
</code></pre>

<p>Writing an Asset</p>

<p>AVAssetWriter 类将多个来源的媒体数据按指定的文件格式写出到单一的文件。你不需要将你的 asset writer 对象和指定的资产关联起来，但是你必须为你想要创建的输出文件使用一个 asset writer. 因为一个 asset writer 可以写出来自多个源的媒体数据，你必须为你想要写出到输出文件的单独轨迹创建一个 AVAssetWriterInput 对象。每个 AVAssetWriterInput 对象期望收到 CMSampleBufferRef 对象格式的数据，但是如果你想追加 CVPixelBufferRef 对象到你的 asset writer input, 使用 AVAssetWriterInputPixelBufferAdaptor 类。</p>

<pre><code>// 1. Creating the Asset Writer
NSError *outError;
NSURL *outputURL = &lt;#NSURL object representing the URL where you want to save the video#&gt;;
AVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:outputURL
fileType:AVFileTypeQuickTimeMovie
error:&amp;outError];
BOOL success = (assetWriter != nil);

// 2. Setting Up the Asset Writer Inputs
// Configure the channel layout as stereo.
AudioChannelLayout stereoChannelLayout = {
    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,
    .mChannelBitmap = 0,
    .mNumberChannelDescriptions = 0
};

// Convert the channel layout object to an NSData object.
NSData *channelLayoutAsData = [NSData dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];

// Get the compression settings for 128 kbps AAC.
NSDictionary *compressionAudioSettings = @{
AVFormatIDKey         : [NSNumber numberWithUnsignedInt:kAudioFormatMPEG4AAC],
                        AVEncoderBitRateKey   : [NSNumber numberWithInteger:128000],
                        AVSampleRateKey       : [NSNumber numberWithInteger:44100],
                        AVChannelLayoutKey    : channelLayoutAsData,
                        AVNumberOfChannelsKey : [NSNumber numberWithUnsignedInteger:2]
};

// Create the asset writer input with the compression settings and specify the media type as audio.
AVAssetWriterInput *assetWriterInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudio outputSettings:compressionAudioSettings];
// Add the input to the writer if possible.
if ([assetWriter canAddInput:assetWriterInput])
    [assetWriter addInput:assetWriterInput];

// 3. Writing Media Data
// Prepare the asset writer for writing.
    [self.assetWriter startWriting];
    // Start a sample-writing session.
    [self.assetWriter startSessionAtSourceTime:kCMTimeZero];
    // Specify the block to execute when the asset writer is ready for media data and the queue to call it on.
    [self.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^{
        while ([self.assetWriterInput isReadyForMoreMediaData])
        {
            // Get the next sample buffer.
            CMSampleBufferRef nextSampleBuffer = [self copyNextSampleBufferToWrite];
            if (nextSampleBuffer)
            {
                // If it exists, append the next sample buffer to the output file.
                [self.assetWriterInput appendSampleBuffer:nextSampleBuffer];
                CFRelease(nextSampleBuffer);
                nextSampleBuffer = nil;
            }
            else
            {
                // Assume that lack of a next sample buffer means the sample buffer source is out of samples and mark the input as finished.
                [self.assetWriterInput markAsFinished];
                break;
            }
        }
    }];
</code></pre>

<p>Reference:<br/>
iOS Technology Overview<br/>
AVFoundation Programming Guide</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android开发问题汇总(三)]]></title>
    <link href="http://DamianSheldon.github.io/blog/problems-of-android-development-part-3.html"/>
    <updated>2017-04-05T08:48:36+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/problems-of-android-development-part-3</id>
    <content type="html"><![CDATA[<h3>1. How to define custom attributes?</h3>

<p>A:Currently the best documentation is the source. You can take a look at it <a href="https://github.com/android/platform_frameworks_base/blob/master/core/res/res/values/attrs.xml">here(arrts.xml)</a>.</p>

<p>You can define attributes in the top <code>&lt;resources&gt;</code> element or inside of a <code>&lt;declare-styleable&gt;</code> element. If I&rsquo;m going to use an attr in more than on place I put it in the root element. Note , all attributes share the same global namespace. That means that even if you create a new attribute inside of a <code>&lt;declare-styleable&gt;</code> element it can be used outside of it and you cannot create another attribute with the same name of a different type.</p>

<p>An <code>&lt;attr&gt;</code> element has two xml attributes <code>name</code> and <code>format</code>. <code>name</code> lets you call it something and this how you end up refering to it in code, e.g., R.attr.my_attribute. The <code>format</code> attribute can have different values depending on the type of attribute you want.</p>

<ul>
<li>reference - if it references another resource id(e.g, &ldquo;@color/my_color&rdquo;, &ldquo;@layout/my_layout&rdquo;)</li>
<li>color</li>
<li>boolean</li>
<li>dimension</li>
<li>float</li>
<li>integer</li>
<li>string</li>
<li>fraction</li>
<li>enum - normally implicitly defined</li>
<li>flag - normally implicitly defined</li>
</ul>


<p>You can set the format to multiple types by using |, e.g., <code>format="reference|color"</code>.</p>

<p>enum attributes can be defined as follows:</p>

<pre><code>&lt;attr name="my_enum_attr"&gt; 
    &lt;enmu name="value1" value="1" /&gt;
    &lt;enmu name="value2" value="2" /&gt;
&lt;/attr&gt;
</code></pre>

<p>flag attributes are similar except the values need to defined so they can be bit ored together:</p>

<pre><code>&lt;attr name="my_flag_attr"&gt;
    &lt;flag name="fuzzy" value="0x01" /&gt;
    &lt;flag name="cold" value="0x02" /&gt;
&lt;/attr&gt;
</code></pre>

<p>In addition to attributes there is the <code>&lt;declare-styleable&gt;</code> element. This allows you to define attributes a custom view can use. You do this by specifying an <code>&lt;attr&gt;</code> element, if it was previously defined you do not specify the format. If you wish to reuse an android attr, for example android:gravity, then you can do that in the name, as follows.</p>

<p>An example of a custom view <code>&lt;declare-styleable&gt;</code>:</p>

<pre><code>&lt;declare-styleable name="MyCustomView"&gt; 
    &lt;attr name="my_custom_attribute" /&gt;
    &lt;attr name="android:gravity" /&gt;
&lt;/declare-styleable&gt;
</code></pre>

<p>When defining you custom attributes in XML on you need to do a few things.</p>

<p>First you must declare a namespace to find your attributes. You do this on the root layout element. Normal there is only <code>xmlns:android="http//schemas.android.com/apk/res/android"</code>. You must now also add <code>xmlns:app="http://schemas.android.com/apk/res-auto"</code>.</p>

<p>Example:</p>

<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:whatever="http://schemas.android.com/apk/res-auto"
android:orientation="vertical"
android:layout_width="fill_parent"
android:layout_height="fill_parent"&gt;

&lt;org.example.mypackage.MyCustomView
android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:gravity="center"
whatever:my_custom_attribute="Hello, world!" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>Finally, to access that custom attribute you normally do so in the constructor of you custom view as follows:</p>

<pre><code>public MyCustomView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);

    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.MyCustomView, defStyle, 0);

    String str = a.getString(R.styleable.MyCustomView_my_custom_attribute);

    //do something with str

    a.recycle();
}
</code></pre>

<p>Reference:<a href="http://stackoverflow.com/questions/3441396/defining-custom-attrs">Defining custom attrs</a></p>

<h3>2. How to get Uri from raw file?</h3>

<p>A: <code>Uri url = Uri.parse("android.resource://" + getPackageName() + "/" + R.raw.usa_for_africa_we_are_the_world);</code></p>

<p>Reference:<a href="http://stackoverflow.com/questions/16791439/android-how-to-get-uri-from-raw-file">Android - How to get Uri from raw file?</a></p>

<h3>3. How to display all music on SD card?</h3>

<p>A: We can use loader perform this work,</p>

<pre><code>public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {
    return new CursorLoader(getActivity(), MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, new String[] { MediaStore.Audio.Media.DISPLAY_NAME }, null, null,
      "LOWER(" + MediaStore.Audio.Media.TITLE + ") ASC");    
}
</code></pre>

<p>Reference:<a href="http://stackoverflow.com/questions/8994625/display-all-music-on-sd-card">Display all music on SD card</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 真机抓包]]></title>
    <link href="http://DamianSheldon.github.io/blog/capturing-android-physic-device-traffic-on-tcpdump.html"/>
    <updated>2017-03-11T17:04:33+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/capturing-android-physic-device-traffic-on-tcpdump</id>
    <content type="html"><![CDATA[<p>在 Android 开发过程中，可能会遇到和服务端交互有问题的情况，这时候就得拿出证据来和服务端撕逼, 而最有力的证据自然是抓取的网络数据包；又或者是遇到很诡异的网络问题，这时候就可以借助抓包来分析和定位问题。</p>

<p>如果我们和服务端的交互没有通过 VPN, 而且也不是视频流这种网络性能要求苛刻的情况，我们可以通过 tPacketCapture 这种应用来抓包；</p>

<p>其他情况我们可以通过 root 手机，然后安装 tcpdump 来抓包。</p>

<p>下面我们详细介绍下 通过 tcpdump 抓包这种方法：</p>

<ul>
<li>Root 手机</li>
</ul>


<p>Root 手机的原理是利用系统存在的漏洞来获得 root 权限，<a href="https://forum.xda-developers.com/">XDA Developers</a> 上有不少 root 工具，很多手机都可以用它们 root。</p>

<ul>
<li>安装 tcpdump</li>
</ul>


<p>可以到网上搜索为 Android 编译好的 tcpdump 二进制包，例如<a href="http://www.strazzere.com/android/tcpdump">这里</a>就有一个。</p>

<pre><code>// Copy tcpdump to device
$ adb -d push /path/to/tcpdump /sdcard/tcpdump

// Device shell
$ adb -d shell

// Switch to root
$ su

// Copy tcpdump to /data/local/
# cat /sdcard/tcpdump /data/local/tcpdump
</code></pre>

<!--more-->


<ul>
<li>抓包</li>
</ul>


<pre><code>/# cd /data/local
/# ./tcpdump -i any -p -s 0 -w /sdcard/capture.pcap

//  Options
    # "-i any": listen on any network interface

　　# "-p": disable promiscuous mode (doesn't work anyway)

　　# "-s 0": capture the entire packet

　　# "-w": write packets to a file (rather than printing to stdout)

　　... do whatever you want to capture, then ^C to stop it ...
</code></pre>

<ul>
<li>分析</li>
</ul>


<pre><code>// Copy capture.pcap to computer
$ adb -d pull /sdcard/capture.pcap /path/to/capture.pcap

Analyze with Wireshark.
</code></pre>

<ul>
<li>Shell Commands</li>
</ul>


<p>Android 手机上的命令通常不全，我们可以通过安装 BusyBox 来提供一个相对完成 Shell 命令集方便我们的开发工作。</p>

<p>1,Download <a href="http://www.busybox.net/downloads/binaries">BusyBox</a> 的压缩包;<br/>
2,获取设备 CPU 的架构版本 <code>adb -d shell cat /proc/cpuinfo</code><br/>
3,解开压缩包，把对应 CPU 架构版本的二进制包生命名为 busybox,例如 <code>mv busybox-armv7l busybox</code>;<br/>
4,安装 busybox 到设备上，</p>

<pre><code>// Copy busybox to device
$adb -d push /path/to/busybox /sdcard/busybox

// Switch to device shell
$adb -d shell

// Install busybox
$ su

\# cat /sdcard/busybox /system/xbin/busybox

// Check install result
# busybox 

...
</code></pre>

<h2>Reference</h2>

<ul>
<li><a href="http://www.cnblogs.com/likwo/archive/2012/09/06/2673944.html">Android通过tcpdump抓包</a></li>
<li><a href="http://www.cnblogs.com/blues_/p/3582097.html">转adb Shell root 权限</a></li>
<li><a href="http://www.cnblogs.com/xiaowenji/archive/2011/03/12/1982309.html">为Android安装BusyBox —— 完整的bash shell</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Photos 框架的基本使用]]></title>
    <link href="http://DamianSheldon.github.io/blog/photos-framework-usage.html"/>
    <updated>2016-12-23T14:23:33+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/photos-framework-usage</id>
    <content type="html"><![CDATA[<p>从 iOS 9 开始 Apple 把 Asset Library 标记为废弃状态，并建议开发者使用 Photos 框架。</p>

<blockquote><p>The Assets Library framework is deprecated as of iOS 9.0. Instead, use the Photos framework instead, which in iOS 8.0 and later provides more features and better performance for working with a user’s photo library.</p></blockquote>

<p>不幸的是 Apple 并没有发布相关的使用指导文档，只有一个相关 Demo。使用的时候固然可以回头参考这个 Demo，但这样的效率不是很高，很多概念也容易忘记，所以这里做个简单的总结。</p>

<p>Photos 中有不少类，其中几个犹为关键。PHPhotoLibary 是我们操作 Photo Library 里面资源的入口对象，所有的操作都通过它完成。PHCollectionList 表示相册中的专题列表；PHAssetCollection 表示专题；PHAsset 表示资源，如 images, videos, and Live Photos.</p>

<p>我们基本的需求就是 CRUD, 这些操作是需要用户授权的，记得先获取权限再操作， 下面我们展示相关的代码片段。</p>

<h3>Create</h3>

<ol>
<li>创建一个资源</li>
</ol>


<pre><code>PHPhotoLibrary.shared().performChanges({
            PHAssetChangeRequest.creationRequestForAsset(from: image)
        }, completionHandler: {success, error in
            if !success { print("error creating asset: \(error)") }
        })
</code></pre>

<ol>
<li>创建一个资源到指定的专题</li>
</ol>


<pre><code>PHPhotoLibrary.shared().performChanges({
            let creationRequest = PHAssetChangeRequest.creationRequestForAsset(from: image)
            if let assetCollection = self.assetCollection {
            let addAssetRequest = PHAssetCollectionChangeRequest(for: assetCollection)
            addAssetRequest?.addAssets([creationRequest.placeholderForCreatedAsset!] as NSArray)
            }
        }, completionHandler: {success, error in
            if !success { print("error creating asset: \(error)") }
        })
</code></pre>

<!-- more -->


<h3>Read (Fetch)</h3>

<p>获取资源是通过 PHAsset 提供的一系列以 fetchXXX 开头的类方法，选择哪个方法取决于需求，这里示例其中两个我觉得常用的方法。</p>

<ol>
<li><code>class func fetchAssets(with options: PHFetchOptions?) -&gt; PHFetchResult&lt;PHAsset&gt;</code></li>
</ol>


<p>我们可以用这个方法获取 Photo Library 里面所有的资源。</p>

<pre><code>let allPhotosOptions = PHFetchOptions()
    allPhotosOptions.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: true)]
self.fetchResult = PHAsset.fetchAssets(with: allPhotosOptions)
</code></pre>

<ol>
<li><code>class func fetchAssets(in assetCollection: PHAssetCollection, options: PHFetchOptions?) -&gt; PHFetchResult&lt;PHAsset&gt;</code></li>
</ol>


<p>我们可以用这个方法获取指定专题里面的资源。例如我们想获取 Camera Roll 这个专题里面的资源：</p>

<pre><code>let cameraRoll: PHFetchResult&lt;PHAssetCollection&gt; = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumUserLibrary, options: nil).firstObject
let fetchResult = PHAsset.fetchAssets(in: cameraRoll, options: nil)
</code></pre>

<h3>Update (Edit)</h3>

<p>编辑的基本的做法是先用资源请求一个 PHContentEditingInput，然后编辑资源，为了方便用户之后继续编辑或撤销可以实例化一个 PHAdjustmentData 对象来持有相关信息。编辑完成之后对于图片和视频需要实例化一个 PHContentEditingOutput 来完成输出，PHContentEditingOutput 的 adjustmentData 属性关联之前的 PHAdjustmentData, 并把编辑完成的内容输出到 PHContentEditingOutput 的 renderedContentURL。最后创建一个 PHAssetChangeRequest 对象，设置它的 contentEditingOutput 为
之前实例化的 PHContentEditingOutput。</p>

<p>这部分的代码会多点，具体可以查看 <a href="https://github.com/DamianSheldon/PhotosFrameworkUsage">Demo</a>.</p>

<h3>Delete</h3>

<pre><code>PHPhotoLibrary.shared().performChanges({ 
        PHAssetChangeRequest.deleteAssets([self.asset] as NSArray)
        }) { (success, error) in
    DispatchQueue.main.sync {
        self.trashButton.isEnabled = success ? false : true
    }

    if success {
        print("delete asset successfully")
    }
    else {
        print("can't delete asset: \(error)")
    }
}
</code></pre>

<h3>完整 Demo</h3>

<p><a href="https://github.com/DamianSheldon/PhotosFrameworkUsage">PhotosFrameworkUsage</a></p>

<h3>Caveat</h3>

<p>使用过程中遇到一个坑，这里记一下。</p>

<pre><code>guard let inputImage = CIImage(contentsOf: input.fullSizeImageURL!)
            else { fatalError("can't load input image to edit") }

// Apply the filter.
let outputImage = inputImage
    .applyingOrientation(input.fullSizeImageOrientation)
.applyingFilter(filterName, withInputParameters: nil)

// List 1.
let uiImage = UIImage(ciImage: outputImage)

// List 2.
if let cgImage = CIContext(options: nil).createCGImage(outputImage, from: outputImage.extent) {
    let uiImage = UIImage(cgImage:cgImage)
}
else {
    print("instance UIImage from CGImage failed!")    
}

// Ouput
if let data = UIImageJPEGRepresentation(uiImage, 0.7) {
    // NSData - (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;
    do {
        try data.write(to: output.renderedContentURL)

    } catch let error {
        print("output filtered image to specify URL failed: \(error)")
    }
}
else {
    print("generate JPEG representation data failed")
        return
}
</code></pre>

<p>这里的问题是直接用 CIImage 实例化  UIImage 会失败，得转成 CGImage 然后实例化 UIImage. 至于它的原因我暂时还不清楚。</p>

<p>Reference:<a href="http://stackoverflow.com/questions/29732886/uiimagejpegrepresentation-returns-nil">UIImageJPEGRepresentation returns nil</a></p>
]]></content>
  </entry>
  
</feed>
