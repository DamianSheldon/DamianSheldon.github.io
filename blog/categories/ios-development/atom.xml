<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/ios-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2021-11-09T11:14:11+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UI 设计与屏幕适配]]></title>
    <link href="http://DamianSheldon.github.io/blog/ui-design-and-screen-adaptation.html"/>
    <updated>2021-03-17T15:12:26+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ui-design-and-screen-adaptation</id>
    <content type="html"><![CDATA[<p>目前移动设备的尺寸很多，所以前端 (iOS, Android, Web, 小程序等)开发需要适配多种尺寸屏幕。在适配时我们可能会有困惑，设计稿通常是 px 来表示尺寸，设备的分辨率也是以 px 来表示，它们之间是一样的吗？还是存在什么关系？iOS 开发者用 point 来表示视图的尺寸； Android 开发者用 dp 来表示视图尺寸； Web 开发者用 px 来表示尺寸？它们和设计稿的 px 是什么关系？设计师应该以什么基准尺寸来设计会有利于屏幕适配？应该输出几套切图？除了切图，设计师还可以做些什么来配合开发者做屏幕适配？要搞清楚这些问题，我们需要翻翻历史了。</p>

<p>Tim Chien 和 Robert Nyman 的这篇 <a href="https://hacks.mozilla.org/2013/09/css-length-explained/">CSS Length Explained</a> 帮了我的大忙，本文就是基于它而写成。</p>

<h2>英寸</h2>

<p>我们经常是用英寸为度量单位来表示手机屏幕尺寸，一英寸相当于2.54厘米或0.0254米。</p>

<h2>设备像素(device pixel)</h2>

<p>计算机屏幕显示事物的单位是像素。显示屏上的单个物理 &ldquo;光点"，能够独立于它的邻居显示出完整的颜色，被称为像素（图片元素）。我们把屏幕上的物理像素称为 "设备像素"。</p>

<h2>DPI, PPI</h2>

<p>DPI 是 dots per inch 的英文缩写，即每英寸点数； PPI 是 pixels per inch 的缩写，即每英寸像素。 它们都用来表示显示像素密度 (Display pixel density)。</p>

<p>计算机屏幕是由大量发光二极管整齐排列构成的集成电路，由于屏幕制造商工艺水平差异，每英寸集成电路上排列的二极管的数量会不一样，屏幕出厂时我们可以从厂商那里得知屏幕的 PPI。</p>

<p>于是我们可以知道:</p>

<pre><code>width or height of one device pixel = 1 / device's DPI  
</code></pre>

<p>例如 MacBook Air(2011) 的 DPI 为 125 ， 所以：</p>

<pre><code>(width or height of one device pixel) = 1/125 inch = 0.008 inch = 0.02032 cm
</code></pre>

<!--more-->


<h2>The CSS pixel (px)</h2>

<p>CSS像素的尺寸大致可以看成是人的肉眼能够舒适地看到的尺寸，不要太小，这样你就得眯着眼睛，也不要大到让你看到像素化。"看得很舒服 &ldquo; 的定义比较笼统，<a href="http://www.w3.org/TR/CSS2/syndata.html%23length-units">W3C CSS规范</a>中给我们一个推荐的参考。</p>

<blockquote><p>The reference pixel is the visual angle of one pixel on a device with a pixel density of 96 DPI and a distance from the reader of an arm’s length.</p></blockquote>

<h2>The viewing distance</h2>

<p>如前所述，观看距离因人而异，因设备而异，这就是为什么我们必须将设备按外形因素分类的原因。推荐的参考观看距离(&ldquo;一臂之长&rdquo;)和参考像素密度(&ldquo;96 DPI&rdquo;)其实是历史数据。</p>

<p>对于21世纪的日常设备，我们有不同的参考建议:</p>

<table>
<thead>
<tr>
<th> Device </th>
<th> Baseline pixel density </th>
<th> Width/height of one CSS pixel </th>
<th> Viewing distance</th>
</tr>
</thead>
<tbody>
<tr>
<td> A 20th century PC with CRT display </td>
<td> 96 DPI </td>
<td> ~0.2646 mm (1/96in) </td>
<td> 28 in (71.12cm) </td>
</tr>
<tr>
<td> Modern laptop with LCD </td>
<td> 125 DPI </td>
<td> 0.2032 mm (1/125in) </td>
<td> 21.5 in (54.61cm)</td>
</tr>
<tr>
<td> Smartphones/Tablets </td>
<td> 160 DPI </td>
<td> ~0.159mm (1/160 in) </td>
<td> 16.8in (42.672cm) </td>
</tr>
</tbody>
</table>


<p>因此，我们在 CSS 的世界里建立了一个基本的事实：一个 CSS 像素会以不同的物理尺寸显示，但它总是以正确的尺寸显示，让浏览者感到舒适。</p>

<h2>Device pixel ratio (DPPX)</h2>

<p>随着我们步入未来，现在很多智能手机在出厂时都采用了高密度的显示屏。为了保证 CSS 像素在每一个访问网络的设备(即一切有屏幕和网络连接的设备)上的尺寸一致，设备制造商不得不将多个设备像素映射到一个 CSS 像素上，以弥补它相对更大的物理尺寸。CSS 像素相对于设备像素的尺寸比就是设备像素比(DPPX)。</p>

<p>我们以 iPhone 4 为最著名的例子。它配备了一块 326 DPI 的显示屏。根据我们上面的表格，作为一款智能手机，它的典型观看距离是 16.8 英寸，它的基准像素密度是 160DPI。为了创建一个 CSS 像素，苹果选择将设备像素比设置为 2，这就等于让 iOS Safari 显示网页的方式和 163 DPI 手机上一样。</p>

<p>在我们继续之前，先回头看看上面的数字。其实我们可以做得更好，不把设备像素比设置为2，而是设置为<code>326/160=2.0375</code>，让一个 CSS 像素与参考尺寸相比完全一样。不幸的是，这样的比例会导致一个意想不到的结果：由于每个 CSS 像素并不是由整个设备像素来显示的，所以浏览器不得不对所有的位图图像、边框等进行反锯齿，因为它们几乎总是被当作整个 CSS 像素来显示。浏览器很难利用2.0375个设备像素来绘制你的1个CSS像素宽的边框：如果比例是简单的2，那就容易多了。</p>

<p>顺带一提，163 DPI恰好是上一代 iPhone 的像素密度，所以网页的工作方式也是一样的，不需要开发者对自己的网站进行任何特殊的"升级"。</p>

<p>设备制造商通常选择1.5，或2，或其他整数作为 DPPX 值。偶尔，有些设备决定不这么玩了，发货时使用1.325 DPPX这样的值；作为开发者，我们也许应该忽略这些设备。</p>

<p>现在我们就比较清楚 CSS pixel 和 device pixel 的关系了。接下来我们看下 iOS 的 point 和 device pixel 的关系。</p>

<h2>point</h2>

<blockquote><p>The coordinate system iOS uses to place content onscreen is based on measurements in points, which map to pixels in the display. A standard-resolution display has a <code>1:1</code> pixel density (or <code>@1x</code>), where one pixel is equal to one point. High-resolution displays have a higher pixel density, offering a scale factor of 2.0 or 3.0 (referred to as <code>@2x</code> and <code>@3x</code>). As a result, high-resolution displays demand images with more pixels.</p></blockquote>

<p>从 Apple 这段描述可知， scale factor (<code>@1x</code>, <code>@2x</code> 和 <code>@3x</code>) 就是我们上面据说的设备像素比（DPPX)。point 和 css pixel 是对应的。</p>

<h2>dp</h2>

<p>那 dp 和 device pixel 又是什么关系呢？</p>

<blockquote><p>To preserve the visible size of your UI on screens with different densities, you must design your UI using density-independent pixels (dp) as your unit of measurement. One dp is a virtual pixel unit that&rsquo;s roughly equal to one pixel on a medium-density screen (160dpi; the &ldquo;baseline&rdquo; density). Android translates this value to the appropriate number of real pixels for each other density.</p></blockquote>

<p>Google 这段描述更加直接，dp 是一个虚拟的像素单位，大致相当于中密度屏幕上的一个像素(160dpi;&ldquo;基线"密度)，所以 dp 和 css pixel 也是对应的。而 xhdpi, xxhdpi 和 xxxhdpi 是表示设备像素比(DPPX)2、3 和 4。</p>

<p>现在我们还剩下设计稿的 px。我们回忆一下在前端开发时，如果我们不指定图片尺寸而直接去显示设计师的切图，这时图片是有一个固有尺寸的，在设备像素比为1的设备上，这个固有尺寸就是图片的尺寸，而在设备像素比为2上尺寸是图片的尺寸除以2，所以设计稿的 px是对应设备像素(device pixel)的，这也是为什么我们需要提供多套图片来做适配。假设我们不提供多套图片，现在我们有一个 <code>100 x 100 css pixel</code>的图片， 在设备像素比为3的设备上也会去加载 <code>100 x 100 device pixel</code> 尺寸的资源图，按上面的分析，实际它应该加载 <code>300 x 300 device pixel</code> 尺寸的资源图，那么相当于资源图上一个像素点会对应显示三个设备像素点，这样可能会出现模糊或锯齿的情况。</p>

<p>理清了各平台尺寸单位的关系以及它们与设备像素的关系后，我们来看下设备尺寸。</p>

<h2>设备尺寸</h2>

<p>我们先看下 iOS 设备尺寸分布:</p>

<table>
<thead>
<tr>
<th> 型号 </th>
<th> points </th>
<th> 物理像素 </th>
<th style="text-align:center;"> 设备像素比(DPPX) </th>
</tr>
</thead>
<tbody>
<tr>
<td> 2G,3G,3GS </td>
<td> 320 x 480 </td>
<td> 320 x 480</td>
<td style="text-align:center;"> 1 </td>
</tr>
<tr>
<td> 4,4S </td>
<td> 320 x 480 </td>
<td> 640 x 960 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 5,5C,5S,SE </td>
<td> 320 x 568 </td>
<td> 640 x 1136 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 6,6S,7,8,SE2</td>
<td> 375 x 667 </td>
<td> 750 x 1334 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 6+,6S+,7+,8+ </td>
<td> 414 x 736 </td>
<td> 1080 x 1920 </td>
<td style="text-align:center;"> 3 </td>
</tr>
<tr>
<td> 11Pro,X,Xs </td>
<td> 375 x 812 </td>
<td> 1125 x 2436 </td>
<td style="text-align:center;"> 3 </td>
</tr>
<tr>
<td> 11, Xr </td>
<td> 414 x 896 </td>
<td> 828 x 1792 </td>
<td style="text-align:center;"> 2 </td>
</tr>
<tr>
<td> 11Pro Max,Xs Max </td>
<td> 414 x 896 </td>
<td> 1242 x 2688 </td>
<td style="text-align:center;"> 3 </td>
</tr>
</tbody>
</table>


<p>对于 iOS 来说，现在的主流设备应该是从 <code>6,6S,7,8,SE2</code> 开始，对应的设备像素是<code>750 x 1334 px</code>。</p>

<p>再来看下 android 这边， Google 有一个 <a href="https://developer.android.com/about/dashboards/index.html#Screens">Screen sizes and densities</a> 统计表，本文写作时查询的结果如下:</p>

<table>
<thead>
<tr>
<th> </th>
<th> ldpi </th>
<th> mdpi </th>
<th> tvdpi </th>
<th> hdpi </th>
<th> xhdpi </th>
<th> xxhdpi </th>
<th> Total </th>
</tr>
</thead>
<tbody>
<tr>
<td> Small </td>
<td> 0.1% </td>
<td>  </td>
<td>  </td>
<td> </td>
<td> 0.1% </td>
<td>  </td>
<td> 0.2% </td>
</tr>
<tr>
<td> Normal </td>
<td>  </td>
<td> 0.3% </td>
<td> 0.3% </td>
<td> 14.8% </td>
<td> 41.3% </td>
<td> 26.1% </td>
<td> 82.8% </td>
</tr>
<tr>
<td> Large </td>
<td>  </td>
<td> 1.7% </td>
<td> 2.2% </td>
<td> 0.8% </td>
<td> 3.2% </td>
<td> 2.0% </td>
<td> 9.9%  </td>
</tr>
<tr>
<td> Xlarge </td>
<td>  </td>
<td> 4.2% </td>
<td> 0.2% </td>
<td> 2.3% </td>
<td> 0.4% </td>
<td>  </td>
<td> 7.1% </td>
</tr>
<tr>
<td> Total </td>
<td> 0.1% </td>
<td> 6.2% </td>
<td> 2.7% </td>
<td>  17.9% </td>
<td> 45.0% </td>
<td> 28.1% </td>
<td>  </td>
</tr>
</tbody>
</table>


<p><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#ScreenSizeQualifier">Small,Normal,Large 和 Xlarge</a> 是屏幕的尺寸分类，具体含义如下:</p>

<blockquote><ul>
<li><p>small: Screens that are of similar size to a low-density QVGA screen. The minimum layout size for a small screen is approximately 320x426 dp units. Examples are QVGA low-density and VGA high density.</p></li>
<li><p>normal: Screens that are of similar size to a medium-density HVGA screen. The minimum layout size for a normal screen is approximately 320x470 dp units. Examples of such screens a WQVGA low-density, HVGA medium-density, WVGA high-density.</p></li>
<li><p>large: Screens that are of similar size to a medium-density VGA screen. The minimum layout size for a large screen is approximately 480x640 dp units. Examples are VGA and WVGA medium-density screens.</p></li>
<li><p>xlarge: Screens that are considerably larger than the traditional medium-density HVGA screen. The minimum layout size for an xlarge screen is approximately 720x960 dp units. In most cases, devices with extra-large screens would be too large to carry in a pocket and would most likely be tablet-style devices. Added in API level 9.</p></li>
</ul>
</blockquote>

<p>从上表的数据可知，目前 android 设备的主流尺寸分布是从 normal-hdpi 这个分类开始，根据 google 对 normal 的解释，它的大小相当于 medium-density HVGA 屏幕上的 <code>320x470 dp</code>，换算成设备像素就是 <code>480x705 px</code>，注意如果我们以这个尺寸去设计的话，那么得到的切图就是对应 hdpi(1.5)，要输出xhdpi(2) 的切图则要放大 1.3333 倍，这就有点不方便了，很容易得到奇数的像素尺寸，所以我们将 <code>480x705 px</code> 换算到 xhdpi(2) 的设备像素，得到 <code>640x940 px</code>。</p>

<p>我们知道宽屏比窄屏能显示更多内容，如果我们以宽屏为其准尺寸设计，那么在窄屏上就可能出现控件放不下、文字截断的情况。反过来，如果我们以窄屏为基准设计，那么在宽屏上布局时会容易处理，控件的宽度增加或者间隔增加就可以了。高度和宽度存在同样的问题，所以也应该选高度小的作为基准。设计时扣除固定元素高度之和后分配给可滚动区域，这样方便界面的元素布局能够动态响应，开发更好做屏幕适配。</p>

<p>所以选择基准尺寸和我们想支持的设备紧密相关，这需要基于多方面的因素考虑。 例如，如果我们希望支持尽可能多的设备，就越有可能获取更多用户，但开发的兼容工作量就相应增加，很多新特性就可能不适合作为应用的主要功能，而只适合作为增强功能。通常可以考虑覆盖 90% 以上，团队资金和人员比较充足的话可以考虑覆盖 95%，98% 甚至更多。</p>

<p>以覆盖 90% 以上为例，如果我们同时支持 iOS 和 android，或只支持 android 时，应该选 <code>640x940 px</code>作为基准尺寸，而如果只支持 iOS ， 我们应该选 <code>750 x 1334 px</code> 作为基准尺寸。</p>

<p>iOS 的设备像素比主要分布在2和3，而 android 这边设备像素比主要分布在 1.5(hdpi), 2(xhdpi)和 3(xxhdpi)，所以 iOS 需要输出<code>@2x</code> 和 <code>@3x</code> 两套切图； android 需要输出 hdpi, xhdpi 和 xxhdpi 三套切图。</p>

<h2>总结</h2>

<p>现在我们知道，设计基准尺寸的选择以及切图的输出是和我们想支持的设备紧密相关，写作本文时：</p>

<h3>基准尺寸</h3>

<ul>
<li>仅支持 iOS ， 应该选 <code>750 x 1334 px</code> 作为基准尺寸，对应的设备像素比是2</li>
<li>仅支持 android 时，应该选 <code>640x940 px</code> 作为基准尺寸，对应的设备像素比是2</li>
<li>支持 iOS 和 android，应该选 <code>640x940 px</code> 作为基准尺寸，对应的设备像素比是2</li>
</ul>


<h3>切图</h3>

<ul>
<li>支持 iOS 需要输出<code>@2x</code> 和 <code>@3x</code> 两套切图</li>
<li>支持 android 需要输出 hdpi, xhdpi 和 xxhdpi 三套切图</li>
</ul>


<p>基准尺寸对应的切图是 <code>@2x</code> 和 xhdpi，输出 hdpi(1.5) 则是切图缩小 0.75, <code>@3x</code> 和 xxhdpi(3) 则是切图放大 1.5 。</p>

<p>我们需要需要注意，随着设备的更新换代，我们的基准尺寸和切图会发生变化，就像以前我们可能需要为 android 提供 mdpi 的切图。</p>

<p>另外想说一下，设计师在设计之初就要把屏幕适配这事放在心上，将界面的元素看成水流一样，尽量让它们能自由流动，这样开发者就能更好地也更容易地做屏幕适配。Apple 在屏幕适配这块提出了 auto layout 的解决方案，这是一个设计师视角的解决方案，也是我们日常的生活中的视角，用界面元素的之间的约束来表达布局，推荐设计师用约束这种方式去做设计并最终输出。可以看到 google 实际上也很认可 auto layout 用约束来布局的想法，在新版本的 android 开发中默认的根布局容器就是 ConstraintLayout，它就是用约束来表达布局。最后我们再看 web 开发布局这边，css 布局的核心就是流，为支持屏幕适配，目前的主流方案是响应式布局，而这种布局的核心我认为仍然是约束。可以看到在屏幕适配这块，各平台最终的想法其实是一样的。</p>

<h1>Reference</h1>

<ul>
<li><a href="https://hacks.mozilla.org/2013/09/css-length-explained/">CSS Length Explained</a></li>
<li><a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution</a></li>
<li><a href="https://developer.android.google.cn/training/multiscreen/screendensities">Support different pixel densities</a></li>
<li><a href="https://developer.android.google.cn/guide/topics/resources/providing-resources#ScreenSizeQualifier">ScreenSizeQualifier</a></li>
<li><a href="https://developer.android.google.cn/training/multiscreen/screensizes">Support different screen sizes</a></li>
<li><a href="https://developer.android.com/about/dashboards/index.html#Screens">Screen sizes and densities</a></li>
<li><a href="https://www.paintcodeapp.com/news/ultimate-guide-to-iphone-resolutions">The Ultimate Guide To iPhone Resolutions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web API 的设计与开发--读书笔记]]></title>
    <link href="http://DamianSheldon.github.io/blog/notes-of-web-api-the-good-parts.html"/>
    <updated>2020-04-29T10:31:16+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/notes-of-web-api-the-good-parts</id>
    <content type="html"><![CDATA[<p>Web API 的设计与开发是开发者日常工作的重要内容，我们该如何来做好这项工作呢？我觉得一个务实的方法是先参考前辈们的做法，也就是站在巨人的肩上，理解消化后再尝试去突破，这样可能会事半功倍。经过一番搜索，找到了 <code>&lt;&lt;Web API 的设计与开发&gt;&gt;</code>， 我个人觉得这是一本对 Web API 进行全面、细致和深入剖析的书，对 Web API 的设计与开发很有帮助，值得一读。</p>

<p>书的内容是按照整分的逻辑组织，并依先易后难的顺序来讲解相关知识。下面我按自己的理解尝试对书中内容做个简单的总结。</p>

<p>Web API 是用于完成某种需求，由于需求会变化，所以一次就设计出完美 Web API 的想法是不现实的，所以一开始应该要给 Web API 的更改留有余地，这是很容易忽视的地方。推荐的做法是在 URI 中嵌入版本信息，典型的形式是 <code>http://api.linkedin.com/v1/people</code>。</p>

<p>虽然一次就完美地设计 Web API 的想法不现实，但我们还是想尽量做好，减少 Web API 版本变更的次数，毕竟版本越多维护成本越高，那么我们该如何设计 Web API 呢？</p>

<p>Web API 通过 HTTP 协议来完成通信，在设计时我们应该最大程度地利用 HTTP 协议规范。基于标准协议设计的 API 至少要比使用私有协议设计的 API 更容易理解，还会减少使用时引入的 bug，使你的 API 得到更广泛的使用，提高利用已有的程序库或代码的可能。</p>

<p>有了整体设计原则后，我们来看下具体的请求和响应设计。API 的功能是为了完成项目的需求，最完备的请求会包含请求端点、请求方法、请求参数和请求数据体(Request Body)，我们依次来审视请求的每个部分。</p>

<p>端点是指用于访问 API 的 URI，普适又重要的设计原则有：</p>

<ul>
<li>短小便于输入的 URI</li>
<li>人可以读懂的 URI</li>
<li>没有大小写混用的 URI</li>
<li>不会暴露服务端架构的 URI</li>
<li>规则统一的 URI</li>
</ul>


<p>端点设计的注意事项：</p>

<ul>
<li>使用名词的复数形式</li>
<li>注意所用的单词</li>
<li>不使用空格及需要编码的字符</li>
<li>使用连字符来连接多个单词</li>
</ul>


<p>URI 和 HTTP 方法之间的关系可以认为是操作对象和操作方法的关系。如果把 URI 当作 API(HTTP) 的 “操作对象 = 资源”， HTTP 方法则表示 “进行怎样的操作”。通过用不同方法访问同一个 URI 端点，不但可以获取信息，还能修改信息、删除信息等，这样的思想正成为 Web API 设计的主流方式。</p>

<table>
<thead>
<tr>
<th> 方法名 </th>
<th> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td> GET </td>
<td> 获取资源 </td>
</tr>
<tr>
<td> POST </td>
<td> 新增资源 </td>
</tr>
<tr>
<td> PUT </td>
<td> 覆盖已有资源 </td>
</tr>
<tr>
<td> DELETE </td>
<td> 删除资源 </td>
</tr>
<tr>
<td> PATCH </td>
<td> 更新部分资源 </td>
</tr>
<tr>
<td> HEAD </td>
<td> 获取资源的元信息 </td>
</tr>
</tbody>
</table>


<p>有时请求可能还需要传递参数，在设计 URI 时，必须决定是把特定参数放在查询参数里还是路径里，决策的依据有以下两点：</p>

<ul>
<li>是否是表示唯一资源所需的信息</li>
<li>是否可以省略</li>
</ul>


<p>请求数据体，个人认为可以采用面向对象编程的思想来设计，整个处理过程会轻松很多。</p>

<p>说完请求，让我们来看下响应。首先是正确使用状态码，国内由于历史原因遗留下来无论请求是否成功都一律返回 200 的问题，全站切换到 HTTPS 后，我们还是应该最大程度地利用 HTTP 规范，这样我们能受益于通用的 HTTP 程序库，减轻客户端的负担。</p>

<p>其次是数据格式，这里的数据格式是指该用怎样的形式来描述 API 返回的结构化数据，具体而言就是指 JSON、XML 等数据格式。关于这一点，事实上几乎没有可讨论的，因为我们通常就是使用 JSON 作为默认的数据格式，若有需求 API 也可以支持 XML 的格式，这是最贴近现实的做法。</p>

<p>再次是数据内部结构，我们重点看下数据应该以数组还是对象返回，作者更推荐使用对象来封装数据的方式，因为该方式有如下几个优点:</p>

<ul>
<li>更容易理解响应数据表示什么</li>
<li>响应数据通过对象的封装实现了结构统一</li>
<li>可以避免安全方面的风险</li>
</ul>


<p>从次是各个数据的格式，各个数据项组成了最终的数据，只有掌握了如何处理单个数据项格式才能设计出合理的响应体数据格式。作者重点介绍了如何描述性别数据、日期格式和大整数，受益匪浅。</p>

<p>最后是出错信息的表示，同样，我们需要选择合适的状态码，出误信息建议以消息体的形式返回，出错信息应该包含详细的错误代码、人们能够读懂的相关信息，以及记载有详细说明的文档页面的 URI，如下所示：</p>

<pre><code>{
    "error": {
        "code": 2013,
        "message": "Bad authentication token",
        "info": "http://docs.example.com/api/v1/authentication"
    }
}
</code></pre>

<p>如果想支持描述多个错误同时发生，可以返回出错信息数组，</p>

<pre><code>{
    "errors": [
        {
            "code": 2013,
            "message": "Bad authentication token",
            "info": "http://docs.example.com/api/v1/authentication"
        }
    ]
}
</code></pre>

<p>以上是基础内容，作者最后还介绍进阶内容，开发牢固的 Web API，对我们把 Web API 设计和开发提高到新高度有非常大的帮助。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析移动端跨平台开发]]></title>
    <link href="http://DamianSheldon.github.io/blog/an-introduction-to-mobile-cross-platform-development.html"/>
    <updated>2019-04-15T17:04:39+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/an-introduction-to-mobile-cross-platform-development</id>
    <content type="html"><![CDATA[<p>最近几年随着移动端开发日益成熟以及 Web 技术的快速发展，跨平台开发技术如雨后春笋一般冒出来，这是所有从业者不能忽视的现象。这种现象导致很多公司主动或被动去研究相关的技术。我也不例外，对它的研究应该是夹杂着被动和主动。作为原生开发者，本来对日常的开发工作驾轻就熟，恐怕内心本身不会有太多意愿去迁移到新的技术，至少我一开始是这种心态；另一方面，跨平台开发在行业内日益受到关注，倒逼开发者去了解它、研究它。对于变化，我们可能本能的抗拒，但内心理性的声音告诉我们：变化是永恒的不变，我们应该拥抱变化。</p>

<p>在经过一段时间的学习和研究，自己觉得对它的认识更加清晰和深刻，于是决定将它们记下来，以便日后记忆模糊了帮助回忆，也可以验证对于它发展的看法。我这里主要谈谈自己对它的看法，技术选择，以及这种技术的基本使用流程。</p>

<p>跨平台开发不是什么新概念，我觉得这是一种很自然的想法。因为我们总是想减轻自己的工作负担，公司则会想减少成本，提高效率，于是就会想能不能一套代码跑到多个平台，两套代码合并成一套，应该可以删除掉不少重复代码，开发和维护的代码量就少了，可能也不需要那么多开发人员了，应该来说还是很有吸引力的。</p>

<p>不过我觉得问题不像看起来那么简单。上面提到了很多跨平台开发的优点，但它也有自己的缺点。而且看到很多二变为一，很容易认为是在减少，加上业界大厂分享的成功经验，更是验证这种想法。但我想强调具体情况具体分析，这里有一个很重要的点，我们所在的公司开发人员水平和大厂肯定是不一样的，所以它能取得成功，我们不一定能玩得转。所以当两套代码合并成一套，在大厂可能确实减少了开发和维护工作，但我们自己的情况可能就不一定了，因为这对开发人员的技术水平要求要高不少，这是需要考虑的一个问题。当我们在一些项目上使用跨平台技术开发时，如果能本着实事求是的态度，相信会更容易成功。有了这些认识，接下来，我们具体来看看跨平台开发技术。</p>

<p>当我们想跨平台时，我们就会寻找平台的共同之处，应该来讲目光很容易聚焦到 Web 技术上。移动端都可以使用 Web 技术，而且它在桌面端已经实现，可以说是一个不错的选择，于是就可以尝试从这里突破。本质上其实就是 Web 应用，我们要做是将设备的能力提供给 Web，Cordova 则是这方面的一个代表。</p>

<p>我认为移动端 Web 应用的主要问题还是性能，虽然现在硬件性能很强悍，但是很多 Web 应用和原生的体验还是有不小差别，所以这时就要权衡了。那能不能有个完美的解决方案呢？既然性能有问题，我们是不可以想办法优化性能，让它和原生体验一样？我认为 React Native 是顺着这种思路出现的，它使用 javascript 编码，最终设备上运行的是原生代码，即然是运行原生代码，性能自然可以做到和原生一致。虽然性能问题是解决了，但它需要用 javascript 编写多套代码，而且开发人员也要懂原生开发，或者有原生开发支持，不然遇到问题恐怕不好解决。</p>

<!--more-->


<p>除了 Cordova 和 React Native，Google 最近还推出 Flutter，由于技术栈差异很大，以及个人精力有限，暂时不打算研究。我决定在 Cordova 和 React Native 中选择。React Native 虽然性能不错，但各平台需要自己的代码，这和一份代码的初衷不符；另外它动态部署事件的能力也稍逊一筹，框架本身的发展和原生藕合很紧密。基于这些原因，我偏向选择 Cordova。</p>

<p>Cordova 让 Web 访问设备的能力比较方便，屏蔽了很多差异，但是它没有提供 UI 支持，如果我们想做出漂亮的界面，需要自己做，或者更好的办法是找一个好用的 UI 库。而且最好是搭配一个 SPA 框架，因为我们的应用通常不会只有一个界面，SPA 可以帮助我们在单个 WebView 里实现应用的功能。至此我们的脉络应该是比较清晰了，综合这些信息，我觉得 ionic 是个不错的选择。对于原生开发者，我们一开始可能对 Web 技术不是很熟悉，ionic 将相关技术整合在一起，这降低了学习的门槛。说到这里，我想起在前期，在搜索过程中，很多国产的跨平台技术映入眼帘，如 APICloud, DCloud,但我觉得技术群众基础也很重要，这样我们学的技术在其他公司能有用武之地，也容易招到合适的人才，综合考虑便没有选择这些技术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS App Distribution]]></title>
    <link href="http://DamianSheldon.github.io/blog/ios-app-distribution.html"/>
    <updated>2018-12-04T14:33:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ios-app-distribution</id>
    <content type="html"><![CDATA[<p>iOS App 有不少分发方法，她们散落在 Apple 的文档中，并未归总到一处，所以本文对她们进行了总结，方便查阅。</p>

<p>首先我们简单梳理下这些分发方法，然后重点说明下 ipa 文件的安装方法。 Apple 制作的这张表格将分发方法归纳得很全：</p>

<table>
<thead>
<tr>
<th> Method </th>
<th style="text-align:left;"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td> App Store </td>
<td style="text-align:left;"> Distributes your app through the App Store, signed with an Apple Developer Program distribution provisioning profile. </td>
</tr>
<tr>
<td> Ad Hoc </td>
<td style="text-align:left;"> Distributes your app to testers with registered devices, signed with an ad hoc provisioning profile.<br>The devices need to be registered in your developer account and are limited to 100 devices per product family per year. If you don’t want to use a portion of these development devices for testing, distribute your app using TestFlight instead.<br>If you are a member of the Apple Developer Enterprise Program, choose this option to test your app. Only members of the Apple Developer Program have access to App Store Connect and TestFlight. </td>
</tr>
<tr>
<td> Development </td>
<td style="text-align:left;"> Distributes your app to testers with registered devices, signed with a development provisioning profile. </td>
</tr>
<tr>
<td> Enterprise </td>
<td style="text-align:left;"> Distributes your app to users in your organization, signed with an Apple Developer Enterprise Program distribution provisioning profile. </td>
</tr>
</tbody>
</table>


<p>虽然分发方法有很多，但可以分为两类：一类是通过 App Store 分发；另一类则是在 App Store 外分发。通过 App Store 分发时的流程很统一，都是上传应用到 iTunes Connection，等待审核发布，所以没有什么好说的。但是在 App Store 外发布时选择就多样了，我们既可以走像 App Store 分发那样流程的 TestFlight，也可以导出 ipa 文件然后安装。</p>

<p>下面我们介绍在 iPhone 上安装 ipa 的方法：</p>

<h2>Install using iTunes</h2>

<blockquote><p>iTunes 12.7 for Mac was released on Tuesday with a major change in the app. Apple has redesign iTunes so that it focuses on sales of music, movies, TV shows, audiobooks, and podcasts. It no longer has an App Store for buying apps for your iPhone or iPad. Therefore, you can no long install your iOS App (.ipa file) through iTunes any longer.</p></blockquote>

<ol>
<li>Download the .ipa file after the build completes.</li>
<li>Open iTunes, go to App library.</li>
<li>Drag and drop the downloaded .ipa file into the App library.</li>
<li>Connect your device to iTunes and go to your device apps.</li>
<li>Click Install button of the app and click Sync button. </li>
</ol>


<!--more-->


<h2>Install using Apple Configurator 2</h2>

<ol>
<li>Install Apple Configurator 2 on your Mac from the App Store.</li>
<li>Connect your device to your Mac.</li>
<li>Open Apple Configurator 2, select your device. If you device doesn’t appear here, please make sure that your device is successfully connected to your Mac.</li>
</ol>


<h2>Install using Xcode</h2>

<ol>
<li>Connect your device to your Mac.</li>
<li>Open Xcode, go to Window > Devices .</li>
<li>Then, the Devices screen will appear. Choose the device you want to install the app on.</li>
<li>Drag and drop your .ipa file into the Installed Apps.</li>
</ol>


<h2>Install using OTA Deployment</h2>

<p>OTA (Over-The-Air) Deployment enables you to install your built apps (ad-hoc build) via HTTPS.</p>

<ol>
<li>Download the .ipa file after the build completes.</li>
<li>Upload the .ipa file to the site you want.</li>
<li>Create a .plist file for this built application. The .plist file should look like this:</li>
</ol>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
</span><span class='line'>&lt;!DOCTYPE plist PUBLIC &ldquo;-//Apple//DTD PLIST 1.0//EN&rdquo; &ldquo;&lt;a href="http://www.apple.com/DTDs/PropertyList-1.0.dtd">http://www.apple.com/DTDs/PropertyList-1.0.dtd&lt;/a>&rdquo;>
</span><span class='line'>&lt;plist version="1.0">
</span><span class='line'>&lt;dict>
</span><span class='line'>    &lt;key>items&lt;/key>
</span><span class='line'>    &lt;array>
</span><span class='line'>        &lt;dict>
</span><span class='line'>            &lt;key>assets&lt;/key>
</span><span class='line'>            &lt;array>
</span><span class='line'>                &lt;dict>
</span><span class='line'>                    &lt;key>kind&lt;/key>
</span><span class='line'>                    &lt;string>software-package&lt;/string>
</span><span class='line'>                    &lt;key>url&lt;/key>
</span><span class='line'>                    &lt;string>&lt;a href="https://www.anysite.com/application/your_app.ipa">https://www.anysite.com/application/your_app.ipa&lt;/a>&lt;/string>
</span><span class='line'>                &lt;/dict>
</span><span class='line'>            &lt;/array>
</span><span class='line'>            &lt;key>metadata&lt;/key>
</span><span class='line'>            &lt;dict>
</span><span class='line'>                &lt;key>bundle-identifier&lt;/key>
</span><span class='line'>                &lt;string>com.example.helloworld&lt;/string>
</span><span class='line'>                &lt;key>bundle-version&lt;/key>
</span><span class='line'>                &lt;string>1.0.0&lt;/string>
</span><span class='line'>                &lt;key>kind&lt;/key>
</span><span class='line'>                &lt;string>software&lt;/string>
</span><span class='line'>                &lt;key>title&lt;/key>
</span><span class='line'>                &lt;string>HELLO&lt;/string>
</span><span class='line'>            &lt;/dict>
</span><span class='line'>        &lt;/dict>
</span><span class='line'>    &lt;/array>
</span><span class='line'>&lt;/dict>
</span><span class='line'>&lt;/plist>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<ol>
<li>Upload the <code>.plist</code> file to the site you want. Make sure this file must be accessed via HTTPS protocol. </li>
<li>Create a webpage embedded the link to the uploaded <code>.plist</code> file using special <code>itms-services://</code> protocol. See blow example: 
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/li>
</span><span class='line'>&lt;/ol>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>&lt;a href="itms-services://?action=download-manifest&url=https://example.com/manifest.plist">Install App&lt;/a></span></code></pre></td></tr></table></div></figure></p>

<p>使用 OTA 方式部署安装，需要自己架设 Web 服务器，目前市面上也有免费提供此安装服务的产品，如 <a href="https://fir.im/">Fir.im</a>，<a href="https://www.pgyer.com/">蒲公英</a>。</p>

<p>如果我们希望自己架设 Web 服务器来提供 OTA 分发，则相应地需要做些配置工作：</p>

<h2>HTTPS</h2>

<p>保证 ipa 文件是通过 HTTPS 访问，所以网站必须是由 iOS 信任的证书签名的。如果是没有信任锚的自签名证书，并且不能被 iOS 设备验证，那么安装会失败。</p>

<h2>Set server MIME types</h2>

<p>你也许需要配置你的 web 服务器以便清单文件和应用文件能正确传输。</p>

<p>For the server, add the MIME types to the web service’s MIME types settings:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>application/octet-stream ipa 
</span><span class='line'>text/xml plist</span></code></pre></td></tr></table></div></figure> 
For Microsoft’s Internet Information Server (IIS), use IIS Manager to add the MIME type in the Properties page of the server:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>.ipa application/octet-stream 
</span><span class='line'>.plist text/xml</span></code></pre></td></tr></table></div></figure> </p>

<p>同时，如果设备是连接到一个封闭的内部网络，我们必须保证如下访问：</p>

<h2>Network configuration requirements</h2>

<ul>
<li><a href="https://ax.init.itunes.apple.com:">https://ax.init.itunes.apple.com:</a> The device obtains the current file-size limit for downloading apps over the cellular network. If this website isn’t reachable, installation may fail. </li>
<li><a href="https://ppq.apple.com:">https://ppq.apple.com:</a> The device contacts this website to check the status of the distribution certificate used to sign the provisioning profile. </li>
</ul>


<h1>Reference</h1>

<ul>
<li><p><a href="https://help.apple.com/xcode/mac/current/#/dev31de635e5">Distribution methods</a></p></li>
<li><p><a href="https://web.archive.org/web/20171114184350/https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582-CH1-SW1">App Distribution Guide</a></p></li>
<li><p><a href="https://docs.monaca.io/en/products_guide/monaca_ide/deploy/non_market_deploy/#install-using-ota-deployment">Non-market App Distribution</a></p></li>
<li><p><a href="https://help.apple.com/deployment/ios/#/apda0e3426d7">Distribute in-house apps from a web server</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Blocks 的实现]]></title>
    <link href="http://DamianSheldon.github.io/blog/the-implementation-of-blocks.html"/>
    <updated>2018-09-01T15:42:34+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/the-implementation-of-blocks</id>
    <content type="html"><![CDATA[<p>Block 的实现是面试中高频出现的问题，背后的原因我想是希望借此考察面试者对 Block 的掌握程度，在日后的工作中能够用好它；同时能从侧面反映面试者有没有深入钻研技术，以及独立思考能力如何，可谓一举多得。</p>

<p>下面我们就来看看 ObjC 中的 Blocks 是如何实现。Clang 的 <code>-rewrite-objc</code> 选项可以将含有 Block 语法的源代码转换为 C++，说是 C++，其实也仅使用了 struct 结构，其本质是 C 语言。</p>

<p>下面我们先转换一个简单的文件试试:</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, char ** argv)
{
    @autoreleasepool {
        void (^blk)(void) = ^{
            printf("Block\n");
        };

        blk();
    }    

    return 0;
}

// 使用命令:
$ clang -fobjc-arc -ObjC -rewrite-objc -mios-version-min=6.0.0 -fobjc-runtime=ios-6.0.0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.3.sdk -arch arm64 block-essense.m  -o block-essense-in-c.c

//限于篇幅，省略不相关的部分，结果如下:
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {

            printf("Block\n");
        }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, char ** argv)
{
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));

        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    }

    return 0;
}
</code></pre>

<!--more-->


<p>可以看到持有 block 的变量实际上就是指针，而 block 本身则是结构体，在我们的例子中对应的是 <code>__main_block_impl_0</code>,功能代码则是通过函数来实现的，block 结构体内有成员变量指向该函数，这样我们对 block 的实现渐渐清晰起来了。</p>

<p>Block 有一个重要的特性&ndash;自动捕获变量。这又是怎么实现的呢？我们同样可以使用上述的方法来得到答案。我们构造一个捕获变量的例子，然后来查看它的结果：</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, char ** argv)
{
    @autoreleasepool {

        BOOL flag = YES;
        int i = 28;
        float pi = 3.1415;
        char c = 'x';

        void (^blk)(void) = ^{
            printf("Block\n");
            printf("flag:%d\n", flag);
            printf("i:%d\n", i);
            printf("pi:%d\n", pi);
            printf("c:%d\n", c);
        };

        blk();
    }

    return 0;
}

// 转换之后相关部分
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  BOOL flag;
  int i;
  float pi;
  char c;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, BOOL _flag, int _i, float _pi, char _c, int flags=0) : flag(_flag), i(_i), pi(_pi), c(_c) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  BOOL flag = __cself-&gt;flag; // bound by copy
  int i = __cself-&gt;i; // bound by copy
  float pi = __cself-&gt;pi; // bound by copy
  char c = __cself-&gt;c; // bound by copy

            printf("Block\n");
            printf("flag:%d\n", flag);
            printf("i:%d\n", i);
            printf("pi:%d\n", pi);
            printf("c:%d\n", c);
        }

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, char ** argv)
{
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        BOOL flag = ((bool)1);
        int i = 28;
        float pi = 3.1415;
        char c = 'x';

        void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, flag, i, pi, c));

        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    }

    return 0;
}
</code></pre>

<p>可以看到自动捕获的标量数据是直接声明为 block 结构体的成员变量。</p>

<p>除了读取捕获自动变量的值，block 还支持使用 <code>__block</code> 修饰符来修改自动捕获的变量。我们同样来看个例子：</p>

<pre><code class="objc">#import &lt;Foundation/Foundation.h&gt;

int main(int argc, char ** argv)
{
    @autoreleasepool {

        __block BOOL flag = YES;
        __block int i = 28;
        __block float pi = 3.1415;
        __block char c = 'x';

        void (^blk)(void) = ^{
            printf("Block\n");

            flag = NO;
            i = 88;
            pi = 3.1415926;
            c = 'a';

            printf("flag:%d\n", flag);
            printf("i:%d\n", i);
            printf("pi:%f\n", pi);
            printf("c:%d\n", c);
        };

        blk();
    }

    return 0;
}

// 转换之后相关部分的结果:
struct __Block_byref_flag_0 {
  void *__isa;
__Block_byref_flag_0 *__forwarding;
 int __flags;
 int __size;
 BOOL flag;
};
struct __Block_byref_i_1 {
  void *__isa;
__Block_byref_i_1 *__forwarding;
 int __flags;
 int __size;
 int i;
};
struct __Block_byref_pi_2 {
  void *__isa;
__Block_byref_pi_2 *__forwarding;
 int __flags;
 int __size;
 float pi;
};
struct __Block_byref_c_3 {
  void *__isa;
__Block_byref_c_3 *__forwarding;
 int __flags;
 int __size;
 char c;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_flag_0 *flag; // by ref
  __Block_byref_i_1 *i; // by ref
  __Block_byref_pi_2 *pi; // by ref
  __Block_byref_c_3 *c; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_flag_0 *_flag, __Block_byref_i_1 *_i, __Block_byref_pi_2 *_pi, __Block_byref_c_3 *_c, int flags=0) : flag(_flag-&gt;__forwarding), i(_i-&gt;__forwarding), pi(_pi-&gt;__forwarding), c(_c-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_flag_0 *flag = __cself-&gt;flag; // bound by ref
  __Block_byref_i_1 *i = __cself-&gt;i; // bound by ref
  __Block_byref_pi_2 *pi = __cself-&gt;pi; // bound by ref
  __Block_byref_c_3 *c = __cself-&gt;c; // bound by ref

            printf("Block\n");

            (flag-&gt;__forwarding-&gt;flag) = ((bool)0);
            (i-&gt;__forwarding-&gt;i) = 88;
            (pi-&gt;__forwarding-&gt;pi) = 3.1415926;
            (c-&gt;__forwarding-&gt;c) = 'a';

            printf("flag:%d\n", (flag-&gt;__forwarding-&gt;flag));
            printf("i:%d\n", (i-&gt;__forwarding-&gt;i));
            printf("pi:%f\n", (pi-&gt;__forwarding-&gt;pi));
            printf("c:%d\n", (c-&gt;__forwarding-&gt;c));
        }
static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;flag, (void*)src-&gt;flag, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;pi, (void*)src-&gt;pi, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_assign((void*)&amp;dst-&gt;c, (void*)src-&gt;c, 8/*BLOCK_FIELD_IS_BYREF*/);}

static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;flag, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;pi, 8/*BLOCK_FIELD_IS_BYREF*/);_Block_object_dispose((void*)src-&gt;c, 8/*BLOCK_FIELD_IS_BYREF*/);}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
int main(int argc, char ** argv)
{
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        __attribute__((__blocks__(byref))) __Block_byref_flag_0 flag = {(void*)0,(__Block_byref_flag_0 *)&amp;flag, 0, sizeof(__Block_byref_flag_0), ((bool)1)};
        __attribute__((__blocks__(byref))) __Block_byref_i_1 i = {(void*)0,(__Block_byref_i_1 *)&amp;i, 0, sizeof(__Block_byref_i_1), 28};
        __attribute__((__blocks__(byref))) __Block_byref_pi_2 pi = {(void*)0,(__Block_byref_pi_2 *)&amp;pi, 0, sizeof(__Block_byref_pi_2), 3.1415};
        __attribute__((__blocks__(byref))) __Block_byref_c_3 c = {(void*)0,(__Block_byref_c_3 *)&amp;c, 0, sizeof(__Block_byref_c_3), 'x'};

        void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_flag_0 *)&amp;flag, (__Block_byref_i_1 *)&amp;i, (__Block_byref_pi_2 *)&amp;pi, (__Block_byref_c_3 *)&amp;c, 570425344));

        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    }

    return 0;
}
</code></pre>

<p>可以看到使用 <code>__block</code> 修饰的变量实际上转换成了结构体变量，同样在 block 结构体中有成员变量指向它们。</p>

<p>上面我们看过了使用 block 时的几种情况，我们可以尝试来总结使用 block 的情况，然后查看各种情况转换之后的代码来进一步探索 block 的实现，进而得到比较完善的答案。</p>

<p>首先 block 可以按是否捕获变量分为两大类，其次捕获变量时根据是否支持修改又可以分为两类，最后捕获变量又可以分为程序的数据区域、栈上和堆上三种情况。综上，我们可以得到得到如下的 block 分类列表:</p>

<ul>
<li>不捕获变量(1)</li>
<li><p>捕获变量</p>

<ul>
<li><p>不修改捕获的变量</p>

<ul>
<li>存在程序数据区的变量(2)</li>
<li>存在栈上的变量(3)</li>
<li>存在堆上的变量(4)</li>
</ul>
</li>
<li><p>修改捕获的变量(<code>__block</code> 修饰的变量)</p>

<ul>
<li>存在程序数据区的变量(5)</li>
<li>存在栈上的变量(6)</li>
<li>存在堆上的变量(7)</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>这样算下来应该是存在七种情况，我们可以分别构造各种情况的例子，然后得到 block 的实现全貌。</p>

<p>全局变量和 static 变量是程序数据区变量，block 中访问全局变量和在其他地方没有什么不同，所以 block 的实现中不需要对它进行特别考虑。Static 变量在捕获时会在 block 结构体中有对应的成员变量，可以用该成员变量来读写。由于它在程序的生命周期中一直存在，所以当 block 捕获并修改它时，不需要生成对应的结构体变量，这和其他 <code>__block</code> 修饰的变量不同。</p>

<p>情况三和四比较类似，它们都会在 block 结构体中增加相应的成员变量，不同之处是捕获堆上的变量， block 的描述结构体变量中会增加 copy 和 dipose 函数，用来管理对应的内存。</p>

<p>情况六和七也类似，它们都是将变量转换为结构体，然后在 block 结构体增加成员变量指向它们。捕获堆上的变量时，block 内的成员变量指向变量，而这个变量是指向堆上分配的一块内存的，也就是一个对象，对象就是一块内存区域嘛，用代码示例如下：</p>

<pre><code class="objc">blk_t blk;

{
  __block id __strong array = [[NSMutableArray alloc] init];

  blk = [^(id obj){

      [array addObject:obj];
      NSLog(@"array count = %ld", [array count]);

  } copy];
}

// __block 修饰指向 array 的变量
struct __Block_byref_array_0 {
  void *__isa;
__Block_byref_array_0 *__forwarding;
 int __flags;
 int __size;
 void (*__Block_byref_id_object_copy)(void*, void*);
 void (*__Block_byref_id_object_dispose)(void*);
 __strong id array;
};

// 表示 block 的结构体
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_array_0 *array; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_array_0 *_array, int flags=0) : array(_array-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre>

<p>看到这里，我们有了 block 捕获变量出了作用域后还能存在原因的线索，当表示 block 的结构体从栈上拷贝到堆上，如果是只读变量，它的值赋值给 block 结构体的成员变量了；如果是 <code>__block</code> 修饰的变量，表示该变量的结构体也会一并拷贝到堆上，并由 block 持有和管理。</p>

<p>至此，我们应该对 block 的实现比较清晰了。</p>

<h2>Reference</h2>

<ul>
<li>Objective-C 高级编程</li>
</ul>

]]></content>
  </entry>
  
</feed>
