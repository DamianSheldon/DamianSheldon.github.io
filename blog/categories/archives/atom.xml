<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-11-11T16:35:19+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(翻译)iOS 设计模式]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/10/ios-design-patterns/"/>
    <updated>2014-11-10T08:35:43+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/10/ios-design-patterns</id>
    <content type="html"><![CDATA[<p>iOS设计模式&mdash;你也许听说过这个术语，但是你知道它意味着什么吗？尽管大多数开发者可能同意设计模式非常重要，但关于它的文章并不多，咱们开发者们写代码时并没有花大多注意力放到设计模式上。</p>

<p>在软件设计中设计模式是对常见问题的可复用的解决方法。他们被设计成模板帮助你写出容易理解和复用的代码。他们也帮助你写出低藕合的代码以便你不需要太多争论就能改变或替换你代码的组件。</p>

<p>如果你刚刚接触设计模式，告诉你些好消息！首先，你已经使用过很多设计模式，这得感谢Cocoa建立的方式以及你被鼓励使用的最佳实践。其次，这篇教程将让你掌握iOS的主要（次要）设计模式，它们在Cocoa中很常用。</p>

<p>教程分成多个部分，每部分包含一种设计模式。在每部分，你会看到如下顺序的解释：</p>

<ul>
<li>该设计模式是什么；</li>
<li>你为什么应该使用它；</li>
<li>如何使用它，以及什么场景合适，使用时需要留意的常见陷阱；</li>
</ul>


<p>这篇教程中，你将创建一个Music Library应用，它会显示你的专辑和它们相关的信息。</p>

<p>在开发应用的过程中，你会慢慢熟悉多数常见的Cocoa设计模式：</p>

<ul>
<li>构造类：单例(Singleton)和 抽象工厂(Abstract Factory);</li>
<li>架构类：模型-视图-控制器(MVC), 修饰(Decorator), 适配器(Adapter), 门面(Facade)和合成（Composite);</li>
<li>行为类：观察者(Observer), 记忆(Memento), 响应链(Chain of Responsibility)和命令（Command）。</li>
</ul>


<p>别被误导认为这是篇纯理论的文章；你会在你音乐应用中使用这些应用模式中的大多数。你的应用最终看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="finalapp-180x320" src="http://DamianSheldon.github.io/images/finalapp-180x320.png" width="180" height="320">  

</div>


<h3>开始吧</h3>

<p>下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/BlueLibrary-Starter.zip">启动工程</a>,解压ZIP文件内容，然后在Xcode中打开。</p>

<p>里面内容不多，仅仅是默认的ViewController和一个未实现的简单HTTP客户端。</p>

<p><strong>Note</strong>:你知道吗？当你创建一个新的工程你的代码就已经符合设计模式了。MVC, Delegate, Protocol, Singleton&mdash;你免费得到全部！:]</p>

<p>在你深入第一个设计模式之前，你必须创建两个类去持有和显示专辑数据。</p>

<p>导航到<strong>“File\New\File…”</strong>(或简单地按Command+N)。选中<strong>iOS > Cocoa Touch</strong>，然后<strong>Objective-C class</strong>和单击<strong>Next</strong>。设置类名为<strong>Album</strong>并继承<strong>NSObject</strong>。单击<strong>Next</strong>然后<strong>Create</strong>。</p>

<p>打开<strong>Album.h</strong>，然后添加如下属性和方法原型到<strong>@interface</strong> 和 <strong>@end</strong>间:</p>

<p>```
@property (nonatomic, copy, readonly) NSString <em>title, </em>artist, <em>genre, </em>coverUrl, *year;</p>

<ul>
<li>(id)initWithTitle:(NSString<em>)title artist:(NSString</em>)artist coverUrl:(NSString<em>)coverUrl year:(NSString</em>)year;
```</li>
</ul>


<p>注意到所有的属性都是可读的，因为Album对象被创建之后不需要被改变。</p>

<p>方法是对象的初始化方法。当你创建一个新alum，你将传入album name, artist, album cover URL和year。</p>

<p>现在打开<strong>Album.m</strong>,添加下列代码到<strong>@implementation</strong>和<strong>@end</strong>中间:</p>

<p>```
&ndash; (id)initWithTitle:(NSString<em>)title artist:(NSString</em>)artist coverUrl:(NSString<em>)coverUrl year:(NSString</em>)year
{</p>

<pre><code>self = [super init];
if (self)
{
    _title = title;
    _artist = artist;
    _coverUrl = coverUrl;
    _year = year;
    _genre = @"Pop";
}
return self;
</code></pre>

<p>}
```</p>

<p>这里没有什么神奇的；仅仅是一个简单的init方法去创建一个新Album实例。</p>

<p>再次导航到<strong>File\New\File…</strong>。选择<strong>Cocoa Touch</strong>然后<strong>Objective-C class</strong>，点击<strong>Next</strong>。设置类名为<strong>AlbumView</strong>，但是这次设置它为<strong>UIView</strong>的子类。点击<strong>Next</strong>然后<strong>Create</strong>。</p>

<p><strong>Note</strong>:如果你发现快捷键更容易用的话，<strong>Command+N</strong>将创建新的文件，<strong>Command+Option+N</strong>将创建新组，<strong>Command+B</strong>将编译你的工程，<strong>Command+R</strong>将运行工程。</p>

<p>打开<strong>AlbumView.h</strong>,然后添加下列方法原型到<strong>@interface</strong>和<strong>@end</strong>的中间。</p>

<p><code>
- (id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover;
</code></p>

<p>Now open AlbumView.m and replace all the code after @implementation with the following code:</p>

<p>现在打开<strong>AlbumView.m</strong>，用下面的代码替换<strong>@implementation</strong>之后的内容：</p>

<p>```
@implementation AlbumView
{</p>

<pre><code>UIImageView *coverImage;
UIActivityIndicatorView *indicator;
</code></pre>

<p>}</p>

<ul>
<li><p>(id)initWithFrame:(CGRect)frame albumCover:(NSString*)albumCover
{
  self = [super initWithFrame:frame];
  if (self)
  {</p>

<pre><code>  self.backgroundColor = [UIColor blackColor];
  // the coverImage has a 5 pixels margin from its frame
  coverImage = [[UIImageView alloc] initWithFrame:CGRectMake(5, 5, frame.size.width-10, frame.size.height-10)];
  [self addSubview:coverImage];

  indicator = [[UIActivityIndicatorView alloc] init];
  indicator.center = self.center;
  indicator.activityIndicatorViewStyle = UIActivityIndicatorViewStyleWhiteLarge;
  [indicator startAnimating];
  [self addSubview:indicator];
</code></pre>

<p>  }
  return self;
}</p></li>
</ul>


<p>@end
```</p>

<p>你注意到的第一件事是这里有个名为coverImage的实例变量。变量代表专辑的封面图片。第二个变量是一个指示器，当专辑在下载时它转动指示器。</p>

<p>在初始化方法的实现中，你设置背影为黑色，创建一个与主视图周边有5个点距离的图片视图，创建并添加了一个活动指示器。</p>

<p><strong>Note</strong>:很奇怪为什么把私有变量定义在实现文件中而不是接口文件中？这是因为AlbumView类之外的其他类并不需要知道这些变量的存在，它们仅被类的内部实现中使用。如果你是在开发库或框架让其他开发者使用，这个惯例极其重要。</p>

<p>编译你的工程（<strong>Command+B</strong>）确认所有事情都准备就绪。都好了吗？然后准备迎接你的第一个设计模式！:]</p>

<h3>模型&mdash;视图&mdash;控制器，设计模式之王</h3>

<div style="text-align:center" markdown="1">

<img name="mvcking" src="http://DamianSheldon.github.io/images/mvcking.png" width="293" height="196">  

</div>


<p>模型&mdash;视图&mdash;控制器（MVC）是Cocoa的一个基石，它毫无疑问是被用得最多的设计模式。它依据应用中类的角色给它们分类，鼓励基于角色简洁地分隔代码。</p>

<p>这三个角色是：</p>

<ul>
<li><p>模型：持有你应用数据并定义如何操作它们的对象。例如，这个应用中的模型是你的Album类。</p></li>
<li><p>视图：控制模型类的可视显示以及和用户的交互的对象;所有的UIView和它们的子类基本上都是。在你这个应用中AlbumView代表视图。</p></li>
<li><p>控制器：控制器是中间件，它协调所有的工作。它从模型类访问数据并显示到视图上，监听事件，在需要时操作数据。你能猜到哪个类是你的控制器吗？对，是ViewController。</p></li>
</ul>


<p>你应用中这个设计模式好的实现意味着每个对象都会是三者之一。</p>

<p>视图和模型的通信可以被最佳描述成下图：</p>

<div style="text-align:center" markdown="1">

<img name="mvc0" src="http://DamianSheldon.github.io/images/mvc0.png" width="424" height="194">  

</div>


<p>任何数据发生改变模型类便通知控制器，接下来，控制器将数据更新到视图上。视图接收到用户的动作时可以通知控制器，控制器会根据需要更新模型数据或获取任何请求的数据。</p>

<p>你也许会奇怪为什么不拿掉Controller,在同一个类中实现视图和模型，这看起来更容易。</p>

<p>这都来源于代码的去藕合和可可复用。理想情况下，视图应该完全和模型隔离，这样它可以被不同的模型复用去展示其他的数据。</p>

<p>例如，如果未来你也想添加电影或书本到你的收藏库中，你仍然可以使用相同的AlbumView去展示你的电影和图书对象。此外，如果你创建了一个新的对象，它和专辑有些关系，你可以简单地复用你的Album类，因为它不依赖任何视图。这就是MVC的强大之处！</p>

<h3>如何使用MVC设计模式</h3>

<p>首先，你需要保证你工程中的类是Controller，View, Model三者之一；不要混合两个角色的功能到一个类中。你创建的<strong>Album</strong>和<strong>AlbumView</strong>到目前为止都做的很好。</p>

<p>其次，为了确保你习惯这种工作方式，你应该创建三个工程组来持有你的代码，每组对应一个类别。</p>

<p>导航到<strong>File\New\Group</strong>（或按<strong>Command+Option+N</strong>）并命名为Model，用相同的方法创建<strong>View</strong>和<strong>Controller</strong>组。</p>

<p>现在拖拽<strong>Album.h</strong>和<strong>Album.m</strong>到<strong>Model</strong>组。拖拽<strong>AlbumView.h</strong>和<strong>AlbumView.m</strong>到<strong>View</strong>组，最后拖拽<strong>ViewController.h</strong>和<strong>ViewController.m</strong>到<strong>Controller</strong>组。</p>

<p>目前你的工程结构应该看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="mvc2-255x320" src="http://DamianSheldon.github.io/images/mvc2-255x320.png" width="255" height="320">  

</div>


<p>你的工程已经没有混乱的文件了看起来好多了。你明显能拥有其他的组和类，但这三个类别中的类是应用的核心。</p>

<p>现在你的组件被组织起来了，你需要从其他地方得到你的专辑数据。你将创建一个API类用于全部代码的数据管理&mdash;这提供了一个机会和你探讨下一个设计模式&mdash;单例。</p>

<h3>单例设计模式</h3>

<p>单例设计模式确保对于指定的类仅存在一个实例，全局的访问都指向它。它经常使用懒散加载，只有第一次需要时才创建这个实例。</p>

<p><strong>Note</strong>:Apple大量使用这种方法。例如：<strong>[NSUserDefaults standardUserDefaults]</strong>, <strong>[UIApplication sharedApplication]</strong>, <strong>[UIScreen mainScreen]</strong>, <strong>[NSFileManager defaultManager]</strong> 全都返回单例对象。</p>

<p>你也许会奇怪为什么你要关心一个类是不是只有一个实例，毕竟代码和内存都很便宜，对不对？</p>

<p>有些场景对于类只存在一个实例是有意义的。例如，没有必要存在多个Logger实例，除非你想同时输出多个log文件。以或者来看一个全局配置处理类：像配置文件，对于单个共享资源实现线程安全访问要比在同时可能有很多配置文件修改时容易的多。</p>

<h3>如何使用单例设计模式</h3>

<p>看下下面这个图：</p>

<div style="text-align:center" markdown="1">

<img name="singleton" src="http://DamianSheldon.github.io/images/singleton.png" width="233" height="152">  

</div>


<p>上图示例了一个Logger类，它有一个属性（它就是这个单独的实例），和两个方法：sharedInstance和init。</p>

<p>客户端第一次发送sharedInstance消息，属性的实例还没被初始化，所以你创建类的一个新的实例，然后返回它的一个引用。</p>

<p>下次调用sharedInstance，实例会立即返回不用初始化。这个逻辑保证任何时候都只仅存在一个实例。</p>

<p>你将实现这种模式通过创建一个单例类来管理专辑的所有数据。</p>

<p>你将注意到工程里有一个组叫<strong>API</strong>；这是你放所有将为应用提供服务类的地方。在组里用<strong>iOS\Cocoa Touch\Objective-C class</strong>模板创建一个新的类。命名为<strong>LibraryAPI</strong>，设置它是<strong>NSObject</strong>的子类。</p>

<p>打开<strong>LibraryAPI.h</strong>,用如下内容替代它：</p>

<p>```
@interface LibraryAPI : NSObject</p>

<ul>
<li>(LibraryAPI*)sharedInstance;</li>
</ul>


<p>@end
```</p>

<p>Now go to LibraryAPI.m and insert this method right after the @implentation line:</p>

<p>现在到<strong>LibraryAPI.m</strong>，在<strong>@implentation</strong>之后插入这个方法：</p>

<p>```
+ (LibraryAPI*)sharedInstance
{</p>

<pre><code>// 1
static LibraryAPI *_sharedInstance = nil;

// 2
static dispatch_once_t oncePredicate;

// 3
dispatch_once(&amp;oncePredicate, ^{
    _sharedInstance = [[LibraryAPI alloc] init];
});
return _sharedInstance;
</code></pre>

<p>}
```</p>

<p>简短的方法里有不少内容：</p>

<ol>
<li><p>声明了一个静态变量来持有你类的实例，确保它在你的类中是全局可用的。</p></li>
<li><p>声明了一个<strong>dispatch_once_t</strong>静态变量，它确保初始化方法只会被执行一次。</p></li>
<li><p>使用Grand Central Dispatch (GCD)来执行块，它初始化了一个<strong>LibraryAPI</strong>的实例。这是单例设计模式的要义：类被实例化之后初始化方法就不会被调用了。</p></li>
</ol>


<p>下次你调用<strong>sharedInstance</strong>，在<strong>dispatch_once</strong>块中代码就不会被执行了（因为它已经被执行过一次了），你会得到一个之前创建的<strong>LibraryAPI</strong>的实例引用。</p>

<p>Note:想了解更多GCD内容以及它的用法，看下网站中的这两篇教程：<a href="http://www.raywenderlich.com/?p=4295">Multithreading and Grand Central Dispatch</a>和<a href="http://www.raywenderlich.com/?p=9328">How to Use Blocks</a>。</p>

<p>你现在有一个单例对象作为入口去管理专辑。我们把它进一步完善，创建一个类来处理你收藏库数据的持久化。</p>

<p>以<strong>iOS\Cocoa Touch\Objective-C class</strong>为模板在API组中创建一个新的类，命名为<strong>PersistencyManager</strong>，设置它为<strong>NSObject</strong>的子类。</p>

<p>打开<strong>PersistencyManager.h</strong>，添加下列引用到文件的顶端:</p>

<p>```</p>

<h1>import &ldquo;Album.h&rdquo;</h1>

<p>```</p>

<p>Next, add the following code to PersistencyManager.h after the @interface line:</p>

<p>然后，添加下列代码到<strong>PersistencyManager.h</strong>中<strong>@interface</strong>后面：</p>

<p><code>
- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></p>

<p>上面是你处理专辑数据的三个方法原型。</p>

<p>打开PersistencyManager.m，添加下列代码到@implementation前面：</p>

<p>```
@interface PersistencyManager () {</p>

<pre><code>// an array of all albums
NSMutableArray *albums;
</code></pre>

<p>}
```</p>

<p>上面添加了一个类的扩展，它是另一种给类添加私有方法和变量而不会暴露给外部类的方法。这里你声明了一个<strong>NSMutableArray</strong>来持有专辑数据。数组的可变性可以让你很容易添加和删除专辑数据。</p>

<p>现在添加下现代码实现到PersistencyManager.m文件中@implementation的后面：</p>

<p>```
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    // a dummy list of albums
    albums = [NSMutableArray arrayWithArray:
             @[[[Album alloc] initWithTitle:@"Best of Bowie" artist:@"David Bowie" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png" year:@"1992"],
             [[Album alloc] initWithTitle:@"It's My Life" artist:@"No Doubt" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png" year:@"2003"],
             [[Album alloc] initWithTitle:@"Nothing Like The Sun" artist:@"Sting" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png" year:@"1999"],
             [[Album alloc] initWithTitle:@"Staring at the Sun" artist:@"U2" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png" year:@"2000"],
             [[Album alloc] initWithTitle:@"American Pie" artist:@"Madonna" coverUrl:@"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png" year:@"2000"]]];
}
return self;
</code></pre>

<p>}
```</p>

<p>在init中，你用5个样本专辑填充了数组。如果上面的专辑你不喜欢，用你喜欢的音乐替换它们吧. :]</p>

<p>现在添加下面三个方法到<strong>PersistencyManager.m</strong>：</p>

<p>```
&ndash; (NSArray*)getAlbums
{</p>

<pre><code>return albums;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)addAlbum:(Album*)album atIndex:(int)index
{
  if (albums.count >= index)
      [albums insertObject:album atIndex:index];
  else
      [albums addObject:album];
}</p></li>
<li><p>(void)deleteAlbumAtIndex:(int)index
{
  [albums removeObjectAtIndex:index];
}
```</p></li>
</ul>


<p>这些方法能让你获取，添加，删除专辑。</p>

<p>编译你的工程，确保所有的文件仍然能成功被编译。</p>

<p>到这，你可能会奇怪<strong>PersistencyManager</strong>来看哪里呢？它又不是单例。<strong>LibraryAPI</strong>和<strong>PersistencyManager</strong>的关系，我们在下一节会进一步揭示，你还会看到<strong>门面</strong>设计模式。</p>

<h3>门面设计模式</h3>

<div style="text-align:center" markdown="1">

<img name="facade" src="http://DamianSheldon.github.io/images/facade.jpg" width="300" height="212">  

</div>


<p>门面设计模式为复杂的子系统提供一个单一的接口。与其把一系列类和它们的API暴露给用户，还不如仅仅暴露给它们一个简单统一的API。</p>

<p>下图解释了这种理念：</p>

<div style="text-align:center" markdown="1">

<img name="facade2-480x241" src="http://DamianSheldon.github.io/images/facade2-480x241.png" width="480" height="241">  

</div>


<p>API的使用者们完全感觉不到它后面的复杂。当很多类协作时，这种设计模式十分理想，特别是当它们对用户很复杂或很难理解。</p>

<p>门面模式让使用系统的代码从接口和你隐藏实现的类解藕；它也减少了外部代码对内部子系统工作的依赖。当门面底下的类想改变时，这也很有用，因为门面能保留相同的API，尽管后面的代码已经改变了。</p>

<p>例如，如果有一天你想替换你的后端服务，你不需要去修改使用你API的代码。</p>

<h3>如何使用门面设计模式</h3>

<p>目前你有<strong>PersistencyManager</strong>保存专辑数据到本地，<strong>HTTPClient</strong>处理远程交互。工程中其他的类不应该意识到这个逻辑的存在。</p>

<p>为了实现这个设计模式，仅<strong>LibraryAPI</strong>应该持有<strong>PersistencyManager</strong>和<strong>HTTPClient</strong>的实例。然后，<strong>LibraryAPI</strong>会对其他的服务暴露一个简单的API。</p>

<p><strong>Note</strong>:通常，单例在整个应用的生命周期都存在。你不应该让单例保持大多其他对象的强引用，因为他们直到应用关闭才会被释放。</p>

<p>设计看起来像下面这样：</p>

<div style="text-align:center" markdown="1">

<img name="design-patterns-facade-uml-480x71" src="http://DamianSheldon.github.io/images/design-patterns-facade-uml-480x71.png" width="480" height="71">  

</div>


<p><strong>LibraryAPI</strong>将暴露给其他代码，但是会对应用的其他部分隐藏<strong>HTTPClient</strong>和<strong>PersistencyManager</strong>的复杂。</p>

<p>打开<strong>LibraryAPI.h</strong>，添加下列引用到文件的顶端：</p>

<p>```</p>

<h1>import &ldquo;Album.h&rdquo;</h1>

<p>```</p>

<p>然后，添加下列方法定义到<strong>LibraryAPI.h</strong>：</p>

<p><code>
- (NSArray*)getAlbums;
- (void)addAlbum:(Album*)album atIndex:(int)index;
- (void)deleteAlbumAtIndex:(int)index;
</code></p>

<p>现在，这些方法是你会暴露给其他类的。</p>

<p>到LibraryAPI.m中，添加下面两个引用：</p>

<p>```</p>

<h1>import &ldquo;PersistencyManager.h&rdquo;</h1>

<h1>import &ldquo;HTTPClient.h&rdquo;</h1>

<p>```</p>

<p>这将是你唯一导入这些类的地方。记住：你的API将会是唯一的入口去访问你"复杂"的系统。</p>

<p>现在，通过类的扩展添加些私有变量（在@implementation上面）：</p>

<p>```
@interface LibraryAPI () {</p>

<pre><code>PersistencyManager *persistencyManager;
HTTPClient *httpClient;
BOOL isOnline;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p><strong>isOnline</strong>决定任何专辑列表的改变，例如，添加或删除专辑，是否应该被更新到服务器。</p>

<p>你现在需要通过<strong>init</strong>来初始化这些变量。添加下列代码到<strong>LibraryAPI.m</strong>：</p>

<p>```
&ndash; (id)init
{</p>

<pre><code>self = [super init];
if (self) {
    persistencyManager = [[PersistencyManager alloc] init];
    httpClient = [[HTTPClient alloc] init];
    isOnline = NO;
}
return self;
</code></pre>

<p>}
```</p>

<p>HTTP Client最终不会和真实的服务器交互，这里仅仅是为示例门面模式的使用，所以<strong>isOnline</strong>将一直是<strong>NO</strong>。</p>

<p>下一步，添加下面三个方法到<strong>LibraryAPI.m</strong>：</p>

<p>```
&ndash; (NSArray*)getAlbums
{</p>

<pre><code>return [persistencyManager getAlbums];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)addAlbum:(Album*)album atIndex:(int)index
{
  [persistencyManager addAlbum:album atIndex:index];
  if (isOnline)
  {
      [httpClient postRequest:@&ldquo;/api/addAlbum&rdquo; body:[album description]];
  }
}</p></li>
<li><p>(void)deleteAlbumAtIndex:(int)index
{
  [persistencyManager deleteAlbumAtIndex:index];
  if (isOnline)
  {
      [httpClient postRequest:@&ldquo;/api/deleteAlbum&rdquo; body:[@(index) description]];
  }
}
```</p></li>
</ul>


<p>看一眼<strong>addAlbum:atIndex:</strong>。类首先更新本地数据，然后如果是联网的话，更新远程服务器。这是门面的真正力量；当你系统外面添加一个新专辑，它不知道，也不需要知道这底下的复杂。</p>

<p><strong>Note</strong>:当你为子系统的类设计门面时，记住没任何东西防止客户端直接访问隐藏的类。不要吝啬你的防御代码，不要假设所有客户端按门面相同的方式使用这些类是必须的。</p>

<p>编译并运行你的应用。你会看到像下面这样令人兴奋和无法置信的空的黑色屏幕。</p>

<div style="text-align:center" markdown="1">

<img name="2013-09-01_12-08-44-211x320" src="http://DamianSheldon.github.io/images/2013-09-01_12-08-44-211x320.png" width="211" height="320">  

</div>


<p>你将会需要些东西来显示专辑数据到屏幕上&mdash;这是个完美的使用场景对于你的下个设计模式：修饰。</p>

<h3>修饰设计模式</h3>

<p>修饰设计模式动态添加行为和能力到一个对象而不需要修改它的代码。它是不同于子类那样通过包装到另一个对象来修改类的行为的方法。</p>

<p>在Objective-C中，这种设计模式有两个很常见的实现：<strong>Category</strong>和<strong>Delegation</strong>。</p>

<h4>Category</h4>

<p>Category是一个极其强大的机制，它允许你添加方法到已经存在的类而不需要子类化。新的方法在编译时被添加，可以像扩展类的普通方法一样被执行。它和经典的修饰模式有点不同，因为一个Category不能持有扩展类的实例。</p>

<p><strong>Note</strong>:除了扩展你自己的类，你还可以添加方法到任意Cocoa拥有的类。</p>

<h4>如何使用Categories</h4>

<p>想像这么一个场景，你有一个Album对象，你想让它显示在一个表格视图中:</p>

<div style="text-align:center" markdown="1">

<img name="design-patterns-category1" src="http://DamianSheldon.github.io/images/design-patterns-category1.png" width="310" height="188">  

</div>


<p>专辑标题是从哪来的呢？<strong>Album</strong>是一个模型对象，所以它不关心你如何展示数据。你将需要些外部代码来为<strong>Album</strong>类添加该功能，但是不能直接修改类。</p>

<p>你将创建一个category，这是Album的扩展；它将定义一个新方法，这个新方法会返回一个让UITableView很容易使用的数据结构。</p>

<p>The data structure will look like the following:</p>

<p>这个数据结构会看起来像这样：</p>

<div style="text-align:center" markdown="1">

<img name="delegate2-480x67" src="http://DamianSheldon.github.io/images/delegate2-480x67.png" width="480" height="67">  

</div>


<p>为了添加<strong>Category</strong>到<strong>Album</strong>，导航到<strong>File\New\File…</strong>，选择<strong>Objective-C category</strong>模板&mdash;不要习惯性地选择了<strong>Objective-C class</strong>！输入<strong>TableRepresentation</strong>到<strong>Category</strong>字段，<strong>Album</strong>到<strong>Category on</strong>字段。</p>

<p>Note:你有没注意到新文件的名字？<strong>Album+TableRepresentation</strong>意味着你正在扩展<strong>Album</strong>类。这个惯例很重要，因为它易读并且它防止和你事其他人可能创建的categories冲突。</p>

<p>Go to Album+TableRepresentation.h and add the following method prototype:</p>

<p>进入Album+TableRepresentation.h，添加如下方法原型：</p>

<p><code>
- (NSDictionary*)tr_tableRepresentation;
</code></p>

<p>注意这里的方法名前有个<strong>tr_</strong>，是<strong>category:TableRepresentation</strong>的缩写。再次提醒，像这样的惯例将防止和其他方法冲突！</p>

<p><strong>Note</strong>:如果你在category中声明的方法和源类，或都同一个类其他的category（甚至父类）方法相同，运行时会使用哪个方法实现是示定义的。这种情况在你使用自己拥有类的category时很少发生，但是当使用categories添加方法到标准的Cocoa或Cocoa Touch类时能导致严重问题。</p>

<p>Go to Album+TableRepresentation.m and add the following method:</p>

<p>进入<strong>Album+TableRepresentation.m</strong>，添加如下方法：</p>

<p>```
&ndash; (NSDictionary*)tr_tableRepresentation
{</p>

<pre><code>return @{@"titles":@[@"Artist", @"Album", @"Genre", @"Year"],
         @"values":@[self.artist, self.title, self.genre, self.year]};
</code></pre>

<p>}
```</p>

<p>Consider for a moment how powerful this pattern can be:</p>

<p>思考下这种模式在某个时刻有多强大：</p>

<ul>
<li>你正在使用直接来自Album属性。</li>
<li>你添加了内容到Album类，但是你并没有子类化它。如果你需要子类化Album，你仍然也可以这么做。</li>
<li>这个简单的额外内容让你能返回一个UITableView式的专辑，并没有修改Album的代码。</li>
</ul>


<p>Apple在Foundation类中大量使用Categories。打开<strong>NSString.h</strong>看下他们是如何做的。找到 <strong>@interface NSString</strong>，你将会看到总共定义了三个categories：<strong>NSStringExtensionMethods</strong>, <strong>NSExtendedStringPropertyListParsing</strong> 和 <strong>NSStringDeprecated</strong>。Categories帮助方法组织和分隔到各个部分。</p>

<h4>Delegation</h4>

<p>另一个修饰设计模式，Delegation，是一种一个对象的行为代表或协调另一个对象。例如，当你使用<strong>UITableView</strong>，你必须实现的方法之一是<strong>tableView:numberOfRowsInSection:</strong>。</p>

<p>你不能期望UITableView知道你想每个部分有多少行，因为这是应用特定的。因此，计算每个部分有多少行的任务传递给了UITableView delegate。它允许UITableView类独立于它显示的数据。</p>

<p>这里有一个当你创建一个UITableView时是如何进行的虚拟场景解释：</p>

<div style="text-align:center" markdown="1">

<img name="delegate-480x252" src="http://DamianSheldon.github.io/images/delegate-480x252.png" width="480" height="252">  

</div>


<p>UITableView对象的工作是显示table view。但是，最终它将需要一些它没有的信息。然后，它救助于它的delegates，发送消息询问额外的信息。在Objective-C中实现delegate模式，一个类通过protocol可以声明可选和必选的方法。你将教程的稍候全面了解protocols。</p>

<p>表面看起来仅仅去继承一个对象然后覆盖必要的方法要简单，但是考虑下你只能继承单一的一个类。如果你想让某个类成为两或多个对象的delegate，这是不能通过继承实现的。</p>

<p>Note:这是个很重要的模式。Apple应用这种方法到大多数UIKit类：<strong>UITableView</strong>, <strong>UITextView</strong>, <strong>UITextField</strong>, <strong>UIWebView</strong>, <strong>UIAlert</strong>, <strong>UIActionSheet</strong>, <strong>UICollectionView</strong>, <strong>UIPickerView</strong>, <strong>UIGestureRecognizer</strong>, <strong>UIScrollView</strong>。列表还在继续。</p>

<p>未完待续&hellip;</p>

<h3>原文</h3>

<p>iOS Design Patterns（<a href="http://www.raywenderlich.com/46988/ios-design-patterns%EF%BC%89">http://www.raywenderlich.com/46988/ios-design-patterns%EF%BC%89</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为MacBook Pro配置一个像guake的终端]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/07/setup-iterm2-to-behave-like-guake/"/>
    <updated>2014-11-07T10:31:19+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/07/setup-iterm2-to-behave-like-guake</id>
    <content type="html"><![CDATA[<p>以前在Arch下经常使用一个名为guake的终端，体验很好，用MacBook Pro之后也想有个这样的终端，由于各种原因，这事一直耽搁着，但并没有放下，今天特意找了下，还真找到了。不费话了，进入正题。</p>

<h3>让iTerm2的行为像guake</h3>

<p>1)下载<a href="http://iterm2.com/">iTerm2</a>,然后解压;</p>

<p>2)打开iTerm2,然后iTerm2&mdash;>Prefences&hellip;&ndash;>Profiles;</p>

<p>3)创建一个新Profiles,命名为guake;</p>

<p>4)在Window选项中根据自己的喜好配置;</p>

<p><img name="create_new_iterm_profile" src="http://DamianSheldon.github.io/images/create_new_iterm_profile.png" width="913" height="533"></p>

<p>5)在Keys选项中激活"Show/hide iTerm2 with a system-wide hotkey",由于F12用来移动到Dashboard,只能用其他的快捷键了，可以根据自己喜好设置，我这里设置为⌘F12,(Note:⌘ + fn + F12);</p>

<p><img name="assign_a_hotkey" src="http://DamianSheldon.github.io/images/assign_a_hotkey.png" width="897" height="528"></p>

<h3>开机启动iTerm2时不打开终端窗口</h3>

<p>安装好iTerm2,并把它配置像guake, 加入开机自启动(System Preferences > Users&amp;Groups > Login Items > + iTerm2)之后，还有一个小问题困扰着我，就是它会默认打开一个终端窗口，这让人很不舒坦，解决方法如下:</p>

<p>1)打开iTerm2;</p>

<p>2)关闭所有的窗口(iTerm2菜单栏&mdash;>shell&mdash;>Close);</p>

<p>3)Window&mdash;>Save Window Arrangement;</p>

<p>4)将新的窗口布局命名为“No Windows”;</p>

<p>5)将这个新窗口布局设置默认布局，Preferences > Arrangements > Set it as default;</p>

<p>6)最后在Preferences… > General > Startup, 只选中“Open default window arrangement” 。</p>

<h3>Reference:</h3>

<p>SETUP ITERM2 TO BEHAVE LIKE GUAKE(<a href="http://ivanvillareal.com/osx/setup-iterm2-to-behave-like-guake/">http://ivanvillareal.com/osx/setup-iterm2-to-behave-like-guake/</a>)</p>

<p>Launch iTerm 2 on startup without opening a terminal window (<a href="http://rottmann.net/2013/03/launch-iterm-2-on-startup-without-opening-a-terminal-window/">http://rottmann.net/2013/03/launch-iterm-2-on-startup-without-opening-a-terminal-window/</a>)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 小结]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/05/git-summary/"/>
    <updated>2014-11-05T10:13:13+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/05/git-summary</id>
    <content type="html"><![CDATA[<h3>简介</h3>

<p>git &ndash; the stupid content tracker</p>

<p>这是man git中对它的介绍，我们看到它的核心是content tracker。Git是一个分布式的版本控制系统，项目是出于维护Linux内核源码的需求, 由Linus Torvalds启动的，现在已经成为最流行的版本管理系统，学会Git几乎成了开发者的必备技能。</p>

<h3>安装Git</h3>

<p>安装Git主要有两种方法：一种是通过编译源代码来安装;另一种是使用为特定平台预编译好的安装包。</p>

<h3>在服务器上布署Git</h3>

<p>尽管技术上可以从个人的仓库里推送和拉取改变,但是我们不鼓励这样做,因为一不留心就很 容易弄混其他人的进度。另外,你也一定希望合作者们即使在自己不开机的时候也能从仓库获取数据——拥有 一个更稳定的公共仓库十分有用。因此,更好的合作方式是建立一个大家都可以访问的共享仓库,从那里推送和拉取数据。我们将把这个仓库称为 “Git 服务器”;代理一个 Git 仓库只需要花费很少的资源,几乎从不 需要整个服务器来支持它的运行。</p>

<p>架设一个 Git 服务器有很多种选择，这里不打算展开，不是一下子能讲清楚的，让我们看个实例。架设一个使用SSH传输数据和使用 authorized_keys 方法来给用户授权的Git服务器：
```bash
// Step 1:创建一个 ‘git’ 用户并为其创建一个 .ssh 目录
$ sudo adduser git
$ su -l git
$ cd ~
$ mkdir .ssh</p>

<p>// Step 2:把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。
// 假设你通过 e-mail 收到了几个 公钥并存到了临时文件里
$ cat /tmp/id_rsa.john.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub >> ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub >> ~/.ssh/authorized_keys</p>

<p>// Step 3:使用 &mdash;bare 选项运行 git init 来设定一个空仓库,这会初始化一个不包含工作目录的仓库
$sudo mkdir /opt/git
$sudo chown -R git /opt/git
$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git &mdash;bare init</p>

<p>// Mac 下需要开启ssh并允许remote login
$launchctl start sshd
// System Preferences &ndash;> Sharing &ndash;> Remote Login &ndash;> All Users</p>

<p>// Step 4:Join,Josie 或者 Jessica 就可以把它加为远程仓库,
推送一个分支,从而把第一个版本的工程上 传到仓库里了</p>

<h1>在 John 的电脑上</h1>

<p>$ cd myproject
$ git init
$ git add .
$ git commit -m &lsquo;initial commit&rsquo;
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master</p>

<p>// Step 5:其他人的克隆和推送也一样变得很简单
$ git clone git@gitserver:/opt/git/project.git $ vim README
$ git commit -am &lsquo;fix for the README file&rsquo;
$ git push origin master</p>

<p>// Step 6:用这个方法可以很快捷的为少数几个开发者架设一个可读写的 Git 服务</p>

<p>// 如何生成 SSH 公钥？
// Step 1:首先,确定一下是否已经有一个公钥了。SSH 公钥默认储存 在账户的 ~/.ssh 目录。
// 进入那里并查看其内容,有没有公钥一目了然:
$ cd ~/.ssh
$ ls
authorized_keys2 id_dsa known_hosts config id_dsa.pub</p>

<p>// Step 2:关键是看有没有用 文件名 和 文件名.pub 来命名的一对文件,
// 这个 文件名 通常是 id_dsa 或者 id_rsa。 .pub 文件是公钥,另一个文件是密钥。
// 假如没有这些文件(或者干脆连 .ssh 目录都没有),你可以用 ssh- keygen 的程序来建立它们,
// 该程序在 Linux/Mac 系统由 SSH 包提供, 在 Windows 上则包含在 MSysGit 包 里:
$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/schacon/.ssh/id_rsa.
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#x73;&#x63;&#104;&#97;&#x63;&#x6f;&#110;&#64;&#x61;&#103;&#97;&#x64;&#111;&#114;&#108;&#97;&#112;&#116;&#x6f;&#112;&#x2e;&#x6c;&#111;&#99;&#x61;&#x6c;">&#115;&#99;&#x68;&#x61;&#99;&#x6f;&#110;&#x40;&#x61;&#x67;&#97;&#x64;&#x6f;&#x72;&#108;&#x61;&#x70;&#116;&#x6f;&#x70;&#46;&#108;&#x6f;&#x63;&#97;&#108;</a></p>

<p>// Step 3:它先要求你确认保存公钥的位置(.ssh/id_rsa),然后它会让你重复一个密码两次,
// 如果不想在使用公钥的 时候输入密码,可以留空。
// 现在,所有做过这一步的用户都得把它们的公钥给你
// 或者 Git 服务器的管理者(假设 SSH 服务被设定为使 用公钥机制)。
// 他们只需要复制 .put 文件的内容然后 e-email 之。公钥的样子大致如下:
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#115;&#99;&#104;&#x61;&#99;&#x6f;&#110;&#x40;&#x61;&#103;&#97;&#100;&#111;&#x72;&#x6c;&#97;&#112;&#116;&#x6f;&#112;&#x2e;&#108;&#x6f;&#99;&#x61;&#108;">&#x73;&#99;&#104;&#97;&#99;&#111;&#110;&#64;&#x61;&#103;&#x61;&#100;&#x6f;&#114;&#108;&#x61;&#112;&#116;&#111;&#112;&#46;&#108;&#111;&#x63;&#x61;&#108;</a>
```</p>

<p>作为一个额外的防范措施,你可以用 Git 自带的 git-shell 简单工具来把 git 用户的活动限制在仅与 Git 相关。把它设为 git 用户登入的 shell,那么该用户就不能拥有主机正常的 shell 访问权。为了实现这一 点,需要指明用户的登入shell 是 git-shell ,而不是 bash 或者 csh。你可能得编辑 /etc/passwd 文件:
```bash
// Step 1:
$ sudo vim /etc/passwd</p>

<p>// Step 2:在文件末尾,你应该能找到类似这样的行
git:x:1000:1000::/home/git:/bin/sh</p>

<p>// Step 3:把 bin/sh 改为 /usr/bin/git-shell (或者用 which git-shell 查看它的位置)。该行修改后的样子如下
git:x:1000:1000::/home/git:/usr/bin/git-shell</p>

<p>// Step 4:现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库,而不能直接使用主机 shell。
// 尝试登录的话,你会 看到下面这样的拒绝信息
$ ssh git@gitserver
fatal: What do you think I am? A shell? (你以为我是个啥?shell吗?)
Connection to gitserver closed. (gitserver 连接已断开。)
```</p>

<h3>Git基础</h3>

<p>为了和其他人愉快地的合作开发，我们要掌握Git的基本命令。你不会想看到人民群众仇恨你。  <br/>
1)Git基础要点; <br/>
2)配置Git; <br/>
3)Git分支;
4)记录每次更新到仓库;  <br/>
5)撤消操作; <br/>
6)远程仓库的使用;  <br/>
7)打标签;  <br/>
8)查看提交历史。</p>

<h4>Git基础要点</h4>

<p>对于任何一个文件,在 Git 内都只有三种状态:已提交 (committed),已修改(modified)和已暂存(staged)。已提交表示该文件已经被安全地保存在本地数据 库中了;已修改表示修改了某个文件,但还没有提交保存;已暂存表示把已修改的文件放在下次提交时要保存 的清单中。
由此我们看到 Git 管理项目时,文件流转的三个工作区域:Git 的本地数据目录,工作目录以及暂存区域。</p>

<p>每个项目都有一个 git 目录,它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要,每次克隆 镜像仓库的时候,实际拷贝的就是这个目录里面的数据。
从项目中取出某个版本的所有文件和目录,用以开始后续工作的叫做工作目录。这些文件实际上都是从 git 目录中的压缩对象数据库中提取出来的,接下来就可以在工作目录中对这些文件进行编辑。
所谓的暂存区域只不过是个简单的文件,一般都放在 git 目录中。有时候人们会把这个文件叫做索引文件,不过标准说法还是叫暂存区域。</p>

<p>基本的 Git 工作流程如下:  <br/>
a)在工作目录中修改某些文件;  <br/>
b)对这些修改了的文件作快照,并保存到暂存区域;  <br/>
c)提交更新,将保存在暂存区域的文件快照转储到 git 目录中.</p>

<h5>配置Git</h5>

<p>一般在新的系统上,我们都需要先配置下自己的 Git 工作环境。配置工作只需一次,以后升级时还会沿用 现在的配置。当然,如果需要,你随时可以用相同的命令修改已有的配置。</p>

<p>Git 提供了一个叫做 git config 的工具(译注:实际是 git-config 命令,只不过可以通过 git 加一个 名字来呼叫此命令。),专门用来配置或读取相应的工作环境变量。而正是由这些环境变量,决定了 Git 在 各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方:  <br/>
1)/etc/gitconfig文件:系统中对所有用户都普遍适用的配置。若使用 git config 时用 &mdash;system 选项,读写 的就是这个文件。  <br/>
2)~/.gitconfig文件:用户目录下的配置文件只适用于该用户。若使用 git config 时用 &mdash;global 选项,读写 的就是这个文件。 <br/>
3)当前项目的 git 目录中的配置文件(也就是工作目录中的 .git/config 文件):这里的配置仅仅针对当前 项目有效。每一个级别的配置都会覆盖上层的相同配置,所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</p>

<p>```bash
// Quilk config
// 用户信息
$ git config &mdash;global user.name &ldquo;John Doe&rdquo;
$ git config &mdash;global user.email <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#x3a;&#106;&#x6f;&#x68;&#x6e;&#x64;&#x6f;&#101;&#x40;&#101;&#120;&#97;&#109;&#112;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#x6a;&#x6f;&#104;&#110;&#x64;&#111;&#101;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;</a></p>

<p>// 文本编辑器
$ git config &mdash;global core.editor emacs</p>

<p>// 差异分析工具
$ git config &mdash;global merge.tool vimdiff</p>

<p>// 查看配置信息
$ git config &mdash;list</p>

<p>```</p>

<h5>Git分支</h5>

<p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来,然后在不影响主线的同时继续工作。
1)新建分支;
```bash
// 新建本地分支
git branch [&mdash;set-upstream | &mdash;track | &mdash;no-track] [-l] [-f] <branchname> [&lt;start-point>]</p>

<p>&mdash;set-upstream
如果指定的分支不存在，或者指定了&mdash;force参数，作用和&mdash;track一样。
否则当创建分支时建立像&mdash;track一样的配置，除了分支的指向没有改变。</p>

<p>&mdash;track</p>

<p>当创建新的分支，从新分支建立branch.<name>.remote和branch.<name>.merge的配置入口
去标记start-point 分支作为“upstream”。
这个配置会告诉git在git status和git branch -v中显示两个分支的关系。
而且，当新的分支被检出时，它会引导git pull在没带参数时去从upstream拉代码。</p>

<p>当我们的start point是remote-tracking分支时，这一行为是默认的。
如果你想让git checkout和git branch总是像给定&mdash;no-track一样执行，设置branch.autosetupmerge 配置变量为false。
当start-point是local或remote-tracking分支时，上述行为是你想要的，那么设置它为always。</p>

<p>&mdash;no-track
不建立"upstream"配置，即使branch.autosetupmerge配置变量的值是true。</p>

<p>-l
创建分支的引用日志。它会激活对分支引用所有改变模式的记录，开启使用基于sha1表达式的日期，
如"<branchname>@{yesterday}&ldquo;。
注意在non-bare仓库中，引用日志由于core.logallrefupdates配置选项默认都开启的。</p>

<p>-f
如果<branchname>已经存在，重置<branchname>到<startpoint>。没有-f git branch将会拒绝改变。</p>

<p><branchname>
要创建或删除分支的名称。新分支的名称必须通过git-check-ref-format(1)定义的所有检查。
有些检查会限制分支名称中能使用的字符。</p>

<p>&lt;start-point>
已经存在的分支名，对它应用和<branchname>相同的限制。</p>

<p>如果我们没有指定&lt;start-point>,它默认是HEAD。
$git branch <branchname> &lt;start-point></p>

<p>// 新建远程仓库分支
git push [远程名] [本地分支]:[远程分支]</p>

<p>```</p>

<p>2)删除分支;
```bash
// 删除本地分支
$ git branch -d <branchname></p>

<p>// 删除远程分支
// 如果想在服务器上删 除 serverfix 分支,运行下面的命令:
$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
&ndash; [deleted] serverfix
```</p>

<p>3)切换分支;
<code>bash
git checkout &lt;branchname&gt;
</code></p>

<p>4)合并分支;
<code>bash
// 将sourceBranchname合并到destinationBranchname
$git checkout destinationBranchname
$git merge sourceBranchname
</code></p>

<p>5)衍合分支。
```bash
// 把一个分支整合到另一个分支的办法有两种:merge(合并) 和 rebase(衍合)。
// 把在 branchA 里产生的变化补丁重新在 branchB 的基础上打一遍。在 Git 里,这种 操作叫做衍合(rebase)。
// 有了 rebase 命令,就可以把在一个分支里提交的改变在另一个分支里重放一遍。
// 例如将experiment衍合到master分支:
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it&hellip; Applying: added staged command</p>

<p>```
关于如何进行分支管理，可以看看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">这篇博文</a>。</p>

<h5>记录每次更新到仓库</h5>

<p>版本控制的主要作用就是记录我们的更新，如果我们不将更新记录到远程仓库就失去意义了。
```bash
// 检查当前文件状态
$ git status</p>

<h1>On branch master</h1>

<p>nothing to commit (working directory clean)</p>

<p>// 跟踪新文件
$ git add newFilename</p>

<p>// 暂存已修改文件
$ git add trackedFilename</p>

<p>// 忽略某些文件
//一般我们总会有些文件无需纳入 Git 的管理,也不希望它们总出现在未跟踪文件列表。
通常都是些自动生成的文件,像是日志或者编译过程中创建的等等。
我们可以创建一个名为 .gitignore 的文件,列出要忽略的 文件模式。</p>

<p>// 文件 .gitignore 的格式规范如下:
// 1)所有空行或者以注释符号 # 开头的行都会被 Git 忽略。
// 2)可以使用标准的 glob 模式匹配, 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。
// 3)匹配模式最后跟反斜杠(/)说明要忽略的是目录。
/*</p>

<h1>此为注释 – 将被 Git 忽略</h1>

<p><em>.a # 忽略所有 .a 结尾的文件
!lib.a # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件
doc/</em>.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
*/</p>

<p>// 查看已暂存和未暂存的更新
// 实际上 git status 的显示比较简单,仅仅是列出了修改过的文件,如果要查看具体修改了什么地方,可以用 git diff 命令。
$ git diff
diff &mdash;git a/benchmarks.rb b/benchmarks.rb index 3cb747f..da65585 100644
&mdash;&ndash; a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6
+ + + +
+36,10 @@ def main @commit.parents[0].parents[0].parents[0]
end
run_code(x, &lsquo;commits 1&rsquo;) do git.commits.size
end
run_code(x, &lsquo;commits 2&rsquo;) do
log = git.commits(&lsquo;master&rsquo;, 15) log.size</p>

<p>// 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用 git diff &mdash;cached 命令。</p>

<p>// 提交更新
$ git commit</p>

<p>// 跳过使用暂存区域
// 尽管使用暂存区域的方式可以精心准备要提交的细节,但有时候这么做略显繁琐。
Git 提供了一个跳过使用 暂存区域的方式,只要在提交的时候,给 git commit 加上 -a 选项,
Git 就会自动把所有已经跟踪过的文件暂存起来一并提交,从而跳过 git add 步骤:
$ git commit -a -m &lsquo;added new benchmarks&rsquo;
[master 83e38c7] added new benchmarks
1 files changed, 5 insertions(+), 0 deletions(&ndash;)</p>

<p>// 移除文件
// 要从 Git 中移除某个文件,就必须要从已跟踪文件清单中移除(确切地说,是从暂存区域移除),然后提交。
可以用 git rm 命令完成此项工作,并连带从工作目录中删除指定的文件,这样以后就不会出现在未跟踪 文件清单中了。
// 如果只是简单地从工作目录中手工删除文件,运行 git status 时就会在 “Changed but not updated” 部分(也就是<em>未暂存</em>清单)看到。</p>

<p>// 移动文件
$ git mv file_from file_to</p>

<p>```</p>

<h5>撤消操作</h5>

<p>任何时候,你都有可能需要撤消刚才所做的某些操作。
```bash
// 修改最后一次提交
// 有时候我们提交完了才发现漏掉了几个文件没有加,或者提交信息写错了。想要撤消刚才的提交操作,可以 使用 &mdash;amend 选项重新提交:
$ git commit &mdash;amend</p>

<p>// 取消已经暂存的文件
git reset HEAD <file>&hellip;</p>

<p>// 取消对文件的修改
use &ldquo;git checkout &mdash; <file>&hellip;&rdquo; to discard changes in working directory</p>

<p>```</p>

<h5>远程仓库的使用</h5>

<p>```bash
// 查看当前的远程库
git remote [-v]</p>

<p>// 添加远程仓库
git remote add [shortname] [url]</p>

<p>// 从远程仓库抓取数据
$ git fetch [remote-name]</p>

<p>// 推送数据到远程仓库
git push [remote-name] [branch-name]</p>

<p>// 查看远程仓库信息
git remote show [remote-name]</p>

<p>// 远程仓库的删除和重命名
// 可以用 git remote rename 命令修改某个远程仓库的简短名称,比如想把 pb 改成 paul,可以这么运行:
$ git remote rename pb paul $ git remote
origin
paul</p>

<p>// 移除 对应的远端仓库,可以运行 git remote rm 命令:
$ git remote rm paul $ git remote
origin
```</p>

<h5>打标签</h5>

<p>人们在发布某个软件版本(比如 v1.0 等等)的时候,经常会打上一标签。
```bash
// 列显已有的标签
$ git tag v0.1
v1.3</p>

<p>// 新建标签
// Git 使用的标签有两种类型:轻量级的(lightweight)和含附注的(annotated)。
轻量级标签就像是个不 会变化的分支,实际上它就是个指向特定提交对象的引用。
而含附注标签,实际上是存储在仓库中的一个独立 对象,它有自身的校验和信息,
包含着标签的名字,电子邮件地址和日期,以及标签说明,标签本身也允许使 用 GNU Privacy Guard (GPG) 来签署或验证。
一般我们都建议使用含附注型的标签,以便保留相关信息;
当然,如果只是临时性加注标签,或者不需要旁注额外信息,用轻量级标签也没问题。</p>

<p>// 创建一个含附注类型的标签非常简单,用 -a (译注:取 annotated 的首字母)指定标签名字即可:
$ git tag -a v1.4 -m &lsquo;my version 1.4&rsquo;</p>

<p>// 可以使用 git show 命令查看相应标签的版本信息,并连同显示打标签时的提交对象。
$ git show v1.4
tag v1.4
Tagger: Scott Chacon <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#58;&#115;&#99;&#x68;&#x61;&#x63;&#x6f;&#110;&#x40;&#x67;&#101;&#101;&#45;&#x6d;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;">&#x73;&#99;&#x68;&#97;&#x63;&#x6f;&#x6e;&#x40;&#103;&#101;&#x65;&#45;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d;</a> Date: Mon Feb 9 14:45:11 2009 -0800
my version 1.4
commit 15027957951b64cf874c3557a0f3547bd83b3ff6 Merge: 4a447f7&hellip; a6b4c97&hellip;
Author: Scott Chacon <a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x73;&#x63;&#x68;&#97;&#x63;&#x6f;&#x6e;&#x40;&#103;&#101;&#101;&#x2d;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#115;&#x63;&#x68;&#x61;&#x63;&#111;&#x6e;&#64;&#x67;&#x65;&#101;&#45;&#109;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a> Date: Sun Feb 8 19:02:46 2009 -0800
Merge branch &lsquo;experiment&rsquo;</p>

<p>// 签署标签
//如果你有自己的私钥,还可以用 GPG 来签署标签,只需要把之前的 -a 改为 -s (译注: 取 Signed 的首
字母)即可:
$ git tag -s v1.5 -m &lsquo;my signed 1.5 tag&rsquo;
You need a passphrase to unlock the secret key for user: &ldquo;Scott Chacon <a href="&#x6d;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#115;&#x63;&#x68;&#97;&#x63;&#111;&#110;&#64;&#x67;&#101;&#x65;&#x2d;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#115;&#99;&#x68;&#x61;&#99;&#x6f;&#x6e;&#64;&#103;&#101;&#101;&#45;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;</a>&rdquo;
1024-bit DSA key, ID F721C45A, created 2009-02-09</p>

<p>// 轻量级标签
// 轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。
要创建这样的标签,一个 -a,-s 或 -m 选项都不用,直接给出标签名字即可:
$ git tag v1.4-lw</p>

<p>// 验证标签
// 可以使用 git tag -v [tag-name] (译注:取 verify 的首字母)的方式验证已经签署的标签。
此命令会调用 GPG 来验证签名,所以你需要有签署者的公钥,存放在 keyring 中,才能验证:
$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x6a;&#117;&#110;&#107;&#105;&#111;&#x40;&#x63;&#111;&#120;&#46;&#x6e;&#x65;&#116;">&#x6a;&#x75;&#x6e;&#x6b;&#105;&#x6f;&#64;&#x63;&#111;&#x78;&#x2e;&#110;&#x65;&#116;</a> 1158138501 -0700
GIT 1.4.2.1
Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &ldquo;Junio C Hamano <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#x6a;&#x75;&#x6e;&#107;&#x69;&#x6f;&#x40;&#99;&#111;&#x78;&#46;&#110;&#x65;&#x74;">&#106;&#117;&#x6e;&#107;&#105;&#111;&#x40;&#99;&#x6f;&#x78;&#x2e;&#110;&#x65;&#x74;</a>&rdquo;
gpg: aka &ldquo;[jpeg image of size 1513]&rdquo;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7 4A7D C0C6 D9A4 F311 9B9A</p>

<p>// 后期加注标签
// 比如在下面展示的提交历史中:
$ git log &mdash;pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &lsquo;experiment&rsquo;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &lsquo;experiment&rsquo;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</p>

<p>// 我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2,没关系,现在也能做。
只要在打标 签的时候跟上对应提交对象的校验和(或前几位字符)即可:
$ git tag -a v1.2 9fceb02</p>

<p>// 分享标签
// 默认情况下,git push 并不会把标签传送到远端服务器上,只有通过显式命令才能分享标签到远端仓库。
其命令格式如同推送分支,运行 git push origin [tagname] 即可:
$ git push origin v1.5
Counting objects: 50, done.
Compressing objects: 100% (38/38), done. Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
* [new tag] v1.5 &ndash;> v1.5</p>

<p>// 如果要一次推送所有(本地新增的)标签上去,可以使用 &mdash;tags 选项:
$ git push origin &mdash;tags
```</p>

<h5>查看提交历史</h5>

<p>```bash
// 在提交了若干更新之后,又或者克隆了某个项目,想回顾下提交历史,可以使用 git log 命令。</p>

<p>// 我们常用 -p 选项展开显示每次提交的内容差异,用 -2 则仅显示最近的两次更新:
$ git log –p -2</p>

<p>// 还有 许多摘要选项可以用,比如 &mdash;stat,仅显示简要的增改行数统计:
$git log &mdash;stat</p>

<p>// 限制输出长度
// 列出所有最近两周内的提交
$ git log &mdash;since=2.weeks</p>

<p>```</p>

<h3>分布式工作流程</h3>

<p>在服务器上布暑好了Git，并建好代码仓库以后，团队成员就可以愉快地合作开发了。由于团队的规模不一样，工作流程也会略有区别，我们先通过最简单的私有的小型团队来掌握基本的流程，其他的情况也就容易理解了。
```bash
//一个私有项目,与你一起协作的还有另外一到两位开发者。这里说私有,是指源代码不公开,其他人无法访问项目仓库。</p>

<h1>John&rsquo;s Machine</h1>

<p>// Step 1: 克隆一份项目代码到本地
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/ &hellip;</p>

<p>// Step 2: 打开项目，编辑，完成属于自己的任务
$ cd simplegit/
$ vim lib/simplegit.rb</p>

<p>// Step 3:更新项目，因为在你完成任务的时间窗口中团队其他成员可能提交过代码
$ git fetch origin
&hellip;
From john@githost:simplegit
+ 049d078&hellip;fbff5bc master &ndash;> origin/master</p>

<p>// Step 4:合并分支，将团队成员的代码和自己的代码合并到一起
$ git merge origin/master Merge made by recursive.
TODO | 1 +
1 files changed, 1 insertions(+), 0 deletions(&ndash;)</p>

<p>// Step 5:合并分支冲突时
$git status</p>

<p>index.html: needs merge</p>

<h1># # # # #</h1>

<p>On branch master
Changed but not updated:
(use &ldquo;git add <file>&hellip;&rdquo; to update what will be committed)
(use &ldquo;git checkout &mdash; <file>&hellip;&rdquo; to discard changes in working directory)
unmerged: index.html</p>

<p>// 任何包含未解决冲突的文件都会以未合并(unmerged)状态列出。
Git 会在有冲突的文件里加入标准的冲突 解决标记,可以通过它们来手工定位并解决这些冲突。
可以看到此文件包含类似下面这样的部分:
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</p>

<div id="footer">contact : email.support@github.com</div>


<h1> </h1>

<div id="footer">
please contact us at support@github.com </div>


<blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>iss53:index.html</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote>

<p>// 可以看到 ======= 隔开的上半部分,是 HEAD(即 master 分支,在运行 merge 命令时检出的分支)中的内 容,
下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
比如你可以通过把这段内容替换为下面这样来解决:</p>

<div id="footer">
please contact us at email.support@github.com </div>


<p>// Step 6:手动解决冲突，然后运行 git add 将把它们标记为已解决(resolved),
如果觉得满意了,并且确认所有冲突都已解决,也就是进入了缓存区,就可以用 git commit 来完成这次合并提交。</p>

<p>$ git commit -am &lsquo;removed invalid default value&rsquo;
[master 738ee87] removed invalid default value
1 files changed, 1 insertions(+), 1 deletions(&ndash;)</p>

<p>// Step 7:将完成的代码推送到服务器的代码仓库中
$ git push origin master
&hellip;
To jessica@githost:simplegit.git
1edee6b..fbff5bc master &ndash;> master</p>

<p>```</p>

<h4>Reference</h4>

<p><a href="http://git-scm.com/book/zh/v1">Pro Git</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(翻译)Variable-Sized Items in UICollectionView]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview/"/>
    <updated>2014-11-04T11:27:12+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/04/variable-sized-items-in-uicollectionview</id>
    <content type="html"><![CDATA[<h3>基本训练</h3>

<p>我们以“Single View Application”为模板新建一个工程。在ViewController.xib上添加一个UICollectionView让它覆盖整个view。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView01" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView01.png" width="1110" height="783"></p>

<p>Collection View和它的祖父类似，有delegate和dataSource两个outlet,我们把它们连接到“File’s Owner”,这里的“File’s Owner”是ViewController类。这样Collection View的内容和交互就受ViewController控制。我们也需要一个outlet来引用Collection View,所以用Assistant editor增加一个。刚在ViewController.h中添加的outlet property可以是weak，因为作为ViewController的视图的子视图，它也会被充分的保留。</p>

<h3>单元格</h3>

<p>我们需要设计一个Cell原型来显示内容。如果你的Collection View是在View controller’s XIB ,你必须在先在代码中注册Cell才能使用。如果你是在Storyboard中新建的CollectionView，并在CollectionView的区域内创建的原型Cell,那么你就不需要注册Cell identifier了。因为我们并没有从Storyboard中开始，所以需要手动来创建。</p>

<p>我们在Interface Builder中创建一个原型Cell，设置它的背影为白色，添加一个UILabel，添加Label到父视图边缘的约束，分别是5 points的距离。因为我们想让Label的文字来决定它的尺寸，所以选中Label,然后从Editor menu中选择“Size to Fit Content”。后面我们会看到它是否会按照我们想像的那样工作。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView02" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView02.png" width="964" height="400"></p>

<p>我们设置Identifier为“TagCell”以便我们能在设计中引用。</p>

<p>这里我们遇到了第一个问题。如果你没有使用Storyboards,并没有办法让Collection View在相同的NIB文件中使用Collection View Cell。有两种可行的方法注册Cell:
```objective-c</p>

<pre><code>– registerClass:forCellWithReuseIdentifier:
– registerNib:forCellWithReuseIdentifier:
</code></pre>

<p>```</p>

<p>方法一为指定的Reuse identifier实例化某个特定的类，如果我们是通过代码来创建Cell的视图层级，我们应该使用这个方法；  <br/>
方法二需要一个NIB,而且NIB文件中只有Cell一个元素。在Storyboard中使用Collection Views避免了这个麻烦，这是它工作量更小的第二个重要原因。</p>

<p>为了解决这个问题，我们创建一个“empty Interface Builder Document”，命名为TagCollectionViewCell。感激零涕我们可以简单地CMD+X Cell设计从一个ViewController NIB中，然后CMD+V它到一个空的文档中。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView03" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView03.png" width="791" height="229"></p>

<p>下一步我们将试着注册Cell在Collection View中使用，并想看到显示一定数量的元素。</p>

<h3>注册设计的单元格</h3>

<p>任何时候我们想要一个标识符为“TagCell”的Cell都需要注册设计好的NIB文件，所以我们在ViewController.m文件的viewDidLoad中加入如下代码。
```objective-c</p>

<pre><code>UINib *cellNib = [UINib nibWithNibName:@"TagCollectionViewCell" bundle:nil];
[self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@"TagCell"];
</code></pre>

<p>```</p>

<p>我们仅需要实现的更多方法属于UICollectionViewDataSource协议，这些方法确保单元格正确显示。</p>

<p>```objective-c</p>

<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 UICollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> return cell;
}
```</p></li>
</ul>


<p>现在启动应用，我们看到100个元素全部是使用我们大概还没获奖的设计原型。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView04" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView04.png" width="396" height="744"></p>

<p>一眼就看出所有的元素都拥有相同的大小，准确的50x50 points。这是因为我们没有修改Interface Builder的默认值。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView05" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView05.png" width="261" height="273"></p>

<p>但是在我们为每个元素指定大小之前，让我们首先来完善一下我们的设计。我们移除白色的背影，新建一个TagCollectionViewCell类，并且将它指定为元素的类。</p>

<h3>漂亮的单元</h3>

<p>与其依赖iOS用单元的背影颜色填充整个矩形，我们想用一个圆角的矩形包围我们的标签。</p>

<p>```objective-c
&ndash; (void)drawRect:(CGRect)rect
{
   // inset by half line width to avoid cropping where line touches frame edges
   CGRect insetRect = CGRectInset(rect, 0.5, 0.5);
   UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:insetRect cornerRadius:rect.size.height/2.0];</p>

<p>   // white background
   [[UIColor whiteColor] setFill];
   [path fill];</p>

<p>   // red outline
   [[UIColor redColor] setStroke];
   [path stroke];
}
```</p>

<p>注意：你需要设置单元的contentMode为redraw,否则修改单元的大小不会触发重绘这个漂亮的背影。</p>

<p>结果看起来像下面这样，有部分黑色的背影发光渗透。注意我们需要轻微缩进一点再绘画轮廓，因为Quartz将裁剪红色圆圈靠近视图边界的部分。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView06" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView06.png" width="394" height="110"></p>

<p>下一步是让单元的大小适合现在标签的内容。</p>

<h3>逐个元素指定大小</h3>

<p>当然我们并不满足用1）一个静态值指定所有的元素大小，所以2）想让大小随我们单元的内容自动调整。还记得我们指定元素标签依靠文本大小来决定自身大小吗？视图的边缘距离标签的边缘是固定的5 points。因此如果有一种方法能得到元素的实际大小，那将十分酷。更酷的是如果我们能告诉collection view用这些值来指定元素的大小。</p>

<p>LLDB的一个快速测试表明元素返回一个-1，-1的固定内容大小值，这个未定义是一样的。我们在TagCollectionViewCell的头文件中为Label加一个outlet,以便我们能找到UILabel返回它们显示当前文本需要的大小。</p>

<p>因为我们知道约束四周的空白，我们把它们和Label的固定内容大小相加就得到了元素的大小。
```objective-c
// cache for margins configured via constraints in XIB
static CGSize _extraMargins = {0,0};</p>

<p>@implementation TagCollectionViewCell</p>

<ul>
<li><p>(CGSize)intrinsicContentSize
{
 CGSize size = [self.label intrinsicContentSize];</p>

<p> if (CGSizeEqualToSize(<em>extraMargins, CGSizeZero))
 {
    // quick and dirty: get extra margins from constraints
    for (NSLayoutConstraint *constraint in self.constraints)
    {
       if (constraint.firstAttribute == NSLayoutAttributeBottom || constraint.firstAttribute == NSLayoutAttributeTop)
       {
          // vertical spacer
          </em>extraMargins.height += [constraint constant];
       }
       else if (constraint.firstAttribute == NSLayoutAttributeLeading || constraint.firstAttribute == NSLayoutAttributeTrailing)
       {
          // horizontal spacer
          _extraMargins.width += [constraint constant];
       }
    }
 }</p>

<p> // add to intrinsic content size of label
 size.width += <em>extraMargins.width;
 size.height += </em>extraMargins.height;</p>

<p> return size;
}</p></li>
</ul>


<p>@end
```</p>

<p>该方法从我们在Interface Builder设置的约束中得到实际的留白宽度。它允许我们在IB中调整大小而不需要在代码中改变常量或宏定义。因为我们不打算修改任何约束，只是在方法第一次被调用时懒散的设置一个静态_extraMargins作为常量。</p>

<p>现在困难的部分是从Collection view中出列一个元素并得到大小。它之所以困难是因为方法会调用数据源的collectionView:cellForItemAtIndexPath:，还会调用collectionView:layout:sizeForItemAtIndexPath:方法。这里禁止我们从后一种方法中出列一个元素，否则会导致无限循环。</p>

<p>有些人从模型对象中得到数据，然后cell有一个类方法来计算需要的大小。然而这没有利用我们想要在Interface Builder中设置的约束。对于这个先有鸡还是先有蛋的问题，我能想到的最简便的方法是使用一个单独的元素作为模板，然后使用它新鲜出炉的intrinsicContentSize方法。</p>

<p>```objective-c
@implementation ViewController
{
   TagCollectionViewCell *_sizingCell;
}</p>

<ul>
<li><p>(void)viewDidLoad
{
 [super viewDidLoad];</p>

<p> UINib *cellNib = [UINib nibWithNibName:@&ldquo;TagCollectionViewCell&rdquo; bundle:nil];
 [self.collectionView registerNib:cellNib forCellWithReuseIdentifier:@&ldquo;TagCell&rdquo;];</p>

<p> // get a cell as template for sizing
 _sizingCell = [[cellNib instantiateWithOwner:nil options:nil] objectAtIndex:0];
}</p></li>
</ul>


<h1>pragma mark &ndash; UICollectionView</h1>

<ul>
<li><p>(NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
 return 100;
}</p></li>
<li><p>(void)_configureCell:(TagCollectionViewCell <em>)cell forIndexPath:(NSIndexPath </em>)indexPath
{
 if (indexPath.row%2)
 {
    cell.label.text = @&ldquo;A&rdquo;;
 }
 else if (indexPath.row%3)
 {
    cell.label.text = @&ldquo;longer&rdquo;;
 }
 else
 {
    cell.label.text = @&ldquo;much longer&rdquo;;
 }
}</p></li>
<li><p>(UICollectionViewCell <em>)collectionView:(UICollectionView </em>)collectionView cellForItemAtIndexPath:(NSIndexPath <em>)indexPath
{
 TagCollectionViewCell </em>cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&ldquo;TagCell&rdquo; forIndexPath:indexPath];</p>

<p> [self _configureCell:cell forIndexPath:indexPath];</p>

<p> return cell;
}</p></li>
<li><p>(CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
 [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p> return [_sizingCell intrinsicContentSize];
}</p></li>
</ul>


<p>@end
```</p>

<p>为Collection view注册了NIB之后，我创建了个元素实例并赋值给了我的实例变量 <em>sizingCell。为了得到实际元素单元，我们有一个 </em>configureCell:forIndexPath:方法，它作用于出列可复用的实例上。为了计算大小，我们应用这个相同的方法到我们的sizing cell,以便我们得到正确的intrinsicContentSize。</p>

<h3>Once More With Auto Layout</h3>

<p>当我救助我的推友们关于如何得到基于约束的元素的大小，<a href="https://twitter.com/pilky">Martin Pilkington</a>迅速将我指向-systemLayoutSizeFittingSize:。一开始在应用中失败了，得到的全是{0,0}。但是当我写完上述解决办法，沉下心来又试了一次。</p>

<p>这一次它正常工作了。所需要做的是替换下面方法：
```objective-c
&ndash; (CGSize)collectionView:(UICollectionView <em>)collectionView layout:(UICollectionViewLayout</em>)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath
{
   [self <em>configureCell:</em>sizingCell forIndexPath:indexPath];</p>

<p>   return [_sizingCell systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
}
```</p>

<p>这个方法决定一个最接近传入大小的布局大小。两个标准值都可行，UILayoutFittingCompressedSize得到基于布局的最小大小，UILayoutFittingExpandedSize得到最大大小。</p>

<p>有了它我们可以很愉快地利用我们之前在intrinsicContentSize做的工作。我们也可以完全使用布局约束来进一步限制元素各个部分的大小。例如说：你可能想要短标签不要窄于某个宽度；如果某个标签太长了就让它截断。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView07" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView07.png" width="394" height="214"></p>

<p>结果如下，证明确实是我们想要的。</p>

<p><img name="Variable-Sized_Items_in_UICollectionView08" src="http://DamianSheldon.github.io/images/Variable-Sized_Items_in_UICollectionView08.png" width="396" height="744"></p>

<p>是不是很酷？让我们再强调一次：你不需要在Cell方法中计算大小，本质是重复了auto layout将要执行的计算。你只需要向系统要。</p>

<h3>总结</h3>

<p>在这篇博文中，我向你展示了如何为Collection view创建一个来自NIB的Cell。备选方法是在Storyboard中使用Collection view，它在某些方面更方便。这些Cell没有放在单独的XIB文件中，但是是在Collection view的结构层级中。探索如何得到一个sizing cell就作为练习留给读者了。</p>

<p>我们发现UILabel暴露一个intrinsicContentSize方法十分方便，如果你在Interface Builder指定了auto layout，它会用来计算大小。我们探索了一种方法，它使用一个cell实例作为模板来决定最佳的元素大小。然后我们更进一步运用了一个方法告诉我们基于布局约束和固定内容大小的完美尺寸。</p>

<p>例子的代码放在GitHub的<a href="https://github.com/Cocoanetics/Examples">Cocoanetics Examples</a> 仓库中。</p>

<h3>原文</h3>

<p><a href="http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/">http://www.cocoanetics.com/2013/08/variable-sized-items-in-uicollectionview/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iTunes 歌曲信息乱码的解决办法]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/11/03/music-import-from-windows-text-display-garbled-in-itunes/"/>
    <updated>2014-11-03T10:23:29+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/11/03/music-import-from-windows-text-display-garbled-in-itunes</id>
    <content type="html"><![CDATA[<p>从Windows迁移过来的歌曲在iTunes中乱码显示，按照Apple support里面的方法添加语言并没有解决问题，因此，我推测问题应该不是出在这。经过查找，发现问题是由于歌曲的ID3中的Enconding by字段的影响，也就是说，编码格式不一样。解决办法： <br/>
1)下载<a href="https://bitbucket.org/lazka/mutagen">Mutagen</a>; <br/>
2)安装Mutagen; <br/>
```bash</p>

<pre><code>$ path_to_mutagen/setup.py build
$ sudo path_to_mutagen/setup.py install
</code></pre>

<p><code>
3)先将所有歌曲备份，防止操作出错；  
4)将目录下的所有MP3歌曲的编码转成Unicode;  
</code>bash</p>

<pre><code>$find . -iname "*.mp3" -execdir mid3iconv -e gbk {} \;  
</code></pre>

<p>```
5)将iTunes中的音乐清空，重新添加。</p>

<p>Reference:<a href="http://floss.zoomquiet.io/data/20070510235547/index.html">http://floss.zoomquiet.io/data/20070510235547/index.html</a></p>
]]></content>
  </entry>
  
</feed>
