<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web development | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/web-development/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2020-04-27T11:09:28+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ionic App 使用 cordova hot code push 实现热更新]]></title>
    <link href="http://DamianSheldon.github.io/blog/ionic-app-use-cordova-hot-code-push-achieve-live-update.html"/>
    <updated>2020-01-07T17:02:35+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/ionic-app-use-cordova-hot-code-push-achieve-live-update</id>
    <content type="html"><![CDATA[<p>本文主要记录 Ionic App 使用 cordova hot code push 实现热更新时遇到问题的解决方法，另外也简单记录下使用方法，方便日后查阅。</p>

<p>Cordova hot code push 插件的原作者已经不维护了，我们可以选择一个可能最好的 fork 来使用。 <a href="http://gitpop2.herokuapp.com/">gitpop2</a> 可以帮助我们选择，我从中选择了当前 star 最多的一个 fork。</p>

<p>Ionic App 使用 cordova hot code push 实现热更新的基本步骤如下：</p>

<ol>
<li><p>在 ionic 工程中添加 cordova hot code push plugin</p>

<pre><code class="`"> $ ionic cordova plugin add https://github.com/snipking/cordova-hot-code-push.git
</code></pre></li>
<li><p>安装 Cordova Hot Code Push CLI client</p>

<pre><code class="`"> $ npm install -g cordova-hot-code-push-cli
</code></pre></li>
<li><p>为指定平台编译工程</p>

<pre><code class="`"> $ ionic cordova prepare android
</code></pre></li>
<li><p>执行插件初始化</p>

<pre><code class="`"> $ cd /path/to/project/root
 $ cordova-hcp init
</code></pre></li>
<li><p>生成插件配置文件</p>

<pre><code class="`"> $ cordova-hcp build
</code></pre></li>
<li><p>运行到设备上</p></li>
<li><p>开发和发布应用新版本的 web</p>

<pre><code class="`"> // 1. 开发
 // 2. 为指定平台编译工程生成 web 
 $ ionic build --engine=cordova --platform=android
 // 3. 生成新插件配置文件
 $ cordova-hcp build
 // 4. 部署到服务器
</code></pre></li>
</ol>


<p>在使用的过程中遇到的第一个问题是更新之后白屏。使用 Chrome 的 remote devices 调试 android webview 找到了问题的原因，ionic 应用中 <code>&lt;base href="http://DamianSheldon.github.io/" /&gt;</code>， cordova hot code push 会将 web 代码拷贝到外部存储上，webview 使用形如 <code>file:///data/user/0/com.tenneshop.liveupdatedemo/files/cordova-hot-code-push-plugin/2020.01.07-16.16.39/www/index.html</code> 的路径来加载应用，此时 <code>document.baseURI = /</code>，加载其他相对路径的 js 文件时，是相对这个路径，例如 <code>&lt;script src="cordova.js"&gt;&lt;/script&gt;</code>，就是以 <code>/cordova.js</code> 去加载，于是就会提示找不到文件。从上面的分析我们也知道，解决问题的一个办法是修正 base href 的值，我们可以在 index.html 的 head 元素加入下面的代码：</p>

<p>```</p>

<script>
    document.write('<base href="' + document.location.href + '" />');
</script>


<p>```</p>

<p>这样我们就修正文件路径的问题，很不巧，虽然文件的路径是对了，但是 ionic 默认不响应 file schema 的请求，我们需要做些工作，先让 WebViewLocalServer.java 支持响应 file schema，将 createHostingDetails 改成如下实现：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void createHostingDetails() {
</span><span class='line'>  final String assetPath = this.basePath;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  if (assetPath.indexOf(&lsquo;&lt;em>&rsquo;) != -1) {
</span><span class='line'>    throw new IllegalArgumentException(&ldquo;assetPath cannot contain the &lsquo;&lt;/em>&rsquo; character.&rdquo;);
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  PathHandler handler = new PathHandler() {
</span><span class='line'>    @Override
</span><span class='line'>    public InputStream handle(Uri url) {
</span><span class='line'>      InputStream stream = null;
</span><span class='line'>      String path = url.getPath();
</span><span class='line'>      try {
</span><span class='line'>        if (url.getScheme().equals(&ldquo;file&rdquo;)) {
</span><span class='line'>          stream = protocolHandler.openFile(path);
</span><span class='line'>        } else if (path.startsWith(contentStart)) {
</span><span class='line'>          stream = protocolHandler.openContentUrl(url);
</span><span class='line'>        } else if (path.startsWith(fileStart) || !isAsset) {
</span><span class='line'>          if (!path.startsWith(fileStart)) {
</span><span class='line'>            path = basePath + url.getPath();
</span><span class='line'>          }
</span><span class='line'>          stream = protocolHandler.openFile(path);
</span><span class='line'>        } else {
</span><span class='line'>          stream = protocolHandler.openAsset(assetPath + path);
</span><span class='line'>        }
</span><span class='line'>      } catch (IOException e) {
</span><span class='line'>        Log.e(TAG, &ldquo;Unable to open asset URL: &rdquo; + url);
</span><span class='line'>        Log.e(TAG, e.getLocalizedMessage());
</span><span class='line'>        return null;
</span><span class='line'>      }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>  return stream;
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  };&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  registerUriForScheme(httpScheme, handler, authority);
</span><span class='line'>  registerUriForScheme(httpsScheme, handler, authority);
</span><span class='line'>  if (!customScheme.equals(httpScheme) &amp;&amp; !customScheme.equals(httpsScheme)) {
</span><span class='line'>    registerUriForScheme(customScheme, handler, authority);
</span><span class='line'>  }&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  registerUriForScheme(&ldquo;file&rdquo;, handler, &ldquo;&rdquo;);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>然后是 isLocalFile 方法：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private boolean isLocalFile(Uri uri) {
</span><span class='line'>  String path = uri.getPath();
</span><span class='line'>  if (path.startsWith(contentStart) || path.startsWith(fileStart) || uri.getScheme().equals(&ldquo;file&rdquo;)) {
</span><span class='line'>    return true;
</span><span class='line'>  }
</span><span class='line'>  return false;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>做完这些工作后 ionic 就可以响应 file schema 请求了。</p>

<p>继续测试，我发现更新后第二次打开还是显示 App bundle asset 中的 web，这有点奇怪。仔细查看日志，确实有加载外部存储的 web , 但却被 <code>http://localhost/</code> 的请求覆盖了，这是什么原因呢？经过对代码逻辑的一番梳理，我发现是 IonicWebViewEngine 中 onPageStarted 方法的原因：</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onPageStarted(WebView view, String url, Bitmap favicon) {
</span><span class='line'>  super.onPageStarted(view, url, favicon);
</span><span class='line'>  String launchUrl = parser.getLaunchUrl();
</span><span class='line'>  if (!launchUrl.contains(WebViewLocalServer.httpsScheme) &amp;&amp; !launchUrl.contains(WebViewLocalServer.httpScheme) &amp;&amp; url.equals(launchUrl)) {
</span><span class='line'>    view.stopLoading();
</span><span class='line'>    // When using a custom scheme the app won&rsquo;t load if server start url doesn&rsquo;t end in /
</span><span class='line'>    String startUrl = CDV_LOCAL_SERVER;
</span><span class='line'>    if (!scheme.equalsIgnoreCase(WebViewLocalServer.httpsScheme) &amp;&amp; !scheme.equalsIgnoreCase(WebViewLocalServer.httpScheme)) {
</span><span class='line'>      startUrl += &ldquo;/&rdquo;;
</span><span class='line'>    }
</span><span class='line'>    view.loadUrl(startUrl);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>MainActivity 触发 webview 加载 <code>file:///android_asset/www/index.html</code>，然后 cordova hot code push plugin 启动工作，它会让 webview 加载外部存储的 web，之后 IonicWebViewEngine 的 onPageStarted 收到 <code>file:///android_asset/www/index.html</code> 的请求的回调，它先停止了 webview 的加载工作，即 cordova hot code push plugin 启动加载外部存储的 web 的请求，再开始 <code>http://localhost/</code> 的请求，也就是打印出来日志的记录。正是这个方法时序的问题导致成功更新之后再重启应用仍然加载 app bundle asset 的 web。一种解决办法是我们直接让 MainActivity 直接加载 <code>http://localhost/</code>，就像下面这样:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onCreate(Bundle savedInstanceState)
</span><span class='line'>{
</span><span class='line'>   super.onCreate(savedInstanceState);&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>   // enable Cordova apps to be started in the background
</span><span class='line'>   Bundle extras = getIntent().getExtras();
</span><span class='line'>   if (extras != null &amp;&amp; extras.getBoolean(&ldquo;cdvStartInBackground&rdquo;, false)) {
</span><span class='line'>       moveTaskToBack(true);
</span><span class='line'>   }
</span><span class='line'>   launchUrl = &ldquo;&lt;a href="http://localhost/">http://localhost/&lt;/a>&rdquo;;
</span><span class='line'>   // Set by &lt;content src="index.html" /> in config.xml
</span><span class='line'>   loadUrl(launchUrl);
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>这样热更新就可以正常工作了。</p>

<p>我继续做了点测试，又发现一个和 ionic icon 相关的问题，ionic 4 使用了 Fetch API 来请求 ionic icon 的 svg 资源，由于现在是使用 file schema 来指定资源路径，由于 Fetch API 不支持 file schema 所以就报错 <code>Fetch API cannot load file:///xxx/www/svg/md-star.svg. URL scheme "file" is not supported.</code> 我们得想办法来解决这个问题，一个办法替换 fetch 方法的实现，如:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;script>
</span><span class='line'>   document.write('&lt;base href="' + document.location.href + '" />');
</span><span class='line'>
</span><span class='line'>   var originalFetch = window.fetch;
</span><span class='line'>
</span><span class='line'>   window.fetch = function() {
</span><span class='line'>       var args = [];
</span><span class='line'>       for (var _i = 0; _i &lt; arguments.length; _i++) {
</span><span class='line'>           args[_i] = arguments[_i];
</span><span class='line'>       }
</span><span class='line'>       var url = args[0];
</span><span class='line'>       if (typeof url === 'string' && url.match(/\.svg/)) {
</span><span class='line'>           return new Promise(function(resolve, reject) {
</span><span class='line'>               var req = new XMLHttpRequest();
</span><span class='line'>               req.open('GET', url, true);
</span><span class='line'>               req.addEventListener('load', function() {
</span><span class='line'>                   resolve({
</span><span class='line'>                       ok: true,
</span><span class='line'>                       status: 200,
</span><span class='line'>                       text: function() {
</span><span class='line'>                           return Promise.resolve(req.responseText);
</span><span class='line'>                       }
</span><span class='line'>                   });
</span><span class='line'>               });
</span><span class='line'>               req.addEventListener('error', reject);
</span><span class='line'>               req.send();
</span><span class='line'>           });
</span><span class='line'>       } else {
</span><span class='line'>           return originalFetch.apply(void 0, args);
</span><span class='line'>       }
</span><span class='line'>   };
</span><span class='line'>&lt;/script>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>在这些测试过程中，我还发现 cordova hot code push 更新时只做了版本字符是否相等的判断，这在服务器端的版本低于本地版本时，插件仍然会做更新，这是有问题的，我们需要严格这里的判断，让它只有在服务端的版本高于本地版本时才做更新。相关代码位于 UpdateLoaderWorker 的 run 方法中。</p>

<p>最后一个要考虑的问题是如何将我们修改的代码和 ionic 的代码很好的整合起来？我现在的想法是创建一个私有的扩展 IonicWebViewEngine 和 WebViewLocalServer，然后借鉴 ionic 通过 config.xml 的 web 偏好设置的方法，像下面的代码:</p>

<pre><code>&lt;preference name="webView" value="com.ionicframework.cordova.webview.IonicWebViewEngine" /&gt;
</code></pre>

<p>回头测试下这个想法，好了有时间也许可以整理好代码提个 Pull Request。</p>

<p>Reference:</p>

<ul>
<li><a href="https://github.com/angular/angular/issues/13948">Cannot run angular 2+ from file:/// - looks like &lsquo;base href=&ldquo;http://DamianSheldon.github.io/&rdquo;&rsquo; is the issue</a></li>
<li><a href="https://github.com/ionic-team/ionicons/issues/572">IONIC v4: Icon won&rsquo;t work in android</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建 Cordova plugin 及其 Ionic Native]]></title>
    <link href="http://DamianSheldon.github.io/blog/create-cordova-plugin.html"/>
    <updated>2019-09-30T09:59:14+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/create-cordova-plugin</id>
    <content type="html"><![CDATA[<p>本文介绍如何创建 Cordova plugin 及其 Ionic Native，主要内容如下：</p>

<ul>
<li>Cordova Plugin 的工作原理</li>
<li>如何创建 Cordova Plugin</li>
<li>如何创建 Cordova Plugin 对应的 Ionic Native</li>
</ul>


<h3>Cordova Plugin 的工作原理</h3>

<p>我们简要介绍下 Cordova Plugin 的工作原理，这样我们才能解决在开发中遇到的问题。</p>

<p>Plugin js 端的入口方法签名形式如下:</p>

<pre><code>exec(&lt;successFunction&gt;, &lt;failFunction&gt;, &lt;service&gt;, &lt;action&gt;, [&lt;args&gt;]);
</code></pre>

<p>successFunction, failFunction 是成功和失败的回调函数，args 则是传递给原生端的参数。service, action 则是用来映射到原生端的对象和方法。这个映射是通过 plugin.xml 建立起来的。在 plugin.xml 中我们有如下元数据信息:</p>

<pre><code>&lt;feature name="&lt;service_name&gt;"&gt;
    &lt;param name="android-package" value="&lt;full_name_including_namespace&gt;" /&gt;
&lt;/feature&gt;
</code></pre>

<p>service 就是对应 service_name 指定的对象，而 action 则是该对象能处理方法。</p>

<p>具体是怎么映射的呢？</p>

<p>以 android 为例，我们安装的 plugin 信息会保存在 config.xml 中，<code>cordova prepare android</code> 命令会将 config.xml 在 android 的资源文件目录中生成一个同名文件，两个文件内容大致相同，plugin 的信息会改成如下形式表示：</p>

<pre><code>&lt;feature name="&lt;service_name&gt;"&gt;
    &lt;param name="android-package" value="&lt;full_name_including_namespace&gt;" /&gt;
&lt;/feature&gt;
</code></pre>

<p>这个形式就是我们上面见过的形式。</p>

<p>当 js 端调用 exec 方法时，它会通过 webview 建立的通信通道(通常是用 WebView.addJavascriptInterface)调用 PluginManager 的 exec 方法，PluginManager 则根据 service_name 查找或创建 plugin ，然后调用 plugin 的 exec 方法，并将 action 作为参数传入，于是我们便可按需响应 action 请求。</p>

<h3>如何创建 Cordova Plugin</h3>

<h4>安装 plugman</h4>

<pre><code>$ npm install -g plugman
</code></pre>

<h4>创建 cordova plugin</h4>

<pre><code>$ plugman create --name &lt;pluginName&gt; --plugin_id &lt;pluginID&gt; --plugin_version &lt;version&gt; [--path &lt;directory&gt;] [--variable NAME=VALUE]

eg.
$plugman create --name cordova-plugin-onsite-signature --plugin_id cordova-plugin-onsite-signature --plugin_version 0.0.1
</code></pre>

<h4>添加 platform</h4>

<pre><code>$plugman platform add --platform_name android
</code></pre>

<h4>创建 package.json 文件</h4>

<pre><code>$ plugman createpackagejson &lt;directory&gt;

eg.
$plugman createpackagejson .
</code></pre>

<h4>安装 cordova plugin</h4>

<pre><code>// 方法一：这种方式的命令和添加官方的插件类似，个人推荐此方法，可以少记一个命令
$cordova plugin add git+ssh://git@192.168.8.91/git/cordova-plugin-onsite-signature.git

// 方法二：
$ plugman install --platform android --project platforms/android --plugin ../LogicLinkPlugin/
</code></pre>

<h4>卸载 cordova plugin</h4>

<pre><code>// 与安装的方法对应有两种卸载方法
// 方法一：$cordova plugin remove cordova-plugin-onsite-signature

// 方法二：
$ plugman uninstall --platform android --project platforms/android --plugin ../LogicLinkPlugin/
</code></pre>

<h4>发布</h4>

<pre><code>// Create a tag
$git tag &lt;tagname&gt;

// Push to repository
$git push origin master
</code></pre>

<h4>升级 cordova plugin</h4>

<p>现在暂时没有直接升级的命令，采用的是先卸载后安装新版本的方法。</p>

<h3>如何创建 Cordova Plugin 对应的 Ionic Native</h3>

<h4>Creating Plugin Wrappers</h4>

<pre><code>// Navigate to ionic-native root path
$cd  ionic-native

// Install dependencies first time
$npm install

// Create plugin wrapper
// When gulp installed locally
$npx gulp plugin:create -n PluginName

// When gulp installed globally
$gulp plugin:create -n PluginName
</code></pre>

<h4>安装</h4>

<pre><code>// You need to run npm run build in the ionic-native project, this will create a dist directory. The dist directory will contain a sub directory @ionic-native with all the packages compiled in there.
$npm run build

//Copy the package(s) you created/modified to your app's node_modules under the @ionic-native directory.
$cp -r dist/@ionic-native/plugin-name ../my-app/node_modules/@ionic-native/
</code></pre>

<h3>使用</h3>

<pre><code>// Import the plugin in a @NgModule and add it to the list of Providers. 
// app.module.ts
import { APIClient } from '@ionic-native/api-client/ngx';
...

@NgModule({
  ...

  providers: [
    ...
    APIClient
    ...
  ]
  ...
})
export class AppModule { }

// After the plugin has been declared, it can be imported and injected like any other service:

// login.service.ts
import { APIClient } from '@ionic-native/api-client/ngx';
import { ServiceName } from '@ionic-native/api-client/ngx';

constructor(private apiClient: APIClient) { }

this.apiClient.get(ServiceName.Login, JSON.stringify(user))
      .then((result: string) =&gt; {
        console.log('api client login:', result);
        //TODO: Parse server return json to UserExt object
        const routePath = this.simulateLogin(username);        
        resolve(routePath);
      })
      .catch((error: string) =&gt; {
        console.log('api client login error:', error);

        reject(error);
      });
</code></pre>

<h1>Reference:</h1>

<ul>
<li><a href="https://github.com/RootSoft/Create-a-custom-Cordova-plugin">Create-a-custom-Cordova-plugin</a></li>
<li><a href="https://github.com/ionic-team/ionic-native/blob/master/DEVELOPER.md">Ionic Native Developer Guide</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 开发问题汇总(四)]]></title>
    <link href="http://DamianSheldon.github.io/blog/web-development-notes-part-four.html"/>
    <updated>2019-07-16T17:24:01+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/web-development-notes-part-four</id>
    <content type="html"><![CDATA[<h3>1.如何实现如下布局：两个元素A和B，其中A的宽度为包裹其内容，B则占用剩余的宽度？</h3>

<p>A:A 元素利用 float 的包裹性，B 元素则利用 BFC。</p>

<p>```</p>

<div class="container">
    <div class="right"></div>
    <div class="left"></div>
</div>


<p>.container {
    width:600px;
    height:200px;
    border:1px solid;
}
.left {
    width:auto;
    height:200px;
    background:red;
    overflow:hidden;
}
.right {
    height:200px;
    width:200px;
    background:blue;
    float:left;
}
```</p>

<p>Reference:<a href="https://stackoverflow.com/questions/1260122/expand-a-div-to-fill-the-remaining-width">Expand a div to fill the remaining width</a></p>

<h3>2.Meaning of ~ in import of scss files</h3>

<p>A:</p>

<blockquote><p>From documentation on a <code>sass-loader#imports</code> project,</p>

<blockquote><p>webpack provides an advanced mechanism to resolve files. The sass-loader uses node-sass' custom importer feature to pass all queries to the webpack resolving engine. Thus you can import your Sass modules from node_modules. Just prepend them with a ~ to tell webpack that this is not a relative import</p></blockquote>

<p>So if you have a file named foo.css and a module foo then you would use ~ if you want to include the module.</p></blockquote>

<p>Reference:<a href="https://stackoverflow.com/questions/38880187/meaning-of-in-import-of-scss-files">Meaning of ~ in import of scss files</a></p>

<!--more-->


<h3>3.为什么创建 Observable 时传入的函数签名不需要包含 this? 示例如下:</h3>

<pre><code>// API Document:
constructor(subscribe?: (this: Observable&lt;T&gt;, subscriber: Subscriber&lt;T&gt;) =&gt; TeardownLogic)

// Usage code:
const observable = new Observable(subscriber =&gt; {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() =&gt; {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});
</code></pre>

<p>A:Here this is a special syntax in Typescript. It specifies the type of the &ldquo;this&rdquo; the function expects. So here it just means it should be called by a Observable with the same Type T as the Subscriber.</p>

<p>It comes first in the parameter list. It is a fake parameter, and should invoked without it.</p>

<p>More info can be found <a href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#specifying-the-type-of-this-for-functions">Here</a>.</p>

<p>Reference:<a href="https://stackoverflow.com/questions/54886652/confused-by-rxjs-observable-constructor-and-this-argument">Confused by Rxjs Observable constructor and &lsquo;this&rsquo; argument</a></p>

<h3>4.How to make a div take the remaining height?</h3>

<p>A:</p>

<ol>
<li>Flex</li>
<li>Absolute Positioning</li>
<li>Table</li>
<li>CSS3 cacl</li>
</ol>


<p>Reference:<a href="https://www.whitebyte.info/programming/css/how-to-make-a-div-take-the-remaining-height">How to make a div take the remaining height</a></p>

<h3>5.Dynamic modal height based on content in Ionic4?</h3>

<p>A:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Modal page template:&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;div class="inner-content">
</span><span class='line'>    &lt;!-- Construct your view hierarchy here-->
</span><span class='line'>&lt;/div>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;p>// Present method:
</span><span class='line'>async presentAutoHeightModal() {
</span><span class='line'>    const modal = await this.modalController.create({
</span><span class='line'>      component: AutoHeightModalPage,
</span><span class='line'>      cssClass: &lsquo;auto-height&rsquo;
</span><span class='line'>    });&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>return await modal.present();
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>// app.scss
</span><span class='line'>ion-modal.auto-height {
</span><span class='line'>    flex-direction: column;
</span><span class='line'>    justify-content: flex-end;
</span><span class='line'>    &ndash;height: auto;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>.ion-page {
</span><span class='line'>    position: relative;
</span><span class='line'>    display: block;
</span><span class='line'>    contain: content;
</span><span class='line'>
</span><span class='line'>    .inner-content {
</span><span class='line'>        max-height: 80vh;
</span><span class='line'>        overflow: auto;
</span><span class='line'>        padding: 10px;
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></p>

<h3>6.Invalid Host Header</h3>

<p>A:通过外网访问本地的 ionic 开发服务时提示 Invalid Host Header，原因是 angular 默认会对 host 进行验证，所以我们可以通过传入 <code>--disableHostCheck=true</code> 来关闭验证，由于是 ionic 工程，我们传入的参数需要在 <code>--</code> 之后，也就是类似如下命令: <code>ionic serve --port 8080 -- --disableHostCheck=true</code>.</p>

<blockquote><p>ionic serve uses the Angular CLI. Use ng serve &ndash;help to list all Angular CLI options for serving your app. See the ng serve docs[1] for explanations. Options not listed below are considered advanced and can be passed to the Angular CLI using the &ndash; separator after the Ionic CLI arguments.</p></blockquote>

<p>Reference:<a href="https://community.c9.io/t/ionic-4-angular-invalid-host-header-error/25526">Ionic 4 angular - Invalid Host header error</a></p>

<p>Reference:</p>

<ul>
<li><a href="https://forum.ionicframework.com/t/dynamic-modal-height-based-on-content-in-ionic-v4/139595">Dynamic modal height based on content in Ionic v4</a></li>
<li><a href="https://github.com/ionic-team/ionic/issues/16852">resize modal based on content</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[浅析移动端跨平台开发]]></title>
    <link href="http://DamianSheldon.github.io/blog/an-introduction-to-mobile-cross-platform-development.html"/>
    <updated>2019-04-15T17:04:39+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/an-introduction-to-mobile-cross-platform-development</id>
    <content type="html"><![CDATA[<p>最近几年随着移动端开发日益成熟以及 Web 技术的快速发展，跨平台开发技术如雨后春笋一般冒出来，这是所有从业者不能忽视的现象。这种现象导致很多公司主动或被动去研究相关的技术。我也不例外，对它的研究应该是夹杂着被动和主动。作为原生开发者，本来对日常的开发工作驾轻就熟，恐怕内心本身不会有太多意愿去迁移到新的技术，至少我一开始是这种心态；另一方面，跨平台开发在行业内日益受到关注，倒逼开发者去了解它、研究它。对于变化，我们可能本能的抗拒，但内心理性的声音告诉我们：变化是永恒的不变，我们应该拥抱变化。</p>

<p>在经过一段时间的学习和研究，自己觉得对它的认识更加清晰和深刻，于是决定将它们记下来，以便日后记忆模糊了帮助回忆，也可以验证对于它发展的看法。我这里主要谈谈自己对它的看法，技术选择，以及这种技术的基本使用流程。</p>

<p>跨平台开发不是什么新概念，我觉得这是一种很自然的想法。因为我们总是想减轻自己的工作负担，公司则会想减少成本，提高效率，于是就会想能不能一套代码跑到多个平台，两套代码合并成一套，应该可以删除掉不少重复代码，开发和维护的代码量就少了，可能也不需要那么多开发人员了，应该来说还是很有吸引力的。</p>

<p>不过我觉得问题不像看起来那么简单。上面提到了很多跨平台开发的优点，但它也有自己的缺点。而且看到很多二变为一，很容易认为是在减少，加上业界大厂分享的成功经验，更是验证这种想法。但我想强调具体情况具体分析，这里有一个很重要的点，我们所在的公司开发人员水平和大厂肯定是不一样的，所以它能取得成功，我们不一定能玩得转。所以当两套代码合并成一套，在大厂可能确实减少了开发和维护工作，但我们自己的情况可能就不一定了，因为这对开发人员的技术水平要求要高不少，这是需要考虑的一个问题。当我们在一些项目上使用跨平台技术开发时，如果能本着实事求是的态度，相信会更容易成功。有了这些认识，接下来，我们具体来看看跨平台开发技术。</p>

<p>当我们想跨平台时，我们就会寻找平台的共同之处，应该来讲目光很容易聚焦到 Web 技术上。移动端都可以使用 Web 技术，而且它在桌面端已经实现，可以说是一个不错的选择，于是就可以尝试从这里突破。本质上其实就是 Web 应用，我们要做是将设备的能力提供给 Web，Cordova 则是这方面的一个代表。</p>

<p>我认为移动端 Web 应用的主要问题还是性能，虽然现在硬件性能很强悍，但是很多 Web 应用和原生的体验还是有不小差别，所以这时就要权衡了。那能不能有个完美的解决方案呢？既然性能有问题，我们是不可以想办法优化性能，让它和原生体验一样？我认为 React Native 是顺着这种思路出现的，它使用 javascript 编码，最终设备上运行的是原生代码，即然是运行原生代码，性能自然可以做到和原生一致。虽然性能问题是解决了，但它需要用 javascript 编写多套代码，而且开发人员也要懂原生开发，或者有原生开发支持，不然遇到问题恐怕不好解决。</p>

<!--more-->


<p>除了 Cordova 和 React Native，Google 最近还推出 Flutter，由于技术栈差异很大，以及个人精力有限，暂时不打算研究。我决定在 Cordova 和 React Native 中选择。React Native 虽然性能不错，但各平台需要自己的代码，这和一份代码的初衷不符；另外它动态部署事件的能力也稍逊一筹，框架本身的发展和原生藕合很紧密。基于这些原因，我偏向选择 Cordova。</p>

<p>Cordova 让 Web 访问设备的能力比较方便，屏蔽了很多差异，但是它没有提供 UI 支持，如果我们想做出漂亮的界面，需要自己做，或者更好的办法是找一个好用的 UI 库。而且最好是搭配一个 SPA 框架，因为我们的应用通常不会只有一个界面，SPA 可以帮助我们在单个 WebView 里实现应用的功能。至此我们的脉络应该是比较清晰了，综合这些信息，我觉得 ionic 是个不错的选择。对于原生开发者，我们一开始可能对 Web 技术不是很熟悉，ionic 将相关技术整合在一起，这降低了学习的门槛。说到这里，我想起在前期，在搜索过程中，很多国产的跨平台技术映入眼帘，如 APICloud, DCloud,但我觉得技术群众基础也很重要，这样我们学的技术在其他公司能有用武之地，也容易招到合适的人才，综合考虑便没有选择这些技术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Web 界面布局]]></title>
    <link href="http://DamianSheldon.github.io/blog/web-ui-layout.html"/>
    <updated>2019-03-06T09:27:15+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/web-ui-layout</id>
    <content type="html"><![CDATA[<p>Web 应用程序是用户与软件系统的接口，用户通过她与系统进行交互。在 Web 应用程序的开发过程中，实现交互界面占工作内容的很大一部分比例，界面布局则又是这其中的重要组成部分，所以她值得我们花时间去掌握，以便完成工作任务，进而提高工作效率。</p>

<p>Web 诞生的背景是更好的共享信息，而这信息起初便是文字、图片。为了展示图文信息，涌现出了很多布局方式，一种称为流的布局方式在竞争中胜出了。</p>

<p>在这种布局方式中，界面元素被大体分为两类：一类是块级元素；另一类是是内联元素。块级元素负责结构布局，内联元素负责内容。在默认情况下，块级元素会像水流一样填满容器的宽度，内联元素则是从左至右，从上往下堆叠。很显然完全使用默认的布局行为是不能完成所有的需求的，于是在此基础上通过破坏流演化出新的布局行为，进而来满足我们的各种布局需求。所以总结下来，Web 的布局方法主要是如下几种：</p>

<ul>
<li>默认流布局行为</li>
<li>Float</li>
<li>Positioning</li>
<li>Table layout</li>
<li>Flexbox</li>
<li>Grid</li>
</ul>


<p>界面布局的核心任务是控制界面元素的位置和大小。前面我们说过块级元素负责结构布局，所以位置主要是由她来控制。元素的布局信息是通过盒模型来表达的，下面是她的示意图：</p>

<p><img class="center" src="/images/css-box-model.png"></p>

<p>margin 控制块元素间的间隙，padding 控制内容与块元素边框的间隙，所以可以用来控制位置。虽然 margin 是用来控制元素间的间隙，但我们通常可能希望将这种影响局部化，不然由于浏览器窗口大小变化，页面布局会受到很大影响，是与我们流布局的理念相挬的。因此她们主要是用在功能块内部。</p>

<p>在页面布局时，通常会将各功能用块元素包裹起来，这样可以简化布局工作。于是页面就由一棵元素树组成，类似下图:</p>

<p><img class="center" src="/images/html-element-tree.png"></p>

<p>在默认的流布局行为下，块元素的位置很有限，要么从布局容器的左上角开始，要么放在前一个块元素下面，这样恐怕不能完成多样的布局需求。只有拥有能布局到任意位置的能力，才能担此重任。于是需要借助 Positioning 和 Float 布局方法。</p>

<p>Positioning 布局方法是通过改变元素的 position 值来改变她的位置，她可能的值为：<code>static | relative | absolute| fixed</code>，static 是默认值，relative 是相对默认位置定位，absolute 是相对父元素中第一个不为 static 的元素定位，fixed 则是相对 viewport，这些属性大大增强了布局定位能力。</p>

<!--more-->


<p>除了 Positioning 可以改变破坏流，Float 也可以。她本身是用来实现文字环绕图片的效果，但这种特性也可以用来实现布局。这些布局方法在处理某些界面布局时非常困难，甚至不可能，于是 Flexbox, Grid 等的新布局方法出现了。所以总结一下就是，默认流布局行为、Float 和 Positioning 可以控制块元素在容器中的位置，而 Table layout、 Flexbox 和 Grid 主要是控制布局容器内部的布局行为。</p>

<p>梳理完控制位置的方法，我们来看下元素的大小。先看内联非替换元素，它的大小与 font-size 和包含的内容相关。而内联替换元素的大小计算规则要复杂些，基本规则是依次取如下尺寸:</p>

<ul>
<li>CSS 尺寸；</li>
<li>HTML 尺寸；</li>
<li>固有尺寸；</li>
</ul>


<p>祼露的 <code>&lt;img&gt;</code> 元素是个例外，需要留意下，但不影响内在的梳理脉胳。</p>

<p>块级替换元素使用内联替换元素相同的计算规则。所以，我们重点来看下块级非替换元素的尺寸计算。首先，我们肯定可以使用 width 和 height 直接设置她的尺寸，但如果是应用在页面的主体结构布局上是和流布局的理念想违背，我们希望她的宽度是自动填满布局容器，高度是基于她的内容，也就是内联元素。</p>

<p>块元素内部每行内联元素由行框盒子包含，有多少行就有多少个行框盒子，而 <code>line-height</code> 以决定行框盒子的高度，所以块级非替换元素主要由 <code>line-height</code> 决定高度。但是她也受 <code>vertical-align</code> 的影响，这时候由于内联元素和幽灵空白节点的默认基线对齐影响，会造成高度会有些许变化，这是我们需要注意的。</p>

<h2>Reference</h2>

<ul>
<li>CSS 世界</li>
</ul>

]]></content>
  </entry>
  
</feed>
