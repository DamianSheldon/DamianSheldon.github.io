<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Archives | Hello World]]></title>
  <link href="http://DamianSheldon.github.io/blog/categories/archives/atom.xml" rel="self"/>
  <link href="http://DamianSheldon.github.io/"/>
  <updated>2014-08-25T21:01:02+08:00</updated>
  <id>http://DamianSheldon.github.io/</id>
  <author>
    <name><![CDATA[Sheldon]]></name>
    <email><![CDATA[dongmeilianghy@sina.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[改变UIView的Frame时遇到的问题]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti/"/>
    <updated>2014-08-25T17:09:49+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/08/25/gai-bian-uiviewde-frameshi-yu-dao-de-wen-ti</id>
    <content type="html"><![CDATA[<p>  问题描述：Storyboard中的ViewController上添加一个自定义的view,声明为IBOutlet然后用代码改变view的Frame,打印输出Frame的值确实改变了，但是模拟器上的视图的Frame还是没有改变。</p>

<p>  解决办法：Google找到Stackoverflow上有人说是选中了Auto layout的原因，取消之后确实生效了。PS:但是不知道问题的原因是什么。</p>

<p>Reference:<br/>
o <a href="http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work">http://stackoverflow.com/questions/18263359/setting-the-frame-of-an-uiview-does-not-work</a></p>

<p>问题描述：在switch语句中，如果在case中要定义变量的话要加上大括号。</p>

<p>原因：Case statements are only &lsquo;labels&rsquo;. This means the compiler will interpret this as a jump directly to the label.The problem here is one of scope. Your curly brackets define the scope as everything inside the &lsquo;switch&rsquo; statement. This means that you are left with a scope where a jump will be performed further into the code skipping the initialization. The correct way to handle this is to define a scope specific to that case statement and define your variable within it.</p>

<p>Reference:<a href="http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439">http://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement/92439#92439</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift Learning Notes -- Properties]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties/"/>
    <updated>2014-06-24T15:28:20+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/06/24/swift-learning-notes-properties</id>
    <content type="html"><![CDATA[<h3>Properties</h3>

<p>“Properties associate values with a particular class, structure, or enumeration. ” &mdash; Apple</p>

<h4>Type Properties</h4>

<p>属于类型本身的properties称为Type Property.</p>

<p>1)Value Type Properties (keyword: static)<br/>
structrue, enumeration可以定义Stroed 和Computed type properties.</p>

<p>Stored type properties for value types can be variables or constants.<br/>
NOTE:Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself does not have an initializer that can assign a value to a stored type property at initialization time.</p>

<p>Computed type properties are always declared as variable properties, in the same way as computed instance properties.</p>

<p>2)Reference Type Properties (keyword: class)<br/>
class只可以定义Computed type properties.</p>

<h4>Instance Properties</h4>

<p>1)Stroed Properties
In its simplest form, a stored property is a constant or variable that is stored as part of an instance of a particular class or structure. Stored properties can be either variable stored properties (introduced by the var keyword) or constant stored properties (introduced by the let keyword).</p>

<p>P.S:A lazy stored property is a property whose initial value is not calculated until the first time it is used. You indicate a lazy stored property by writing the @lazy attribute before its declaration.</p>

<p>2)Computed Properties
computed properties, which do not actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>

<h3>Properties Observer</h3>

<p>Property observers observe and respond to changes in a property’s value.</p>

<p>You have the option to define either or both of these observers on a property:</p>

<p>willSet is called just before the value is stored.<br/>
didSet is called immediately after the new value is stored.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Concurrency Programming--GCD]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/21/ios-concurrency-programming-gcd/"/>
    <updated>2014-05-21T11:40:27+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/21/ios-concurrency-programming-gcd</id>
    <content type="html"><![CDATA[<h2>GCD是什么？</h2>

<p>GCD是Grand Central Dispatch的缩写，它是用来执行自定义的任务的C接口机制。它可以串行或并行地执行任务，并大大简化了相应的线程代码。它的优点有：<br/>
* 直接简单的编程接口；<br/>
* 自动、整体的线程池管理；<br/>
* 高效的内存管理；<br/>
* 负载时不干扰内核；<br/>
* 异步分发任务到分派队列不会造成死锁；<br/>
* 优雅地处理竞争；<br/>
* 串行分派队列为锁和其他同步操作提供了更高效选择；</p>

<h2>如何使用GCD？</h2>

<p>GCD抽象出来了几组高效的的API,我们使用这些API来完成我们的工作。</p>

<h3>1）单个任务；</h3>

<p>我们通常是通过调用以下API来执行任务：
<code>objective-c
dispatch_async
dispatch_async_f
dispatch_sync
dispatch_sync_f
dispatch_after
dispatch_after_f
dispatch_apply
dispatch_apply_f
dispatch_once
</code></p>

<p>调用这些API之前，我们还要准备好dispatch queue.通常可以通过以下的API创建和管理Queues:
<code>objective-c
dispatch_get_global_queue
dispatch_get_main_queue
dispatch_queue_create
dispatch_get_current_queue
dispatch_queue_get_label
dispatch_set_target_queue
dispatch_main
</code></p>

<p>dispatch queues主要有三大类：main queue, Concurrent queue, Serial queue;</p>

<p>i)main queue:通过dispatch_get_main_queue(void)可以取到main queue;</p>

<p>ii)Concurrent queue:通过dispatch_queue_t dispatch_get_global_queue(long priority,unsigned long flags)可以取得全局的并发队列。总共有四个优先级的全局队列：
 DISPATCH_QUEUE_PRIORITY_HIGH      <br/>
 DISPATCH_QUEUE_PRIORITY_DEFAULT
 DISPATCH_QUEUE_PRIORITY_LOW      <br/>
 DISPATCH_QUEUE_PRIORITY_BACKGROUND</p>

<p>iii）Serial queue:可以使用dispatch_queue_create创建串行或并行队列。</p>

<p>代码示例：
``` objective-c
// i) main queue
dispatch_queue_t mainQueue = dispatch_get_main_queue(void);</p>

<p>// ii)Concurrent Queue
dispatch_queue defaultGlobalConcurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>// iii)Serial queue
dispatch_queue_t myCustomSerialQueue = dispatch_queue_create(&ldquo;com.example.MyCustomSerialQueue&rdquo;, NULL);</p>

<p>// async
dispatch_async(myCustomSerialQueue, ^{</p>

<pre><code>printf("Do some work here.\n");
</code></pre>

<p>});</p>

<p>// sync
dispatch_sync(myCustomSerialQueue, ^{</p>

<pre><code>printf("Do some more work here.\n");
</code></pre>

<p>});
printf(&ldquo;Both blocks have completed.\n&rdquo;);</p>

<p>// apply
for (i = 0; i &lt; count; i++) {
   printf(&ldquo;%u\n&rdquo;,i);
}</p>

<p>// equlivent implement</p>

<p>dispatch_apply(count, defaultGlobalConcurrentQueue, ^(size_t i) {
   printf(&ldquo;%u\n&rdquo;,i);
});
```</p>

<h3>2）组任务；</h3>

<p>可以使用以下API进行组操作：
<code>objective-c
dispatch_group_async
dispatch_group_async_f
dispatch_group_create
dispatch_group_enter
dispatch_group_leave
dispatch_group_notify
dispatch_group_notify_f
dispatch_group_wait
</code>
代码示例：
``` objective-c
// Example 1
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>

<p>dispatch_group_t group = dispatch_group_create();</p>

<p>// Add a task to the group
dispatch_group_async(group, queue, ^{
   // Some asynchronous work
});</p>

<p>// Do some other work while the tasks execute.</p>

<p>// When you cannot make any more forward progress,
// wait on the group to block the current thread.
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</p>

<p>// Release the group when it is no longer needed.
dispatch_release(group);</p>

<p>// Example 2
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(id obj in array)</p>

<pre><code>dispatch_group_async(group, queue, ^{
    [self doWorkOnItem:obj];
});
</code></pre>

<p>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
[self doWorkOnArray:array];</p>

<p>```</p>

<h3>3）使用Dispatch Semaphores调控有效的资源使用；</h3>

<p>Dispatch Semaphores相关的API如下：
<code>objective-c
dispatch_semaphore_create
dispatch_semaphore_signal
dispatch_semaphore_wait
</code>
代码示例：
```objective-c
// Create the semaphore, specifying the initial pool size
dispatch_semaphore_t fd_sema = dispatch_semaphore_create(getdtablesize() / 2);</p>

<p>// Wait for a free file descriptor
dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);
fd = open(&ldquo;/etc/services&rdquo;, O_RDONLY);</p>

<p>// Release the file descriptor when done
close(fd);
dispatch_semaphore_signal(fd_sema);
```</p>

<h2>Reference</h2>

<p>o Concurrency Programming Guide<br/>
o iOS多线程编程Part 3/3 &ndash; GCD;<a href="http://www.hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/">http://www.hrchen.com/2013/07/multi-threading-programming-of-ios-part-3/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的绘图系统]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/19/iosde-hui-tu-xi-tong/"/>
    <updated>2014-05-19T16:47:22+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/19/iosde-hui-tu-xi-tong</id>
    <content type="html"><![CDATA[<h2>iOS的绘图框架</h2>

<p>1)UIKit是Objective-C形式的API，提供基本的2D图形绘制，图片处理，和一些实现用户界面元素动画的方法；</p>

<p>2)Core Graphics是C形式的API，支持向量图形，位图和PDF内容；</p>

<p>3)Core Animation是另一个Objective-C形式的API,它能为用户界面增加流畅的移动和动态的反馈效果；</p>

<p>4)OpenGL ES 是移动端版本的OpenGL,它能实现高性能的2D和3D图形绘制。</p>

<h2>Drawing Destinations(iOS-Only)</h2>

<p>1)View Graphics Context<br/>
2)Layer<br/>
3)Bitmap<br/>
4)PDF<br/>
5)Printer</p>

<h2>Drawing to a View Graphics Context in iOS</h2>

<p>1)Implement drawRect:method;<br/>
2)Mark the view you want update by invocate setNeedDisplay;<br/>
3)Obtain Graphic context by Call UIGraphicsGetCurrentContext method;<br/>
4)Use UIKit provides functions, UIBezierPath or Core Graphics to meet your need.</p>

<p>``` objective-c
// 1) UIKit method
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
[path addLineToPoint:CGPointMake(0.4, 18.05)];
[path addLineToPoint:CGPointMake(18.8, -0.47)];
[path addLineToPoint:CGPointMake(37.21, 18.05)];
[path addLineToPoint:CGPointMake(34.31, 20.83)];
[path addLineToPoint:CGPointMake(20.88, 7.22)];
[path addLineToPoint:CGPointMake(20.88, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 42.18)];
[path addLineToPoint:CGPointMake(16.72, 7.22)];
[path closePath];
path.lineWidth = 1;
[[UIColor redColor] setStroke];
[path stroke];</p>

<p>// 2) Core Graphics method
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
CGContextAddLineToPoint(ctx, 0.4, 18.05);
CGContextAddLineToPoint(ctx, 18.8, -0.47);
CGContextAddLineToPoint(ctx, 37.21, 18.05);
CGContextAddLineToPoint(ctx, 34.31, 20.83);
CGContextAddLineToPoint(ctx, 20.88, 7.22);
CGContextAddLineToPoint(ctx, 20.88, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 42.18);
CGContextAddLineToPoint(ctx, 16.72, 7.22);
CGContextClosePath(ctx);
CGContextSetLineWidth(ctx, 1);
CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextStrokePath(ctx);
```</p>

<h2>Drawing to a Layer(CGLayer)</h2>

<p>A layer context (CGLayerRef) is an offscreen drawing destination associated with another graphics context. It is designed for optimal performance when drawing the layer to the graphics context that created it. A layer context can be a much better choice for offscreen drawing than a bitmap graphics context.</p>

<p>1)“Create a CGLayer Object Initialized with an Existing Graphics Context”<br/>
2)“Get a Graphics Context for the Layer”<br/>
3)“Draw to the CGLayer Graphics Context”<br/>
4)“Draw the Layer to the Destination Graphics Context”</p>

<h2>Drawing to a BitMap</h2>

<p>A bitmap graphics context accepts a pointer to a memory buffer that contains storage space for the bitmap. When you paint into the bitmap graphics context, the buffer is updated. After you release the graphics context, you have a fully updated bitmap in the pixel format you specify.</p>

<p>1)Creating a Bitmap Graphics Context;<br/>
UIGraphicsBeginImageContextWithOptions() or CGBitmapContextCeate()<br/>
2)Draw code.</p>

<p>``` objective-c
// 1) Mix call UIKit and Core Graphics</p>

<p>UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2);
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextBeginPath(ctx);
CGContextMoveToPoint(ctx, 16.72, 7.22);
CGContextAddLineToPoint(ctx, 3.29, 20.83);
&hellip;
CGContextStrokePath(ctx);
UIGraphicsEndImageContext();</p>

<p>// 2) Core Graphics
CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo);
CGContextScaleCTM(ctx, 0.5, 0.5);
UIGraphicsPushContext(ctx);
UIBezierPath *path = [UIBezierPath bezierPath];
[path moveToPoint:CGPointMake(16.72, 7.22)];
[path addLineToPoint:CGPointMake(3.29, 20.83)];
&hellip;
[path stroke];
UIGraphicsPopContext(ctx);
CGContextRelease(ctx);
```</p>

<h2>Concurrency Drawing</h2>

<p>``` objective-c
UIImageView <em>view; // assume we have this
NSOperationQueue </em>renderQueue; // assume we have this
CGSize size = view.bounds.size;
[renderQueue addOperationWithBlock:^(){</p>

<pre><code>    UIImage *image = [renderer renderInImageOfSize:size];
    [[NSOperationQueue mainQueue] addOperationWithBlock:^(){
        view.image = image;
    }];
</code></pre>

<p>}];</p>

<ul>
<li><p>(UIImage *)renderInImageOfSize:(CGSize)size;
{
  UIGraphicsBeginImageContextWithOptions(size, NO, 0);</p>

<p>  // do drawing here</p>

<p>  UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
  UIGraphicsEndImageContext();
  return result;
}
```</p></li>
</ul>


<h2>Reference</h2>

<p>o Quartz 2D Programming Guide<br/>
o 绘制像素到屏幕上 <a href="http://objccn.io/issue-3-1/">http://objccn.io/issue-3-1/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tips and Techniques for Framework Developers(Translation)]]></title>
    <link href="http://DamianSheldon.github.io/blog/2014/05/10/tips-and-techniques-for-framework-developers-translation/"/>
    <updated>2014-05-10T09:23:09+08:00</updated>
    <id>http://DamianSheldon.github.io/blog/2014/05/10/tips-and-techniques-for-framework-developers-translation</id>
    <content type="html"><![CDATA[<h2>Initialization</h2>

<h3>Class initialization</h3>

<p>initialize 类方法是一个一次性，懒散的执行一些代码的地方，它会在类的其他方法被调用之前调用。最典型的应用是设置类的版本号。
动态系统给继承链上每一个类发送initialize方法，即使方法没有实现。因此它可能会被调用多次（例如，一个子类没有实现它。）。通常我们只想初始化代码被执行一次。一种实现的方法是使用dispatch_once();
``` objective-c</p>

<pre><code>+ (void)initialize {

static dispatch_once_t onceToken = 0;

dispatch_once(&amp;onceToken, ^{

    // the initializing code

}
</code></pre>

<p>}
```</p>

<p>Note:因为动态系统发送initialize给每一个类，所以它很可能会在子类的上下文中调用—如果子类没有实现initialize，会调用父类的实现。如果在相关类的上下文中有特殊的初始化需求，我们可以进行如下操作而不仅仅是使用dispatch_once();</p>

<p>``` objective-c
if (self == [NSFoo class]) {</p>

<pre><code>// the initializing code
</code></pre>

<p>}
```</p>

<p>你永远不应显式的调用initialize方法。如果你需要触发初始化，调用一些没有副作用的方法，例如：</p>

<p><code>objective-c
[NSImage self];
</code></p>

<h2>Designated Initializers</h2>

<p>Designated initializer是类的init方法，它会调用父类的init方法。（其他的initializer调用类的init方法）。每个公用类应该至少有一个designed intializer.例如，NSView的initWithFrame:,NSResponder的init方法。这里init方法不是意味着覆盖，不像作为类簇的NSString和其他的抽象类，子类是期望去实现它自己的init方法。</p>

<p>Designated initializer应该标识清晰因为这些信息对于一个想要子类化的人很重要。子类仅需要覆盖designated initializer其他的初始化方法就能正常工作。</p>

<p>当你实现一个框架的类，你经常需要去实现像initWithCoder:和encodeWithCoder:的归档方法。在初始化代码中要小心点，不要去做反归档得到的对象不会发生的事情。如果你的类实现了归档，一个好的实现方法是你的designated initializer和initWithCoder:调用一段相同的程序。</p>

<h3>在初始化过程中检测错误</h3>

<p>好的初始化方法应该完全遵循以下步骤去保证正确的错误检测和传递：
调用父类的designated initializer给self重新赋值。
验证返回值是否为nil，它表明父类的初始化发生了一些错误。
如果现在当前类的初始化发生了错误，释放对象并返回nil。</p>

<p>Listing 1你应该怎么做的示例。
Listing 1  在初始化过程中检测错误
``` objective-c
&ndash; (id)init {</p>

<pre><code>self = [super init];  // Call a designated initializer here.

if (self != nil) {

    // Initialize object  ...

    if (someError) {

        [self release];

        self = nil;

    }

}

return self;

}
</code></pre>

<p>```</p>

<h1>版本化和兼容</h1>

<p>当你往框架时添加新的类或方法，通常没有必要给新的特性组指定新版本号。开发者通常（或者应该）在Objective-C的运行时进行检查，例如用respondsToSelector:去确定新的特性在给定的系统上是否可用。这些运行时的测试是验证新特性推荐和最动态的方法。</p>

<p>但是，你也可以使用一些技术去确保你的每个新版本框架都被合适的标识和尽可能的兼容早期的版本。</p>

<h2>框架版本</h2>

<p>当运行时测试不容易去检测到存在的新特性或修复的bug，你应该提供一些方法给开发者去检查发生的改变。一种实现方法是存储准确的框架版本号并让开发者能访问：
在版本号下编写更改文档。
设置框架的当前版本并让它全局可读取。你也许会把版本号存放在框架的信息属性列表（Info.plist）中然后访问它。</p>

<h2>加上归档键</h2>

<p>如果你框架的对象需要被写到nib文件中，它们必须能够归档它们自己。你也要使用文件数据归档机制去归档任何文档。
你应该考虑关于归档的以下问题：
如果归档的key丢失了，从它们中取值会返回nil, NULL, NO, 0或者0.0,这得看你取值的类型。判断它返回的值可以减少你写入的数据。另外，你可以查出键是否被写入归档中。
编码和解码方法都能做些事情去保证向后兼容。例如，新版本类的编码方法可能用键写新的值，但是仍然写到旧的地方，这样旧类仍能理解对象。另外，解码方法可能想用一些合理的方法处理丢失值去维护未来版本的灵活性。</p>

<p>框架类归档键的推荐命名惯例是加上框架中其他API元素使用的前缀然后加上实例变量的名字。仅仅保证名字不会和任何父类或子类冲突。</p>

<p>如果你有一个工具函数它写出基本的数据类型（换句话说，非对象值），确保使用唯一的键。例如，你有一个名为archiveRect的程序，它应该带一个键的参数去归档一个矩形，无论使用与否；或者，如果你写出多个值（例如，4个浮点数），它应该追加唯一的bits给提供的key.</p>

<p>归档位段对于编译器和大小端依赖时很危险。你应该只在出于性能原因，很多bits需要多次写出时才归档它们。查看”Bitfields”获得更多建议。</p>

<h1>异常和错误</h1>

<p>大多数Cocoa框架方法并不强制开发者捕获和处理异常。这是因为正常部分的执行不会抛出异常，除非运行和用户错误，通常它是不用来交流的。这些错误的例子包括：
文件没有找到
没有这个用户
应用程序尝试打开错误类型的文件</p>

<p>但是，Cocoa不会抛出异常去暗示如下的编程或者逻辑错误：</p>

<p>数组索引越界
尝试改变不可变对象
错误的参数类型</p>

<p>所谓异常是开发者将在测试期间捕获上述错误然后在传给应用之前解决它们。因此应用没有必要在运行时处理惯常。如果异常抛出而应用的各个部分都没有捕获它，通常最上层的默认处理方法会捕获它然后报告异常，之后继续执行。开发者可以选择替换默认的异常捕获，如给出更详细的错误信息，提供保证数据的机会或者退出应用。</p>

<p>错误是Cocoa框架与其他软件库另一个不同的地方。Cocoa方法通常不会返回错误代码。当有一个合理或者像错误的原因，方法会简单的依靠布尔或对象（nil/non-nil）返回值测试；返回NO或nil的原因会在文档中说明。你不应该在运行时使用错误代码标明程序错误需要处理，而应使用抛出异常或者简单打印错误来替代。</p>

<p>例如，NSDictionary的 objectForKey:方法返回找到的对象,如果对象没有找到则返回nil。NSArray的objectAtIndex:方法永远不能返回nil(除非覆盖通用的语言惯用像给nil发送消息返回nil)，因为NSArray对象不能存储nil值，而且在定义上任何越界访问都量程序错误应该抛出异常。许多初始化方法会返回nil当对象不能被 提供的参数初始化时。</p>

<p>在一些小众的情况下会有一些方法有对许多特定错误代码的合理需求，应该通过想着参数指定他们，返回错误代码，或者本地化错误字符串，或者天王终点其他错误描述信息。例如，你可能把错误作为一个NSError返回；查看NSError.h头文件了解更多细节。这个参数需要额外提供不像BOOL或nil是直接返回的。方法也应该遵守这样一个惯例，通过引用的参数是可选的，并且如果发送者不关心错误应该允许传递NULL作为error-code的参数。</p>

<h1>框架数据</h1>

<p>你处理框架数据的方式会影响性能，跨平台兼容和其他方面。这一部分讨论涉及框架数据的技术。</p>

<h2>常量数据</h2>

<p>因为性能的原因，尽可能的把常量标记为框架数据是推荐的做法，因为这样可以减少Mach-O二进制文件<strong>DATA段的大小。全局和静态变量不是const，它们在</strong>DATA段的__DATA部分。这种类型的数据会占用内存，当运行的应用使用了这类框架。虽然额外的500字节（例如）也许不是太糟，它可能造成需要许多页—-每个应用额外占用4KB.</p>

<p>你应该把任何常量数据都标记为const.如果没有char*指针在块中，这会导致数据被 放在<em>TEXT段（这成了真正的常量）。否则它会存在</em>DATA段但不允许写操作（unless prebinding is not done or is violated by having to slide the binary at load time。）。</p>

<p>你应该初始化静态变量保证它们被合并进<em>DATA段的</em>data部分，而不是在_bss部分。如果没有明显的值用作初始化，使用0,NULL, 0.0或任何合适的值。</p>

<h2>位段</h2>

<p>位段使用有符号的值，特别是一位的位段，如果代码假设值是布尔类型可能导致未定义行为。一位形式的位段应该总是无符号的。因为它只存像0和-1（依赖编译器实现）这样的唯一的值，拿这样一个位段与1想比较结果是false.例如，如果你的你代码遇到以下情况：</p>

<p>``` objective-c
BOOL isAttachment:1;</p>

<p>int startTracking:1;</p>

<p>```</p>

<p>你应该把类型改为unsigned int.</p>

<p>位段的其他问题是归档。通常，你不应该以它自身的形式把位段写到硬盘或者归档文件，因为当从其他的架构或者编译器读取时可能会不一样。</p>

<h2>内存分配</h2>

<p>在框架代码中，如果你能做到不一起分配内存是最好的.如果因为某些原因需要临时的缓存区，通常使用栈的缓存区经分配一个缓存区要好。但是，栈的大小有限制（通常总共是512kb)，所以决定使用栈还得考虑函数和缓存的大小。通常如果缓冲的大小是1000字节（或MAXPATHLEN）或更少，使用栈是可接受的。</p>

<p>如果缓冲的大小超过了栈的缓冲大小，就要使用malloc生成的缓冲了。</p>

<p>Listing 2 给出示例代码片段。</p>

<p>Listing 2  Allocation using both stack and malloc’ed buffer
``` objective-c</p>

<pre><code>#define STACKBUFSIZE (1000 / sizeof(YourElementType))

 YourElementType stackBuffer[STACKBUFSIZE];

YourElementType *buf = stackBuffer;

int capacity = STACKBUFSIZE;  // In terms of    YourElementType

 int numElements = 0;  // In terms of YourElementType


while (1) {

if (numElements &gt; capacity) {  // Need more room

    int newCapacity = capacity * 2;  // Or whatever your growth algorithm is

    if (buf == stackBuffer) {  // Previously using stack; switch to allocated memory

        buf = malloc(newCapacity * sizeof(YourElementType));

        memmove(buf, stackBuffer, capacity * sizeof(YourElementType));

    } else {  // Was already using malloc; simply realloc

        buf = realloc(buf, newCapacity * sizeof(YourElementType));

    }

    capacity = newCapacity;

}

// ... use buf; increment numElements ...

}

// ...

if (buf != stackBuffer) free(buf);
</code></pre>

<p>```</p>

<h1>对象比较</h1>

<p>你应该意识到通常对象的比较方法isEqual:和相关对象类型的比较方法，如isEqualToString:有重大差别. isEqual方法允许传入任意对象作为参数，如果对象不是相同的对象则返回NO.像isEqualToString:和isEqualToArray:方法，经常假定参数是指定的类型（它经常是方法的接收者）。它们因此不做类型检查，因而它们更快，不过这并不安全。对于需要从外部获取的值，例如，应用的信息属性列表或偏好，推荐使用isEqual:,因为它们安全；当类型是知道的时候，使用isEqualToString:替代。</p>

<p>关于isEqual:更深的点是它连接到hash方法。对于放到基于hash的Cocoa集合如NSDictionary或NSSet中的对象，f[A isEqual:B] == YES 和[A hash] == [B hash]的效果是一样的。因此，如果你覆盖isEqual:,那么你也应该覆盖hash来确保这个不变关系。isEqual方法默认会查找指向每个对象的指针地址，hash返回一个基于每个对象地址的hash值，因此它们的关系是不变的。</p>
]]></content>
  </entry>
  
</feed>
